[{"content":"电子系统的运作图 信号与放大器 信号 概念 Signal Contains Information Process 将信号变成人能理解的信息 Transducer 将信号从非电形式转成电信号 如何表示信号 戴维南电路 最好在$R_S$较低时\n对于一个简化的输出电路 $$ V_o = \\frac{R_L}{R_L+R_S}V_S \\\\\\ \\\\ 显然，R_S越小，V_0越接近V_S $$\n诺顿电路 最好在$R_S$较高时 模拟信号与数字信号 stateDiagram 模拟信号 --\u003e 取样 取样 --\u003e 量化 量化 --\u003e 数字信号 信号频谱 定义 根据谐波部分强度定义时域信号\n傅里叶级数 函数表示 $$ f(x) = \\frac{a_0}{2} + \\sum_{k=1}^\\infin \\big[ a_kcos(kx) + b_k sin(kx) \\big] \\\\\\ \\\\ a_k = \\frac{1}{\\pi} \\int_{-\\pi}^\\pi f(x) cos(kx)dx, k\\ge 0 \\\\\\ \\\\ b_k = \\frac{1}{\\pi}\\int_{-\\pi}^\\pi f(x)sin(kx)dx,k\\ge 1 $$\n","date":"2023-02-27T09:35:27Z","permalink":"https://downeyflyfan.com/p/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"信号与放大器"},{"content":"2023 2.25 Once upon a time, in the kingdom of Meganeton, there lived a brave and untamed prince. He was determined to ascertain the truth behind a long-standing dispute between his kingdom and its neighboring kingdom.\nThe prince was a brilliant scientist and he decided to pursue the matter using the latest scientific methods. He built a solenoid, a device that uses an electric current to create a magnetic field, to measure the viability of the mass medium between the two kingdoms.\nHe also used a logie, a device that measures the speed of sound, to measure the resonant frequency of the mass medium. He then used an insulator and coaxial cable to protect the device from interference.\nThe prince was intrigued when his experiment revealed that the mass medium was anisotropic, meaning it had different properties in different directions. He suspected that this was the source of the dispute.\nTo further investigate, the prince used a retarder, a device that slows down the speed of sound, to see if the properties of the mass medium could be changed. He then used cellophane to cover the retarder and see if it changed the properties of the mass medium.\nThe prince was delighted to find that the cellophane had indeed changed the properties of the mass medium. He was finally able to ascertain the truth behind the long-standing dispute and bring peace between the two kingdoms.\n2023 2.26 Once upon a time there lived a boorish prince who was always befuddling the courtiers with his austere attitude. He was so cajoling that no one could ever guess what he was thinking. He was known for his candor but his words were so sharp that they often left people exhausted.\nOne day, the prince decided to test the courtiers by giving them a difficult problem. He asked them to solve a combinatorial problem that involved partitioning a set of bolts into pairwise disjoint sets with different alleles. The courtiers were taken aback by the problem and tried their best to solve it but to no avail.\nThe prince, who was already in a bad mood, became even more frustrated and ordered them to solve the problem using the binomial axiom and an exhaustive search. The courtiers were now completely befuddled and exhausted. They had no idea how to proceed and begged the prince for mercy.\nHowever, the prince was in no mood to show mercy and continued to insist that they solve the problem. After much cajoling, the courtiers finally managed to solve the problem and the prince was satisfied. However, their solution was not perfect and had a few defects.\nThe prince, who was known for his abstinence, refused to accept the solution and demanded that they find a perfect solution. The courtiers, who were already exhausted, had no choice but to try again. After a long and tedious search, they finally managed to find a perfect solution and the prince was pleased.\nThe courtiers had finally managed to solve the problem, much to their posterior!\n","date":"2023-02-25T18:33:11Z","permalink":"https://downeyflyfan.com/p/%E5%8D%95%E8%AF%8D2023-2.25-3.4/","title":"单词(2023-2.25-3.4)"},{"content":" 什么是电路 RLC电路的解\n电路的变换\n","date":"2023-02-22T10:59:04Z","permalink":"https://downeyflyfan.com/p/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/","title":"查缺补漏"},{"content":"转移函数 定义 将电路方程从时域转为频域，获得一个关于$\\omega$的方程\n$$ H(\\omega) = \\frac{V_{out}}{V_{in}} $$\n相关概念 $$ |H(\\omega)|被称为magnitude \\ response，20lg(|H(\\omega)|)叫做\\pmb{Gain} \\\\\\ \\\\ \\angle H(\\omega)被称为phase \\ response $$\n理想滤波器 定义 通过特定频率的信号，阻碍不需要的频率的信号\n分类 LPF: Lowpass filter 低通滤波器\nHPF: Highpass filter 高通滤波器\nBPF: Bandpass filter 带通滤波器\nBSF: Bandstop filter 带阻滤波器\nGain 图示\nabcd分别对应1234 应用 RC电路 图示 推导 $$ H(\\omega) = \\frac{\\frac{1}{j\\omega C}}{\\frac{1}{j\\omega C}+R} = \\frac{\\frac{1}{RC}}{j\\omega + \\frac{1}{RC}} = \\frac{\\frac{1}{RC}}{\\sqrt{\\omega^2 + (\\frac{1}{RC}})^2}e^{-jtan^{-1}(\\omega RC)} \\\\\\ \\\\ \\therefore |H(\\omega)| = \\frac{\\frac{1}{RC}}{\\sqrt{\\omega^2 + (\\frac{1}{RC}})^2} \\\\\\ \\\\ \\angle H(\\omega) = tan^{-1}(\\omega RC) \\\\\\ \\\\ 当\\omega = \\frac{1}{RC}时，|H(\\omega)| = \\frac{1}{\\sqrt 2} ，Gain = 20lg(|H(\\omega)|) = -3.01(dB) \\\\\\ \\\\ 其中，\\omega_0 = \\frac{1}{RC}叫做3dB的截止频率 $$\n结论 RC电路是LPF（低通滤波器） CR电路 图示 推导 $$ 同理，H(\\omega) = \\frac{\\omega}{\\sqrt{\\omega^2 + (\\frac{1}{RC})^2}} e^{j\\Big[\\frac{\\pi}{2} - tan^{-1}(\\omega RC) \\Big]} \\\\\\ \\\\ |H(\\omega)| = \\frac{\\omega}{\\sqrt{\\omega^2 + (\\frac{1}{RC})^2}} \\\\\\ \\\\ \\angle H(\\omega) =\\frac{\\pi}{2} - tan^{-1}(\\omega RC) \\\\\\ \\\\ 当\\omega_0 = \\frac{1}{RC}时，可以得出与RC电路相同的计算结果 $$\n结论 CR电路是HPF(高通滤波器) 串联RLC低通滤波器 - RLC电路 图示 推导 $$ H(\\omega) = \\frac{\\frac{1}{LC}}{-\\omega^2 + \\frac{R}{L}j\\omega + \\frac{1}{LC}} \\\\\\ \\\\ |H(\\omega)| = \\frac{\\omega^2}{\\sqrt{\\Big(\\frac{1}{LC} - \\omega^2\\Big)^2 } + \\Big( \\frac{R}{L}\\omega\\Big)^2} \\\\\\ \\\\ \\angle H(\\omega) = \\pi - tan^{-1}\\Big(\\frac{\\frac{R}L{\\omega}}{\\frac{1}{LC}- \\omega^2} \\Big) \\\\\\ \\\\ 转角频率 \\omega_0 = \\frac{1}{\\sqrt{LC}} $$\n串联RLC高通滤波器 串联RLC带通滤波器 - LCR电路 图示 推导 $$ H(\\omega) = \\frac{\\frac{R}{L}j\\omega}{-\\omega^2 + \\frac{R}{L}j\\omega + \\frac{1}{LC}} \\\\\\ \\\\ |H(\\omega)| = \\frac{\\frac{R}{L}\\omega}{\\sqrt{\\Big(\\frac{1}{LC} - \\omega^2\\Big)^2 + \\Big( \\frac{R}{L}\\omega\\Big)^2}} \\\\\\ \\\\ \\angle H(\\omega) = \\frac{\\pi}{2} - tan^{-1}\\Big(\\frac{\\frac{R}L{\\omega}}{\\frac{1}{LC}- \\omega^2} \\Big) \\\\\\ \\\\ 转角频率 \\omega_0 = \\frac{1}{\\sqrt{LC}} \\\\\\ \\\\ 下截止频率 \\ \\omega_1 = -\\frac{R}{2L} + \\frac{R}{2L} \\sqrt{1 + \\frac{4L}{R^2C}} \\\\\\ \\\\ 上截止频率 \\ \\omega_2 = \\frac{R}{2L} + \\frac{R}{2L} \\sqrt{1 + \\frac{4L}{R^2C}} \\\\\\ \\\\ 3dB带宽 \\omega_{3dB} =\\omega_2 - \\omega_1 =\\frac{R}{L} $$\n串联RLC带阻滤波器 - RCL电路 电路 大小 相量 Gain 带宽 与LCR电路相同 并联RLC低通滤波器 电路 大小 相量 截止频率 并联RLC高通滤波器 电路 大小 相量 截止频率 并联RLC带通滤波器 并联RLC带阻滤波器 并联RLC的带通和带阻滤波器的带宽都是$\\frac{1}{RC}$ 其他电路 LR电路是LPF 附录 转角频率($\\omega_0$) 解方程$\\omega_0 = 1$得到\n截止频率 HPF和LPF的频率过滤临界点\n通过解方程$|H(\\omega)| = \\frac{1}{\\sqrt 2}$得到 判断滤波器类型 将$j\\omega$替换为$s$\n解方程$H(\\omega) = \\frac{1}{\\sqrt 2}$\n画出大致图像(开口方向和零点)\n即可得出滤波器类型 ","date":"2023-02-21T16:22:32Z","permalink":"https://downeyflyfan.com/p/%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"滤波器"},{"content":"实验背景 前提 光可以被偏振这一事实说明了光是横波，而不是纵波(因为纵波无法被偏振)\n光的能量是通过光子束传播的\n光在传播过程中，一般而言，电向量、磁向量与传播方向三者互相垂直\n偏振介绍 定义 光在传播过程中，电磁波振动方向不变，而电场振动方向在特定平面内振动的现象\n偏振光的类型(type) $Partially \\ polarized$ 光照到透明介质上，部分反射，部分折射,其中反射光被偏振，折射角被称为Brewster\u0026rsquo;s angle，在下图中有以下关系 $$ \\pmb{折射率 n = tan i} \\\\\\ \\\\ \\pmb{反射光与折射光垂直} $$\n$Totally \\ polarized$ 偏振光的状态(States) $linear$ 电场矢量在特定平面内振动，而垂直方向上不发生振动，这个垂直方向被称为偏振方向，一旦确定就不能改变\n线偏振光可以通过偏振片实现\n$circular$ 电场矢量大小不变，但始终绕光的传播方向旋转 $elliptical$ 被视为线偏振光与圆偏振光的混合 Polarizer 举例 Polaroid sunglasses\n它可以偏振阳光反射产生的眩光(glare from reflected sunlight) 对光偏振的方式 使用偏振片\n让光照射透明物体\n让光穿过各向异性的材料\n实验 实验目的 使用起偏器获得线性偏振光\n使用起偏器判断偏振的类型和状态\n偏振器可以使自然光变为线偏振光\n检偏器可以鉴别线偏振光、自然光和部分偏振光\n了解half-wave plate和quarter-wave plate的功能\n起偏器和检偏器在本质上是一样的\n了解波板的功能 实验器材 Diode laser: 二极管激光器\nDetector (to measure the intensity of light):侦测器\nTwo polaroid sheets:两块偏振片\nmicroammeter (to display the intensity of light): 微安计\nQuarter-wave and half-wave plates: 四分之一波板与半波板\n沿着fast axis的光直接穿过波板，而垂直方向上的光会与它产生$\\frac{\\lambda}{2}$或$\\frac{\\lambda}{4}$的相位差\n这就是双折射现象\n实验图示 Law of Malus $$ I = I_0 cos^2\\theta \\\\\\ \\\\ \\theta表示图中transmission \\ axis的夹角 $$\n实验过程 实验1: 证明Malus定律 实验2：证明半波板的功能 实验3：证明四分之一波板的功能 实验结论 1.\n数据和问题 问题 偏振现象如何证明光是横波 If we stack two polarizing filters together and make their polarization directions perpendicular to each other, then unpolarized natural light cannot pass through. Only when the polarization direction of the second polarizing filter is the same as that of the first one, can the polarized light pass through.\nThis demonstrates that light must be a transverse wave, because only transverse waves can be filtered to have a single direction of polarized light.\n区分自然光和偏振光 区分自然光和线偏振光\nPlace a polarizer in front of the light source and gradually rotate the direction of the polarizer. If the intensity of light remains unchanged, the light is linearly polarized because only linearly polarized light has polarization in a specific direction.\nIf the intensity of light changes as the polarizer rotates, the light is elliptically polarized or circularly polarized because they can be produced by the superposition of two orthogonally polarized linearly polarized lights.\nNatural light can be seen as the superposition of linearly polarized light in all possible polarization directions, so the intensity of light passing through the polarizer will change as the polarizer rotates.\n区分自然光和圆偏振光\nPassing natural light and circularly polarized light through a polarizer, such as a polarizing mirror or polarizing filter, reveals that the intensity of natural light is reduced by half after passing through the polarizer, while the intensity of circularly polarized light remains unchanged. ","date":"2023-02-20T09:40:14Z","permalink":"https://downeyflyfan.com/p/%E5%A4%A7%E7%89%A9%E5%AE%9E%E9%AA%8C%E8%80%83%E8%AF%95/","title":"大物实验考试"},{"content":"知识点 复习极坐标 ","date":"2023-02-13T19:42:46+08:00","permalink":"https://downeyflyfan.com/p/%E5%BA%94%E8%AF%95/","title":"应试"},{"content":"审题 between possible values 实际上就是between adjacent values 查缺补漏 光谱的名称与范围 可见光 大约$400nm - 750nm$ 波长 物质的波长一定要用德布罗意波的公式计算 $X$射线 $0.03 - 3nm$，数量级通常为$1nm$ 极化原子 = 离子 氢原子光谱和能级的推导 相对论的速度公式 Fine Structure 只考虑$n$就不是Fine Structure\n考虑$n,l,m_l,m_s$就是Fine Structure\n感应电荷 只在导体表面出现\n导体内部没有电场\n光电效应 金属的$W_0$在可见光的能量范围附近 技巧 氢原子电子的能量 其势能是动能的两倍，不论处在哪个能级 重要数值 $$ hc = 1.24\\times 10^3 (eV\\cdot nm) \\\\\\ \\\\ \\hbar = \\frac{h}{2\\pi} = 1.055\\times 10^{-34}(J\\cdot s) \\\\\\ \\\\ 1fm = 1 \\times 10^{-15} m \\\\\\ \\\\ 1kcal = 4.184kJ \\\\\\ \\\\ 1eV/molecule \\times N_A(6.02\\times 10^{23})\\times \\frac{1.60\\times 10^{-19}J/eV}{4186J/kcal} = 23.01(kcal/mol) $$\n","date":"2023-02-12T21:04:46+08:00","permalink":"https://downeyflyfan.com/p/%E5%BA%94%E8%AF%95/","title":"应试"},{"content":"对象 使用对象键值对 1 2 3 key: child-key1: value1 child-key2: value2 当对象较复杂，比如为数组时\n问号加一个空格代表一个复杂的 key\n一个冒号加一个空格代表一个 value\n1 2 3 4 5 6 ? - complexkey1 - complexkey2 : - complexvalue1 - complexvalue2 数组 以-开头的行表示一个数组 1 2 - A - B 支持多维数组 1 2 3 4 5 6 7 8 9 # 行内表示 key: [value1,value2] # 多行表示 - - A - B - C 很多元素$\\rightarrow$数组元素$\\rightarrow$数组 例子 1 2 3 4 5 6 7 8 9 10 11 companies: - id: 1 name: company1 price: 200W - id: 2 name: company2 price: 500W # 或者 companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}] 复合结构 例 1 2 3 4 5 6 7 8 9 languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 纯量 定义 最基本、不可再分的值\n分类 字符串 1 2 3 4 5 string: - 哈哈 - \u0026#39;Egnlish word\u0026#39; - newline newline2 #字符串可以被拆成多行，每行会被转换成一个空格 布尔值 1 2 3 boolean: - True # 或者true - False # 或者false 整数和浮点数 1 2 3 4 5 6 float: - 3.14 - 8.85E-12 # 可以使用科学记数法 int: - 123 - 0b1010_0111_0100_1010_1110 # 二进制表示 Null 1 2 3 null: nodeName: \u0026#39;node\u0026#39; parent: ~ # ~表示null 日期 1 2 date: - 2023-2-11 # 必须是这种格式 时间 1 2023-2-11T22:07:02+8:00 # 用+代表时区 引用(暂定) ","date":"2023-02-12T05:51:51+08:00","permalink":"https://downeyflyfan.com/p/yaml%E8%AF%AD%E6%B3%95/","title":"YAML语法"},{"content":"picom —— 让窗口更美丽 润色你的dwm 了解配置 删除旧配置config.h\n在新配置config.def.h中进行操作\n打补丁 ","date":"2023-02-12T00:45:54+08:00","permalink":"https://downeyflyfan.com/p/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","title":"图形界面"},{"content":"探究氢原子中的量子数(Quantum Number) 1.1 主量子数(Principal) $$ E_n = \\frac{-13.6eV(E_1)}{n^2} \\\\\\ \\\\ 此处的n即为主量子数 $$\n1.2 轨道量子数(Orbital) 轨道量子数$l$与电子的轨道角动量的大小有关系 $$ L = \\sqrt{l(l+1)}\\hbar \\\\\\ \\\\ \\pmb{0 \\le l \\le (n-1)} $$\n1.3 磁量子数(magnetic) 磁量子数表示轨道角动量的方向 $$ L_z = m_l \\hbar \\\\\\ \\\\ -l \\le m_l \\le l $$\n1.4 自旋量子数(spin) 自旋量子数表示自旋的方向 $$ m_s = +\\frac{1}{2} \\Leftrightarrow 上旋(Spin \\ Up) \\\\\\ \\\\ m_s = -\\frac{1}{2} \\Leftrightarrow 下旋(Spin \\ Down) \\\\\\ \\\\ 电子的自旋角动量S = \\sqrt{s(s+1)}\\hbar = \\frac{\\sqrt{3}}{2}\\hbar $$\n1.5 总结 在氢原子中，只有$n$影响能量 在其他原子中，$n$和$l$对电子能量的影响最大，$m_l$和$m_s$影响甚微 1.6 电子的跃迁 Selection Rule 电子跃迁的轨道角动量变化只可能是$\\Delta l = \\pm 1$之间,\n其他范围(包括$l=0$)叫做forbidden transition\n氢原子波方程 2.1 基态氢原子薛定谔方程的解 $$ \\psi_{100} = \\frac{1}{\\sqrt{\\pi r_0^3}}e^{-\\frac{r}{r_0}} \\\\\\ \\\\ 其中, r_0 = \\frac{h^2 \\varepsilon_0}{\\pi me^2} = 0.0529(nm),为\\pmb{波尔半径} \\\\\\ \\\\ \\psi的下标分表表示n,l,m_l $$\n2.2 氢原子中电子的概率分布 基态 $$ 假设P_r 是电子的半径分布概率，则 \\\\\\ \\\\ P_rdr 可以看作电子分布在半径r处的概率 \\\\\\ \\\\ 对于一个球壳来说，其体积 \\\\\\ \\\\ dV = 4\\pi r^2 dr \\Longrightarrow |\\psi|^2 dV = |\\psi|^2 4\\pi r^2 dr \\\\\\ \\\\ \\therefore P_r dr = |\\psi|^2 dV \\Longrightarrow P_r = 4\\pi r^2 |\\psi|^2 \\\\\\ \\\\ 对于基态氢原子，P_r = 4\\frac{r^2}{r_0^3}e^{-\\frac{2r}{r_0}} $$\n非基态的一些解 $$ \\psi_{200} = \\frac{1}{\\sqrt{32\\pi r_0^3}} (2-\\frac{r}{r_0})e^{-\\frac{r}{2r_0}} \\\\\\ \\\\ P_{r200} = \\frac{1}{8}\\frac{r^2}{r_0^3}(2-\\frac{r}{r_0})^2 e^{-\\frac{r}{r_0}} \\\\\\ \\\\ \\psi_{210} = \\frac{Z}{\\sqrt{32\\pi r_0^5}}e^{-r/2r_0} \\\\\\ \\\\ \\psi_{211} = \\frac{x + iy}{\\sqrt{64 \\pi r_0^5}}e^{-r/2r_0} \\\\\\ \\\\ \\psi_{21-1} =\\frac{x - iy}{\\sqrt{64 \\pi r_0^5}}e^{-r/2r_0} $$\n元素周期表 泡利不相容原理 定义 每个轨道只能容纳两个电子，且自旋相反配对\n即每个电子的四个量子数不可能完全相同 能量最低原理 原子的基态是能量最低的状态\n洪特规则 电子分布到能量能级相同的轨道时，优先以自旋相同的方式分别占据不同的轨道\n元素周期表 1.$Subshell$与$l$的关系\n元素周期表 X射线和原子数 产生原因 由高能电子撞击X射线管道中的特定金属产生\nX-射线 光强 —— 波长 关系图 随着撞击电子的能量(即加速撞击电子的电压)增高，$\\lambda_0$减小\n$K_{\\alpha}$和$K_{\\beta}$两个峰体现了被撞击材料的特性,不因入射电子能量的改变而改变\n关系 $$ 电子从n=2向n=1跃迁的过程中产生了K_{\\alpha}\\\\\\ \\\\ \\lambda_{min} \\propto \\frac{1}{(Z-1)^2} \\\\\\ \\\\ \\lambda_{min}：最短的X射线 $$\n电子与光子撞击过程中的能量转换 $$ E = hf_0 =eV \\\\\\ \\\\ \\therefore \\lambda_0 =\\frac{hc}{eV} $$\n磁偶极矩 总角动量* 磁偶极矩 $$ \\mu = IA = \\frac{1}{2}evr \\\\\\ \\\\ 又L = mvr \\\\\\ \\\\ \\therefore \\mu = \\frac{1}{2}\\frac{e}{m}L \\\\\\ \\\\ 由于电流中是电子(附点),所以磁偶极矩与角动量反向 \\\\\\ \\\\ \\begin{align} \\therefore \\pmb{\\mu} = -\\frac{1}{2}\\frac{e}{m}\\pmb{L} \\\\ U =- \\pmb{\\mu \\cdot B} \\end{align} \\\\ 假设B都在z方向上 \\\\\\ \\begin{align} 有 U = -\\mu_z \\cdot B_z \\\\ 又L_z = m_l\\hbar \\end{align} \\\\\\ \\\\ 可以得到\\mu = - \\frac{e\\hbar}{2m}m_l \\\\\\ \\\\ 其中\\mu_B = \\frac{e\\hbar}{2m} = 9.27 \\times 10^{-24}(J/T)，被称作\\pmb{玻尔磁子} \\\\\\ \\\\ 有 \\mu = - \\mu_B m_l $$\n","date":"2023-02-10T22:28:52+08:00","permalink":"https://downeyflyfan.com/p/%E5%8E%9F%E5%AD%90%E7%9A%84%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/","title":"原子的量子力学"},{"content":"一、二进制的数字表达 1.1 $r$进制数的大小 $$ 已知 r = (a_{n-1}a_{n-2}\u0026hellip;a_0a_1\u0026hellip;a_{-m})r \\\\\\ \\\\ 则其大小R = a_{n-1}\\times r^{n-1} + \u0026hellip; + a_{-m}\\times r^{-m} = \\sum_{i=-m}^{n-1}a_i\\times r^i $$\n最左边的叫高阶位(High-order Bit)或最高有效位(Most Significant Bit)，对应的权最大\n最右边的叫低阶位(Low-order Bit)或最低有效位(Least Significant Bit)，对应的权最小\n逢基数进1\n1.2 重要概念 数码(Digit) 构成数的数字 数位(Digit Pisition) 每个数码所处的位置 基数(Base/Radix) 决定数码有多少类 权(Weight) 1.3 二进制数的转换 二进制与十进制 十进制$\\rightarrow$ 二进制\n用十进制数除以2，反写得出二进制数 二进制到八进制和十六进制 关系图 转换技巧\n整数在前面补零\n小数在后面补零\n注意 十六进制数码被称为半字节(Nibble)\n一串数码又称为一个字(Word)\n小数点前的数字都是整数，后的都是小数，适用于任何进制\n","date":"2023-02-10T20:05:54+08:00","permalink":"https://downeyflyfan.com/p/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E6%81%AF/","title":"二进制信息"},{"content":"一、电子系统 1.1 图示 1.2 模拟信号 定义 模拟真实物理量变化的信号形式，例: 麦克风记录的语音信号，图像各点的亮度变化\n特点 连续信号，在任何时间都没有确定的值 以麦克风为例 1.3 数字信号 定义 离散信号(Discrete Signal),在任何时间都有确定的值\n特点 采样密度越高，越接近于模拟信号 脉冲信号 1.4 数电和模电 如何保存信号 stateDiagram 模电 --\u003e 数电:将原始(模拟)信号转化为数字电路(ADC) 数电 --\u003e 模电:恢复模拟信号(DAC) DAC后的模电信号不是原始信号的精确复制 数字电路的优点 数字信号更稳定，不易失真 (High stability,High reliability) 长期存储，无限复制\n易于设计(Easy to Desgin)\n可编程性 ( P rogramming )\n可实时控制 (Real-time Control)\n快速(Fast Speed)\n经济性(Economic)\n二、实现数字系统的方法 2.1 编程微处理器 (A programmed microprocessor) 2.2 固定的数字电路 (Fixed Digital Circuit) 在不同的步骤中，微处理器和数字电路的效率不同，需要平衡两者的效率\n三、数字系统设计 3.1 组成 逻辑门(Gates) 触发器(Flip-Flops) 计数器(Counter) 寄存器(Register) 逻辑器件(Logic Devices) 3.2 层次结构(由低到高) 元件级(第1级) 如电阻、电容、二极管、传感器、晶体管\n它们组成功能块(Funciton Block),被看作更大功能单元的组成单位\n第2 - 4 级 $1IC \\ (SSI \\ Small-scale Integration)$\n$2IC \\ (MSI \\ LSI \\ Medium\u0026hellip; \\ Large\u0026hellip;)$\n$3IC \\ (VLSI \\ Very \\ Large \u0026hellip;)$\n专用（半定制）IC (Application-Specific IC,$ASIC$)\n它通过制造商提供的标准构建实现结构化\n第5级 3.3 为降低成本生产的单元 3.3.1 标准单元(Standard Cells)库 MSI Decoder Register Counter LSI Memories Programmable Logic Array(PLA) 可编程逻辑阵列\nMicroprocessors\n3.3.2 门阵列(Gate Array) 内部结构尚未指定 由设计者指定门类型(Gate Type)和连接(Interconnection) 3.3.3 两者的区别和联系 门阵列和宏单元不能像标准单元设计那样进行高度优化\n3.4 PLD PLD(Programmable Logic Device)\nCPLD (Complex Programmable Logic Device)\nFPGA (Field Programmable Gates Array)\n3.5 数字系统设计流程 ","date":"2023-02-07T20:06:02+08:00","permalink":"https://downeyflyfan.com/p/%E5%BC%95%E8%AE%BA/","title":"引论"},{"content":"波运动的特点 波源来自振动\n振幅 $A$\n波峰的高度 波长 $\\lambda$ 波峰之间的距离 周期$T$\n频率$f = \\frac{1}{T}$\n单位时间内经过某给定点的波峰(周期)数量 波的速度$v$ 波峰移动的速度 $$ v = \\lambda f $$\n波的类型 横波 定义 振动方向与运动方向垂直的波\n横波的移动速度 决定因素 介质 在细绳上横波的速度 图示 推导 $$ SHM \\Longrightarrow F \\propto x \\\\\\ \\\\ \\therefore \\frac{F_y}{F_T} = \\frac{v\u0026rsquo;t}{vt} = \\frac{v\u0026rsquo;}{v} \\\\\\ \\\\ F_y t = \\Delta p = \\Delta m\\cdot v \\\\\\ \\\\ F_T t \\cdot \\frac{v\u0026rsquo;}{v} = F_y t = (\\mu vt)v\u0026rsquo; \\\\\\ \\\\ \\therefore \\pmb{v = \\sqrt{\\frac{F_T}{\\mu}}} $$\n纵波 定义 振动方向与运动方向相同的波\n纵波的特点 在纵波中，压缩和扩张对应着横波中的波峰和波谷\n常见的纵波\n声波 纵波速度 $$ v = \\sqrt{\\frac{elastic \\ force \\ factor}{inertia \\ factor}} \\\\\\ \\\\ 在长绳中， v= \\sqrt{\\frac{E}{\\rho}},弹性系数 \\\\\\ \\\\ 在流体中，v = \\sqrt{\\frac{B}{\\rho}},体积系数 $$\n其他的波 表面波 定义 在两种物质的交界处的波\n实例 水面波\n地震的表面波\n波的能量 波的运动方程 运动方程 $$ y(x,t) = Acos(\\omega t \\pm \\frac{\\omega}{v}x + \\varphi) \\\\\\ \\\\ \\omega = \\frac{2\\pi}{T} \\\\\\ \\\\ Wave \\ number \\ k = \\frac{2\\pi}{\\lambda} = \\frac{\\omega}{v} \\\\\\ \\\\ 表示\\pmb{相位随距离的变化率}或\\pmb{2\\pi 长度内的全波数目} \\\\\\ $$\n波的能量与强度 波的运动是能量的传播 $$ 对于 SHM \\\\\\ \\\\ dm = \\rho S dx \\\\\\ \\\\ dE = \\frac{1}{2} dm \\omega^2 A^2 \\\\\\ \\\\ \\therefore dE = \\frac{1}{2}\\rho S dx \\omega^2A^2 \\\\\\ \\\\ \\overline{P} = \\frac{dE}{dt} = \\frac{1}{2} \\rho S v \\omega^2 A^2 \\\\\\ \\\\ I = \\frac{\\overline{P}}{S} = \\frac{1}{2}\\rho v\\omega^2 A^2 $$\n叠加原理 反射和传播 干涉 光电干涉结果 幅度与光强 $$ 幅度: A = \\sqrt{A_1^2 + A_2^2 +2A_1A_2cos\\Delta \\varphi} \\\\\\ \\\\ \\Delta \\varphi = k\\Delta r = \\frac{2\\pi}{\\lambda} \\Delta r \\\\\\ \\\\ I = I_1 + I_2 + 2\\sqrt{I_1I_2}cos{\\Delta \\varphi} $$\n亮与暗 $$ \\Delta \\varphi = 2m\\pi \\Longrightarrow \\Delta r = m \\lambda \\Longrightarrow I_{max} \\\\\\ \\\\ \\Delta \\varphi = (2m + 1) \\pi \\Longrightarrow \\Delta r = (m + \\frac{1}{2}) \\lambda \\Longrightarrow I_{min} $$\n干涉的类型 双缝干涉 条件 单色光照到两个缝上 杨氏双缝干涉实验 图示 公式 $$ \\Delta r = r_2 - r_1 \\approx dsin\\theta \\\\\\ \\\\ 亮纹: dsin\\theta = m \\lambda \\\\\\ \\\\ 暗纹：dsin\\theta = (m+\\frac{1}{2}) \\lambda \\\\\\ \\\\ 又sin\\theta \\approx tan\\theta = \\frac{x}{L} \\\\\\ \\\\ \\therefore 亮纹:x = \\frac{L}{d} \\cdot m\\lambda \\\\\\ \\\\ 暗纹：x = \\frac{L}{d}(m+\\frac{1}{2}) \\lambda \\\\\\ \\\\ 当\\theta \\rightarrow 0 时: \\theta \\approx sin\\theta \\\\\\ \\\\ \\therefore \\Delta \\theta_{max} = \\frac{\\lambda}{d} $$\nThin films —— 反射与干涉 条件:光从两个表面反射 光程差(OPD) $$ \\delta = n_1r_1 - n_2r_2 \\\\\\ \\\\ \\Delta = 2n_2 t(+\\frac{\\lambda}{2}) = \\begin{cases} m\\lambda \u0026amp; bright \\\\ (m+\\frac{1}{2})\\lambda \u0026amp; dark \\end{cases} $$\n驻波 共鸣 衍射与偏振 单缝衍射 图示\n光程差\n$$ \\delta = \\overline{BP} - \\overline{AP} = \\overline{BC} = asin\\theta $$\n半波法 将缝以半波长等分\n两个光程差为$\\frac{\\lambda}{2}$的区域会抵消\n这样我们有以下结论\n$$ 亮:asin\\theta = m\\lambda \\\\\\ \\\\ 暗：asin\\theta =(m+\\frac{1}{2})\\lambda $$\n","date":"2023-02-01T19:09:12+08:00","permalink":"https://downeyflyfan.com/p/%E6%B3%A2%E7%9A%84%E8%BF%90%E5%8A%A8/","title":"波的运动"},{"content":"海森堡不确定性原理 1.1 内容 一个物体的动量和它的位置不可能被同时准确地观测到\n1.2 解释 原理 需要用光子撞击电子才能知道它的位置,而撞击会增加电子的动量，改变其位置 根据$p = \\frac{h}{\\lambda}$ 波长越大，动量越大，动量测不准，位置也会改变\n波长越小，动量太小，仪器没法精确测量，位置不准\n1.3 公式 动量和位置 $$ 对于波长为\\lambda的光子 \\\\\\ \\\\ \\Delta x \\approx \\lambda \\\\\\ \\\\ \\Delta p \\approx \\frac{h}{\\lambda} \\\\\\ \\\\ \\therefore (\\Delta x)(\\Delta p) \\approx h \\\\\\ \\\\ 根据海森堡的精确计算(这课本真省事) \\\\\\ \\\\ (\\Delta x)(\\Delta p) \\ge \\frac{h}{2\\pi} $$\n能量与时间 $$ \\Delta E = hf = \\frac{hc}{\\lambda} \\\\\\ \\\\ \\Delta t \\approx \\frac{\\lambda}{c} \\\\\\ \\\\ (\\Delta E )(\\Delta t) = h \\\\\\ \\\\ (\\Delta E )(\\Delta t) \\ge \\frac{h}{2\\pi} \\\\\\ \\\\ 科学家们给这个常用的量换了个名字: \\ \\hbar = \\frac{h}{2\\pi} $$\n一维薛定谔方程时间无关形式 2.1 不考虑时间 $$ 假设\\psi(x) = Asinkx + Bcoskx \\\\\\ \\\\ k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi p}{h} = \\frac{p}{\\hbar} (1)\\\\\\ \\\\ \\frac{d^2\\psi(x)}{dx^2} = -k^2 \\varphi(x) (2)\\\\\\ \\\\ 根据能量守恒 \\\\\\ \\\\ K + U = E \\ \\ \\ \\ 动能 + 势能 = 总能量 \\\\\\ \\\\ \\frac{p^2}{2m} + U = E (3)\\\\\\ \\\\ 根据(1)式 ， p = k\\hbar \\\\\\ \\\\ \\therefore \\frac{k^2\\hbar^2}{2m} + U =E (4)\\\\\\ \\\\ 结合(2)和(3)式，-\\frac{\\hbar^2}{2m} \\frac{d^2\\psi(x)}{dx^2} = \\frac{\\hbar^2k^2}{2m}\\varphi(x) \\\\\\ \\\\ 对(4)式两端乘以\\psi(x),得到\\pmb{一维薛定谔方程的无时间形式} \\\\\\ \\\\ -\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} + U(x) \\cdot \\varphi(x) = E\\cdot \\varphi(x) $$\n2.2 三维形式 将上式的$(x)$改为$(x,y,z)$即可\n2.3 一维形式的正交化条件 $$ \\int_{三维} |\\psi|^2dV = \\int_{一维} |\\varphi|^2dx = 1 $$\n薛定谔方程的时间有关形式* 公式 $$ -\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} + U(x) \\cdot \\psi(x,t) = i\\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} \\\\\\ \\\\ 很多时候， \\psi(x,t) = \\varphi(x)\\cdot f(t)\\\\\\ \\\\ \\therefore -\\frac{\\hbar}{2m} \\frac{d\\varphi^2(x)}{dx^2}\\cdot f(t) + U(x) \\cdot \\varphi(x)\\cdot f(t) = i\\hbar \\frac{df(t)}{dt}\\varphi(x) \\\\\\ \\\\ 两边同时除以f(t)\\cdot \\varphi(x) \\\\\\ \\\\ -\\frac{\\hbar}{2m}\\frac{1}{\\varphi(x)} \\frac{d\\varphi^2(x)}{dx^2} + U(x) = i\\hbar \\frac{1}{f(t)} \\frac{df(t)}{dt} = C \\\\\\ \\\\ 对于上式，两边分别只有一个变量 \\\\\\ \\\\ 故分别让两边等于同一个常数即可 \\\\\\ \\\\ -\\frac{\\hbar}{2m} \\frac{d^2\\varphi(x)}{dx^2} +U(x) \\varphi(x) = C\\varphi(x) \\\\\\ \\\\ 注意到，上式与时间无关的以为薛定谔方程相同 \\\\\\ \\\\ \\therefore C = E \\\\\\ \\\\ \\therefore i\\hbar \\frac{1}{f(t)} \\frac{df(t)}{dt} = E \\\\\\ \\\\ \\therefore \\frac{df(t)}{dt} = -i\\frac{f(t)}{\\hbar} E \\\\\\ \\\\ 解得：f(t) = e^{-i(\\frac{E}{\\hbar})t} \\\\\\ $$\n波的方程 $$ \\psi(x,t) =\\varphi(x) e^{-i(\\frac{E}{\\hbar})t}\\\\\\ \\\\ 根据欧拉公式：|f(t)| =1 \\Longrightarrow |f(t)|^2 = 1 \\\\\\ \\\\ \\therefore |\\psi(x,t)|^2 = |\\varphi(x)|^2 $$\n自由粒子 平面波 波包 自由粒子 不受任何外力的粒子\n其势能为0 自由粒子的薛定谔方程 $$ \\frac{d^2\\psi(x)}{dx^2} + \\frac{2mE}{\\hbar^2}\\psi(x) = 0 \\\\\\ \\\\ 其中, k =\\frac{2\\pi}{\\lambda} = \\frac{p}{\\hbar} = \\sqrt{\\frac{2mE}{\\hbar^2}} $$\n粒子在无限深的井中的势能 5.1 图示 $$ 我们规定 \\\\\\ \\\\ U(x) = \\begin{cases} 0 \u0026amp; 0 \\lt x \\lt L \\\\ \\infin \u0026amp; x \\le 0 \\ or \\ x \\ge L \\end{cases} $$\n5.2 波方程 $$ 当x \\lt 0 \\ or \\ x \\gt L ，U(x) = \\infin \\\\\\ \\\\ 为了使得薛定谔方程成立，U(x) \\cdot \\psi(x)= 0 \\\\\\ \\\\ \\therefore \\psi(x) =0 \\\\\\ \\\\ 我们认为一个波函数是\\pmb{连续的} \\\\\\ \\\\ \\therefore 当x= 0和x = L 时，\\psi(x) = 0 \\\\\\ \\\\ \\psi(0) = B = 0\\\\\\ \\\\ \\psi(L) = A\\cdot sinkL = 0 \\\\\\ \\\\ \\therefore k = \\frac{n\\pi}{L} \\\\\\ \\\\ \\therefore \\psi_n(x) = Asin\\frac{n \\pi}{L}x\\\\\\ \\\\ 根据归一化条件 \\\\\\ \\\\ \\int_{0}^{L} |\\psi(x)|^2dx = 1 \\\\\\ \\\\ 解得: A = \\sqrt{\\frac{2}{L}} \\\\\\ \\\\ \\therefore \\psi_n(x) =\\sqrt{\\frac{2}{L}}sin\\frac{n\\pi}{L}x $$\n5.3 能量方程 方程 $$ \\because k = \\sqrt{\\frac{2mE}{\\hbar^2}} \\\\\\ \\\\ E_n = \\frac{k^2\\hbar^2}{2m} = n^2 \\frac{h^2}{8mL^2} \\\\\\ \\\\ \\therefore E_1 =\\frac{h^2}{8mL^2},\\pmb{零点能量} $$\n观察与解释 $$ p = \\frac{h}{\\lambda} = \\hbar k = n\\hbar\\frac{\\pi}{L} \\\\\\ \\\\ p与L 成反比 $$\n这可以理解为不确定性原理的一种体现 粒子在有限深井中的势能 6.1 图示 6.2 波方程 $$ 设 \\psi = Asinkx + Bcoskx \\\\\\ \\\\ -\\frac{\\hbar^2}{2m} \\frac{d^2\\psi}{dx^2} + U\\psi = E\\psi \\\\\\ \\\\ \\frac{d^2\\psi}{dx^2} - \\Big[\\frac{2m(U_0 -E)}{\\hbar^2}\\Big] \\psi = 0 \\\\\\ \\\\ 设G^2 = \\frac{2m(U_0-E)}{\\hbar^2} \\\\\\ \\\\ \\pmb{当U_0 \\gt E}时: \\\\\\ \\\\ \\psi_{I,III} = Ce^{Gx} + De^{-Gx} \\\\\\ \\\\ 在I处，x \\lt 0 \\Longrightarrow 当x \\rightarrow -\\infin 时, \\psi \\rightarrow +\\infin \\\\\\ \\\\ 这显然不可能，故D = 0 \\\\\\ \\\\ 同理，在III处，C = 0 \\\\\\ \\\\ 我们得到 \\begin{cases} \\psi_I = Ce^{Gx} \\\\ \\psi_{III} = De^{-Gx} \\end{cases} \\\\\\ \\\\ 由于波方程是连续且可微的 \\\\\\ \\\\ 故有x =0 时: \\psi_I = \\psi_{II}，\\frac{d\\psi_I}{dx} = \\frac{d\\psi_{II}}{dx} \\\\\\ \\\\ x= L时: \\psi_{II} = \\psi_{III} ，\\frac{d\\psi_{II}}{dx} = \\frac{d\\psi_{III}}{dx} \\\\\\ \\\\ 解得 \\pmb{B = C， GC = kA} $$\n6.3 另一种情况 $$ 当U_0 \\lt E \\\\\\ \\\\ 我们有 \\lambda =\\begin{cases} \\frac{h}{p} = \\frac{h}{\\sqrt{2mE}} \u0026amp; 0 \\le x \\le L \\\\ \\frac{h}{p} = \\frac{h}{\\sqrt{2m(E-U_0)}} \u0026amp; x\\gt L \\ or \\ x \\lt 0 \\end{cases} \\\\\\ $$\n穿越障碍 7.1 图示 7.2 解释 前提：$U_0 \\gt E$\n有一部分粒子会穿过障碍，如图(b)所示\n$$ 假设穿过概率为T,反弹概率为R,有T+R = 1 \\\\\\ \\\\ 当T 非常小时 \\\\\\ \\\\ T = \\frac{|\\psi(L)|^2}{|\\psi(0)|^2} = e^{-2GL} $$\n","date":"2023-02-01T07:03:55+08:00","permalink":"https://downeyflyfan.com/p/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/","title":"量子力学"},{"content":"一、安装except 1.1 安装依赖tcl 1 2 3 4 5 wget https://sourceforge.net/projects/tcl/files/Tcl/8.4.19/tcl8.4.19-src.tar.gz tar zxvf tcl8.4.19-src.tar.gz cd tcl8.4.19/unix \u0026amp;\u0026amp; ./configure make sudo make install 1.2 下载并安装except 1 2 3 4 5 6 7 wget http://sourceforge.net/projects/expect/files/Expect/5.45/expect5.45.tar.gz # tar zxvf expect5.45.tar.gz # cd expect5.45 # ./configure --with-tcl=/usr/local/lib --with-tclinclude=../tcl8.4.19/generic # make # sudo make install # ln -s /usr/local/bin/expect /usr/bin/expect 二、用法 2.1 概述 1 except [选项][ -c cmds] [ [ -[f|b] ] cmdfile] [ args] 2.2 常见用法 开启子程序 1 spawn program 自动交互 1 2 3 4 5 6 7 8 9 10 11 expect { \u0026#34;字符串A\u0026#34; { send \u0026#34;字符串B\u0026#34;; exp_continue } \u0026#34;字符串C\u0026#34; { send \u0026#34;字符串D\u0026#34;; exp_continue } ... } expect eof 注意事项 用#!/usr/bin/expect作为开头\nexpect文件以.exp作为后缀\n","date":"2023-01-29T05:05:05+08:00","permalink":"https://downeyflyfan.com/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%84%9A%E6%9C%AC/","title":"自动化交互式脚本"},{"content":"一、购买服务器 选择操作系统 建议选择Debian系统 二、连接服务器 输入命令ssh root@IP\n输入服务器密码\n升级\napt update\napt upgrade\n在服务器中增加安全组,开放1194端口,并关联实例\n注意内外网问题\n三、服务器操作 3.1 创建新用户并赋予sudo权限 创建新用户 1 adduser \u0026lt;username\u0026gt; 在管理员账号下 1 adduser \u0026lt;username\u0026gt; sudo 注意 useradd比adduser功能更强大 3.2 下载openssh-server 下载 1 sudo apt install openssh-server 检查ssh运行状态 1 sudo systemctl status ssh 看到active(running)即为正常运行,否则开启该服务 1 sudo systemctl start ssh 在本地端bashrc中加入alias ssh='TERM=xterm-256color ssh'\n进入服务器，并输入\n1 2 sudo apt install curl # 安装curl curl -sSL https://raw.githubusercontent.com/alacritty/alacritty/master/extra/alacritty.info | tic -x - 3.3 关闭防火墙 1 2 3 4 5 6 sudo apt install lsof # 安装lsof命令 sudo lsof -l -P -n | grep LISTEN # 查看端口状态 sudo apt install ufw # 安装ufw命令 sudo ufw allow 22 sudo ufw allow 1194 # 开放以上两个端口 3.5 下载openvpn 1 sudo apt install openvpn 3.6 下载指定脚本并运行 下载 1 2 3 4 curl -O https://raw.githubusercontent.com/Angristan/openvpn-install/master/openvpn-install.sh chmod 775 openvpn-install.sh sudo ./openvpn-install.sh sudo chmod 775 flyfan.ovpn # 改变权限 安装选项 DNS resolver选择Google 四、传输文件 4.1 从本地到远程 1 scp 本地路径 USER_NAME@IP:远程路径 4.2 从远程到本地 1 scp USER_NAME@IP:远程路径 本地路径 五、连接VPN 5.1 设置SSH密钥 创建密钥 1 ssh-keygen # 不要Overwrite 在**.ssh**中查看密钥 id_rsa是私人密钥 id_rsa.pub是公共网络密钥 将SSH密钥添加到远程 1 ssh-copy-id -i ~/.ssh/id_rsa.pub \u0026lt;USERNAME\u0026gt;@IP 注意!!!管理员用户和普通用户都要添加 让SSH密钥成为唯一的登录密码 1 sudo vi /etc/ssh/sshd_config 找到PasswordAuthentification并改成yes 5.1 在本地电脑安装openvpn及其配件 1 sudo pacman -S openvpn networkmanager-openvpn 5.2 安装openssh-client 5.2 将远端配置下载到本地 1 scp USER_NAME@IP:/home/flyfan/flyfan.ovpn Downloads/ flyfan是用户名 5.3 将配置复制到openvpn的配置文件中 1 sudo cp Downloads/flyfan.ovpn /etc/openvpn/client/client.conf 5.4 运行 1 sudo openvpn /etc/openvpn/client/client.conf 六、Debian系统的一些指令 6.1 apt 指令 删除包 1 apt remove pkg 安装 ","date":"2023-01-24T20:03:44+08:00","permalink":"https://downeyflyfan.com/p/%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"搭建服务器"},{"content":"一、分析问题 1.1 概念 star ratings 范围 1 - 5\n衡量顾客满意度的评分\nreviews 客户的文字评价 helpfulness ratings 客户对于其他用户的reviews的评价 1.2 深入具体问题 三种产品 microwave oven\nbaby pacifier\nhair dryer\n分析过去顾客的 关键模式\n关系\n措施\n参数\n1.3 要求 分析数据，在star ratings、reviews和helpfulness ratings中找出定性定量的模式、关系、措施、参数\n解决以下问题\n当该公司促销时，根据ratings和reviews确定数据度量\n根据数据组分析产品评价随时间的变化的基于时间的 措施和模式\n确定reviews和ratings的最佳组合(即文字评价和打星评价的组合)\n判断一个产品的优劣 打几星的人更喜欢做文字评论\n文字评价中的词汇，例如disappointed,enthusiastic和打几星关系密切\n1.4 论文引用格式 [No. ]\u0026lt;名(首字母)\u0026gt;.\u0026lt;姓(全)\u0026gt;,\u0026quot;\u0026lt;论文标题\u0026gt;,\u0026quot;\u0026lt;期刊名称\u0026gt;,vol.\u0026lt;卷号\u0026gt;,no.\u0026lt;期号\u0026gt;,pp\u0026gt;\u0026lt;起始页码-终止页码\u0026gt;,\u0026lt;年份\u0026gt;\n二、解决问题 第一个大问题 剔除无效数据，在三种评价之间找关系\n第二个大问题 问题a 剔除无效信息结合reviews和ratings得出measures\n问题b 以时间为横坐标，将每天的评价量化(具体见问题c)作为纵坐标画图看趋势。\n问题c 将文字评论中的褒义词和贬义词量化为数字。对于每一组数据，将星级，量化数据和helpful vote相加，总和即位评判标准\n问题d 直接统计每个星级做评论的人数，然后比较，得出结论\n问题e 列出常用的英文褒义词和贬义词并分类，找出他们对应的星级并进行统计，得出结论\n","date":"2023-01-08T01:53:39+08:00","permalink":"https://downeyflyfan.com/p/2020_mcm_c/","title":"2020_MCM_C"},{"content":"一、误差与数值计算基本原则 避免绝对值小的数做除数\n避免两相近数相减\n避免大数“吃”小数现象\n尽量减少工作量\n例1: 秦九沼算法\n例2: 数值不稳定计算\n$$ \\begin{align} I_{n} = e^{-1}\\int_0^1 x_ne^x dx , n =0,1,2,\u0026hellip;20 \\\\ \\int_0^1 x^n dx \\le \\int_0^1 x_ne^x dx \\le \\\\\n\\end{align} $$\n二、非线性方程的解 2.1 数值求解非线性方程的根 2.1.1 步骤 寻找隔根区间() 只有一个零点的区间\n不需要单调\n或在其中找到一个近似解$x_0$\n逐步逼近 2.1.2 二分法迭代 $$ 已知在区间[a,b]上，f(a)\\cdot f(b) \\lt 0 \\\\\\ \\\\ 在[a,b]区间不断二分，逼近根x_0 \\\\\\ $$\n更优方法: 寻找黄金分割点 2.1.3 牛顿迭代法 定义 $$ 设x^*是f(x)=0的根，x_0是x^*的近似值 \\\\\\ \\\\ 在x_0附近做\\pmb{局部线性化} \\\\\\ \\\\ \\begin{align} f(x) \\approx f(x_0) +f\u0026rsquo;(x_0)(x-x_0) \\\\ x_{n+1} = x_n - \\frac{f(x_n)}{f\u0026rsquo;(x_n)}，n = 0,1,2,\u0026hellip; \\end{align} $$\n求正数平方根算法 $$ x = \\sqrt{C} \\longrightarrow x^2 -C = 0 \\\\\\ \\\\ \\therefore x_{n+1} =x_n - \\frac{x_n^2-C}{2x_n} $$\n局限性\n被零除错误(导数非常小)\n程序死循环\n牛顿迭代法的收敛域问题 画出$z^3 -1 = 0$的收敛域彩色图 $$\n$$\n三、矩阵计算 3.1 向量范数 定义 $$ 设R^n是n维向量空间，对于\\forall x \\in R^n，都有 \\\\\\ \\\\ ||x|| \\ge 0，且||x|| = 0 \\Leftrightarrow 0 \\\\\\ \\\\ ||\\lambda x|| = \\lambda ||x|| \\\\\\ \\\\ $$\n常见的范数 $$ \\begin{align} 1- 范数(列和范数):||x||1 = \\sum{i=1}^n |x_i| \\\\ 2-范数(谱范数):||x||2 = \\sqrt{\\sum{i=1}^nx_i^2} = \\sqrt{\\lambda_{max}(A^TA)} \\\\ 无穷大范数(行和范数):||x||_{\\infin} = \\underset{1\\le i \\le n}{max} (|x_1|,|x_2|,\u0026hellip;,|x_n|) \\end{align}\n$$\n范数不变性 $$ AA^T = I , y = Ax \\longrightarrow ||y||_2 = ||x||_2 \\\\\\ \\\\ y^Ty = (Ax)^T(Ax) = x^T(A^TA)x = x^Tx \\\\\\ \\\\ ||y||_2 = \\sqrt{y^Ty} = \\sqrt{x^Tx} = ||x||_2 $$\n矩阵范数 $$ 对A \\in R^{m\\times n}，存在实数||A||满足 \\\\\\ \\\\ \\begin{align} ||A|| \\ge 0，且||A|| = 0 \\Leftrightarrow = ||A|| = 0\\\\ ||\\lambda A|| = |\\lambda|\\ ||A|| \\\\ ||A+B|| \\le ||A|| + ||B|| \\\\ ||A \\cdot B || \\le ||A || \\cdot ||B|| \\end{align} \\\\\\ \\\\ 则称||A||是矩阵A的一个范数 \\\\\\ \\\\ Frobenius范数 \\\\\\ \\\\ ||A||F = (\\sum{j=1}^n\\sum_{i=1}^n a_{ij}^2)^{1/2}\n$$\n矩阵算子范数 $$ 设||x||是R^n上的向量范数，A \\in R^{m\\times n} \\\\\\ \\\\ 则A的非负函数 ||A|| = \\underset{x\\ne 0}{max}\\frac{||Ax||}{||x||} \\\\\\ \\\\ 称为矩阵A的\\pmb{算子范数} $$\n数学 上,范数等价 3.2 矩阵的条件数 定义 $$ 对于Ax = b，b存在一扰动 \\ \\delta b \\ 引起\\ x \\ 的扰动 \\ \\delta x \\\\\\ \\\\ 即 \\ A\\hat x = b + \\delta b \\\\\\ \\\\ A(x + \\delta x) = b + \\delta b \\Longrightarrow A \\cdot \\delta x = \\delta b \\\\\\ \\\\ \\therefore \\delta x = A^{-1} \\delta b \\\\\\ \\\\ || \\delta x || \\le ||A^{-1}|| \\ || \\delta b|| \\\\\\ \\\\ 又\\because b = Ax \\Longrightarrow ||b|| \\le ||A|| \\ ||x|| \\\\\\ \\\\ \\therefore \\frac{1}{||x||} \\le \\frac{||A||}{||b||} \\\\\\ \\\\ \\therefore \\frac{||\\delta x||}{||x||}\\le (||A|| \\cdot ||A^{-1}||) \\frac{||\\delta b||}{||b||} \\\\\\ \\\\ 其中,||A|| \\cdot ||A^{-1}||是\\pmb{条件数} $$\n四、数据插值方法 4.1 $$ l_0(x) = \\frac{(x-x_1)(x-x_2)}{(x_1-x_0)(x_1-x_2)} = $$\n今日作业\n二分法解具体问题\n画出$z^3 -1 = 0$的收敛域彩色图\n","date":"2023-01-05T22:49:43+08:00","permalink":"https://downeyflyfan.com/p/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/","title":"数值计算"},{"content":"案例一 1.1 解题方程 $$ Sol: Suppose \\ that \\ we \\ produce \\ x_1 \\ and \\ x_2 \\ sets \\ of \\ 甲、乙机床 \\\\\\ \\\\ \\begin{cases} Z = 4x_1+3x_2 \u0026amp; Z是价值向量 \\\\ 2x_1 + x_2 \\le 10 \u0026amp; \\\\ x_1 + x_2 \\le 8 \\\\ x_2 \\le 7 \\end{cases} $$\n1.2 线性规划问题解的概念 1.2.1 Matlab中的标准形式 公式 $$ \\underset{x}{min} \\ c^Tx \\\\\\ \\\\ s.t.\\begin{cases} Ax \\le b \\\\ Aeq \\cdot x = beq \\\\ lb \\le x \\le ub \\end{cases} $$\n注意把是方程改成以上形式\n$c$和$x$为$n$维向量\n$c$为价值向量 $b$为资源向量 $A$和$Aeq$为适当维数的矩阵\n$b$和$beq$为适当维数的列向量\nMatlab的求解 1 2 3 [x,fval] = linprog(c,A,b) [x,fval] = linprog(c,A,b,Aeq,beq) [x,fval] = linprog(c,A,b,Aeq,beq,lb,ub) 1.2.2 一般线性规划的数学标准型 $$ max \\ z = \\sum_{j=1}^nc_jx_j \\\\\\ \\\\ s.t.\\begin{cases} \\sum_{j=1}^na_{ij}x_j=b_i \u0026amp; i=1,2,\u0026hellip;,m \\\\ x_j \\ge 0 \u0026amp; j =1,2,\u0026hellip;,m \\end{cases} $$\n1.3 可以转化为线性规划的问题 1.3.1 例 题目 $$ min \\ |x_1|+|x_2|+\u0026hellip;+|x_n| \\\\\\ \\\\ s.t. \\ \\ Ax \\le b \\\\\\ \\\\ $$\n解 $$ 对于任意x_i，都存在u_i\\gt0,v_i \\ge 0 \\\\\\ \\\\ 使得x_i = u_i -v_i,|x_i| = u_i + v_i \\\\\\ \\\\ u_i = \\frac{x_i+|x_i|}{2}，v_i=\\frac{|x_i|-x_i}{2} \\\\\\ \\\\ 这样，以上问题就转化为 \\\\\\ \\\\ 记u = [u_1,u_2,\u0026hellip;]^T，v=[v_1,v_2,\u0026hellip;]^T \\\\\\ \\\\ 求min\\sum_{i=1}^n (u_i+v_i) \\\\\\ \\\\ \\begin{cases} A(u-v) \\le b \\\\ u,v \\ge 0 \\ why!!!!!!!!!!! \\end{cases} $$\n案例二 2.1 题干 2.2 问题 用给定资金M，有选择地购买若干种资产或存银行生息，使净收益净可能大，总体风险尽可能小\n2.3 解答 2.3.1 符号规定 $s_i,i=0,1,2\u0026hellip;n$代表第$i$种投资项目，其中$s_0$代表存入银行\n$r_i,p_i,q_i,i=0,1,\u0026hellip;,n$分别代表$s_i$的平均收益率、交易费率、风险损失率,其中$p_0=0,q_0=0$\n$u_i$表示交易金额\n$x_i$表示投资$\\pmb{s_i}$的资金\n$a$表示投资风险度\n$M$表示投资金额\n$Q$表示总体收益\n2.3.2 基本假设 投资金额M相当大,假设$M=1$，（为什么等于1嘞）\n投资越分散，总的风险越小\n总体风险用投资项目$s_i$中最大的一个风险来度量\n$n+1$种资产$s_i$是相互独立的\n在投资期间，$r_i,p_i,q_i$是固定的，不受任何因素影响\n净收益和总体风险只受r_i,p_i,q_i影响\n2.3.3 模型的分析与建立 总体思路\n费率多少，赚多少，风险多少 总体风险 $$ max {q_ix_i | i = 1,2,L,n} \\ \\ \\ 注意L的使用 $$\n风险$\\Longrightarrow$净收益 $$ 交易费 =\\begin{cases} p_ix_i \u0026amp; x_i \\gt u_i \\\\ p_iu_i \u0026amp; x_i \\le u_i \\end{cases} \\\\\\ \\\\ \\because u_i \\ll M \\Longrightarrow p_iu_i \\ll M \\\\\\ \\\\ \\therefore 净收益 = (r_i - p_i)x_i $$\n总体风险小，净收益大 $$ 目标函数为 \\\\\\ \\\\ \\begin{cases} min \\ \\ max{q_ix_i|i=1,2,L,n } \\\\\\ \\\\ max \\sum_{i=0}^n (r_i-p_i)x_i,i=0,1,L,n \\end{cases} \\\\\\ \\\\ 约束条件为 \\\\\\ \\\\ \\begin{cases} \\sum_{i=0}^n (1+p_i)x_i = M \\ \\ \\ 交易额+税= 总金额 \\\\\\ \\\\ x_i \\ge 0 \\end{cases} $$\n在实际投资中，风险$q_ix_i$往往是变化的，但只要给定一个界限a,使得 $$ \\frac{q_ix_i}{M} \\le a \\\\ $$\n就可以把多目标规划转化为线性规划 建立模型 模型一 固定风险，优化收益 $$ \\begin{cases} \\sum_{i=0}^n (1+p_i)x_i = M \\\\ min \\ \\ max{q_ix_i|i=1,2,L,n } \\\\ \\frac{q_ix_i}{M} \\le a \\end{cases} $$\n模型二 固定收益，极小化风险 $$ \\begin{cases} max \\sum_{i=0}^n (r_i-p_i)x_i,i=0,1,L,n \\\\ \\sum_{i=0}^n (1+p_i)x_i = M \\\\ \\sum_{i=1}^n(r_i-p_i)x_i \\ge k \\end{cases} $$\n模型三 权衡收益与风险，设置投资偏好 设定投资偏好系数$s$，对风险和收益分别赋予权重$s$和$1-s(0 \\lt s\\le 1)$\n","date":"2023-01-03T18:16:30+08:00","permalink":"https://downeyflyfan.com/p/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B/","title":"线性规划模型基本原理与案例"},{"content":"一、Linux账号与群组 1.1 使用者识别码UID与GID ID与账号存储在/etc/passwd当中 1.2 使用者账号 1.2.1 输入账号密码的处理过程 stateDiagram 在/etc/passwd里寻找输入账号与密码 --\u003e 结束: 没有 在/etc/passwd里寻找输入账号与密码 --\u003e 读取UID，GID,主文件夹与Shell设置:有 读取UID，GID,主文件夹与Shell设置 --\u003e 在/etc/shadow中核对密码表 在/etc/shadow中核对密码表 --\u003e Shell管控: 正确 在/etc/shadow中核对密码表 --\u003e 结束:错误 注意，备份时一定要备份/etc/passwd与/etc/shadow文件\n1.2.2 /etc/passwd文件结构 每一行代表一个账号 bin、daemon、adm、nobody等是系统账号 每一行的七大字段 账号\n密码\nUID\nGID\n使用者信息说明栏\n主文件夹\nShell\n字段说明 ID范围 该ID使用者特性 0 系统管理员 1-999 系统账号 1000-60000 可登录账号 1.2.3 /etc/shadow文件结构 每一行的九大字段 账号\n密码\n最近密码更变日期\n密码不可重置的天数\n密码需要重置的天数\n密码需要重置前的警告\n密码失效日\n密码过期后的账号宽限时间 账号失效日期\n保留\n字段说明 所有日期均以1970.1.1以来的天数表示 1.3 群组 1.3.1 /etc/group文件结构 每一行的四大字段 群组名称\n群组密码\nGID\n此群组支持的账号名称\n字段说明 群组密码通常是给群组管理员使用的，不需要设置 1.3.2 有效群组与初始群组 初始群组 etc/passwd里的GID 有效群组 输入groups命令得到的第一个群组为有效群组\nnewgrp GROUP_NAME切换有效群组\n1.3.3 /etc/gshadow 四个字段 群组名称\n密码栏\n群组管理员账号\n与/etc/group的第四栏内容相同\n二、账号管理 2.1 添加与移除使用者 useradd添加使用者 默认值(在/etc/default/useradd中查看) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # GID设置为1000 GROUP=1000 # 默认的主文件夹所在目录 HOME=/home # 密码失效日,-1表示永久不失效 INACTIVE=-1 # 账号失效日 EXPIRE= # 默认使用的shell SHELL=/bin/bash # 使用者主文件夹参考基准目录 SKEL=/etc/skel # 创建使用者的mailbox CREATE_MAIL_SPOOL=yes LOG_INIT=yes passwd 操作密码 参数 作用 无参数 修改密码 -d 删除密码 -f 强制下次登陆修改口令 -w 口令到期前警告的天数 -k 更新只能发送在过期之后 -l 停止账号使用 -S 显示密码信息 -u 启用已被停止的账户 -x 指定口令最常存活期 -g 修改群组密码 -i 多少天后停用账户 change 账户名显示密码参数 -l 列出详细的密码参数 usermod调整账号信息 -c 修改用户账号的备注文字 -d 登入目录 -e 修改账号的有效期限 -g 修改群组 userdel删除账户 无参数 直接删除 -r 连同使用者的主文件夹一起删除 2.2 使用者功能 id [username]查询用户的UID/GID等信息\nfinger查询用户的相关信息\n比较危险，目前的版本里没有 chfn [username](change finger) -f 接完整的大名 -o 办公室房间号 -p 办公室电话号码 -h 家里电话 chsh(change shell) -l 列出系统中有的shell -s 设置自己的shell 2.3 新增与移除群组 groupadd -g GID -r [group_name]增添群组 -g 接GID -r 创建系统群组 groupmod -g 修改GID -n 修改既有群组名称 groupdel删除群组 2.4 账号管理实例 三、ACL 3.1 ACL简介 定义 ACL，即 Access Control list，主要目的是提供传统的rwx以外的权限，包括\n使用者(user)\n群组(group)\n默认属性(mask)\n3.2 ACL的设置技巧 setfacl [-bkRd] [-m/x ACL参数] file_name(set file ACL) -m 设置ACL参数，不可与-x混用 -x 删除后续ACL参数 -b 移除所有的ACL参数 -k 移除默认的ACL参数 -R 递归 -d 针对目录设置默认ACL参数 ","date":"2022-12-27T17:48:26+08:00","permalink":"https://downeyflyfan.com/p/linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8Eacl%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/","title":"Linux账号管理与ACL权限设置"},{"content":"一、用户与硬件的关系 stateDiagram User --\u003e API API --\u003e User API --\u003e Kernel Kernel --\u003e API Kernel --\u003e Hardware Hardware --\u003e Kernel 二、Shell的变量功能 2.1 变量定义 等号两端不能有空格\n如有空格 等特殊字符需要加引号\u0026quot; \u0026quot;\n双引号、单引号都可以 双引号里可以加变量，单引号不行 字符串里可以使用转义字符 1 str1=\u0026#34;abc\\tdef\\n\u0026#34; 数值计算需要双圆括号 1 2 3 num3=$(($num1 + $num2)) # 也省略括号中的取值符号 num3=$((num1 + num2)) 简单的字符操作 1 2 3 str2=abcdef echo $str2[2,4] # 角标与元素位置相同 echo $str2[1,-1] # -1代表最后一个字符 2.2 变量比较 使用双圆括号比较数值 1 2 num=123 ((num == 123)) \u0026amp;\u0026amp; echo good 可以使用\u0026amp;\u0026amp; || !等逻辑操作符 使用双方括号比较字符串 1 2 3 str=abc # 注意，两边的变量必须与[]之间留有一个空格!!! [[ $str == abc ]] \u0026amp;\u0026amp; echo good 2.3 变量进阶 2.3.1 typeset 1 2 typeset -A 暂定 2.3.2 local 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # 强制大小写 # l代表lower u代表upper local -l(u) str # 设置环境变量 local -x str export str # 设置只读变量 local -r str # 设置数组不包含重复元素 local -U array # 设置整数位数 local -Z n num # 设置num的数位为n位。不足补0,超过截断高位 # 设置进制 local -i n num # 设置num为n进制数 [#n] num # 可以显示十进制数为n进制 # 同时对多个变量赋相同而的值 local {a,b,c}=123 # 绑定字符串和数组 local -T(tie) DIR dir dir=(.. .. ..) # 删除DIR也会删除dir,反之亦然 # 显示变量的定义方式 local -p(print) str 三、语句 3.1 条件语句 3.1.1 格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # [[ ]] 用于比较字符串和文件 if [[ ]] { } elif { } else { } # (())用于比较数值 if (()) { } # () 用于在子shell运行命令并判断结果 if () { } 以上三种可以混合使用 3.1.2 示例 1 2 3 4 5 # 此处不需要$ if (( num \u0026gt; 3 \u0026amp;\u0026amp; num + 3 \u0026lt;= 10)) { echo $num } 3.2 循环语句 3.2.1 while与until 1 2 3 4 5 6 7 8 9 while [[ ]] 或 (( )) 或 ( ) # 此处同if { break/continue } until [[ ]] 或 (( )) 或 ( ) # 此处同if { break/continue } 3.2.2 for 用于枚举 1 2 3 4 5 # 枚举括号中的内容 for i ( ) { } C风格的for循环 1 2 3 4 for (( i=0; i\u0026lt; 10; i++ )) { echo $i } 生成数组 1 2 3 4 for ({1..10}) { echo $i } 3.2.3 repeat 用于循环固定次数 1 2 3 4 5 # 将代码块中的内容循环n次 repeat n { ... } 3.3 分支语句 3.3.1 case 1 2 3 4 5 6 case $i { (a) echo 1 } 3.3.2 select 循环，并让用户选择 1 2 3 4 select $i (...) { } 3.4 异常处理语句 如果Code 1出错，就执行Code 2 1 2 3 4 5 6 { Code 1 } always { Code 2 } 四、字符串处理 4.1 字符串长度1 1 2 3 4 5 6 7 #显示字符串长度 echo $#str # 读取函数或脚本的第一个参数的长度 echo $#1 4.2 字符串拼接 1 2 3 4 5 6 str1=abc str2=def # 第一种拼接方式 str2+=$str1 # 第二种拼接方式 str3=$str1$str2 4.3 字符串截断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 str=abcdeabcde # 删除左端匹配内容，最小匹配 echo ${str#*b} # 结果 cdeabcde # 删除右端匹配内容，最大匹配 echo ${str%*d} # 结果 abcdeabc # 删除左端匹配内容，最大匹配 echo ${str##*b} # 结果 cde # 删除右端匹配到的内容 echo ${str%%d*}，最大匹配 # 结果 abc 4.4 字符串查找 子字符串定位 1 2 3 4 5 6 7 str=abcdef # I 表示从右往左找，i表示从左往右找 echo $str[(I)cd] # $后不能有空格 # 找不到就返回(数组大小+1) 4.5 字符串替换 只替换找到的第一个 1 2 str=abcabc echo ${str/bc/ef} 删除匹配到的第一个 1 echo ${str/bc} 替换所有找到的 1 echo ${str//bc/ef} # 多加一个/ 删除所有匹配的 1 echo ${str//bc} 匹配成功就输出空字符串 1 echo ${str:#ab*} 匹配失败就输出原字符串 1 echo ${str:#ab} 加M后效果反转 1 echo ${(M)str:#ab} 按位置删除(替换)字符串 1 2 str[1,4]= # 空值即位删除，否则就是替换 echo $str 4.6 判断字符串变量是否存在 1 2 3 (($+var)) \u0026amp;\u0026amp; echo good # 存在就返回good 仅仅用[[\u0026quot;str\u0026quot;==\u0026quot;\u0026quot;]]是无法区分其内容为空还是不存在的 4.7 字符串匹配判断 判断是否包含字符串 1 2 3 4 str1=abc str2=bc [[ $str1 == *$str2* ]] \u0026amp;\u0026amp; echo good 4.8 大小写转换 转成大写 1 2 3 4 5 6 7 str=\u0026#34;ABCDE abcde\u0026#34; echo ${(U)str} # 等价形式 echo ${str:u} 转成小写 1 2 3 4 5 echo ${(L)str} # 等价形式 echo ${str:l} 转成首字母大写 1 echo ${(C)str} 4.9 文件目录名截取 1 2 3 filepath=/a/b/c.x echo ${filepath:[hter]} h取目录名 t取文件名 e取文件扩展名,即文件.后的部分 r去掉末尾扩展名的路径 4.10 字符串分隔 使用空格 作分隔符，多个空格只算一个分隔符 1 2 3 4 5 str=\u0026#39;aa bb cc dd\u0026#39; # 显示第n个token echo ${str[(w)n]} 指定分隔符 1 2 3 4 5 str=\u0026#34;aa--bb--cc\u0026#34; # 设定分隔符为--，并显示第n个token echo ${str[(ws:--:)n]} 4.11 多行字符串 1 2 3 # 以下操作可以用于命令行 str=\u0026#34;line1 \u0026gt; line2\u0026#34; 4.12 读取文件内容到字符串 读取整个文件 1 2 3 4 5 6 7 8 9 10 11 12 str=$(\u0026lt;filename) # 注意引号 echo \u0026#34;$(\u0026lt;filename)\u0026#34; # 遍历每行 for i (${(f)\u0026#34;$(\u0026lt;filename)\u0026#34;}) { echo $i } 读取文件指定行 1 2 3 4 5 6 7 8 9 echo ${\u0026#34;$(\u0026lt;text.txt)\u0026#34;[(f)2]} # 输出包含abc的一行 echo ${\u0026#34;$(\u0026lt;text.txt)\u0026#34;[(fr)*abc*]} # 从左端输出包含aa的一行，但从左端截去\u0026#34;line\u0026#34; echo ${\u0026#34;$(\u0026lt;text.txt)\u0026#34;[(fr)*aa*]#line} #表示从字符串开头开始匹配，%表示从字符串结尾开始匹配\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-12-14T00:26:51+08:00","permalink":"https://downeyflyfan.com/p/zsh%E7%9A%84%E5%8F%98%E9%87%8F%E8%AF%AD%E5%8F%A5%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Zsh的变量、语句与字符串"},{"content":"一、普朗克量子假设与光电效应 1.1 黑体 1.1.1 定义 黑体吸收一切照射其上的辐射\n1.1.2 黑体辐射 黑体产生的辐射即为黑体辐射\n1.1.3 Wien 定理 \u0026ndash; \u0026ndash; 仅在短波长时有效 光谱峰值处的波长$\\lambda_p$ 与温度T的关系 $$ \\lambda_p T = 2.90 \\times 10^{-3} m\\cdot K $$\n1.1.4 不同温度下的黑体光谱 1.2 普朗克的工作 前提 Wien公式和Rayleigh等人的公式在波长较大时失效 一定温度下光强与波长的公式 —— 普朗克辐射公式 $$ I(\\lambda,T) = \\frac{2\\pi {h}c^2\\lambda^{-5}}{e^{hc/\\lambda k T}-1} \\\\\\ \\\\ {h} = 6.626\\times 10^{-34} \\ J\\cdot s \\\\\\ \\\\ k \\ \\ Boltzman 常数 \\\\\\ \\\\ T 在此处为给定的\\pmb{常数} $$\n普朗克量子假设 能量是不连续的 $$ E = n{h}f, n=1,2,3,\u0026hellip; $$\n1.3 光电效应 1.3.1 图示 1.3.2 公式 $$ E_{k_{max}} = {h}f -W_0 \\\\\\ \\\\ E_{k_{max}} = eV_0, f = \\frac{c}{\\lambda} $$\n1.3.3 解释 最大初动能$E_{kmax}$ 光子和电子相撞，碰撞类型不同，损失的能量不同 二、康普顿效应 - 光子撞电子 2.1 光子动量 一般物质的动量为 $$ p = \\gamma mv = \\frac{mv}{\\sqrt{1-v^2/c^2}} $$\n光子的动量 由于光子的速度$v=c$，而其动量不可能为无穷，故其质量$m=0$\n$$ E = mc^2 \\longrightarrow E^2 = m^2 c^4 = p^2c^2 \\\\\\ \\\\ \\therefore \\pmb{p =\\frac{E}{c}} \\\\\\ \\\\ p = \\frac{{h}f}{c} = \\frac{h}{\\lambda} \\\\\\ $$\n2.2 康普顿效应与光子 2.2.1 实验图 2.2.2 推导 $$ 已知: 撞前，电子静止，光子波长为\\lambda; \\\\\\ \\\\ 撞后，电子速率为v，光子波长为\\lambda\u0026rsquo; \\\\\\ \\\\ 根据能量守恒有: \\\\\\ \\\\ \\begin{align} \\frac{{h}c}{\\lambda} = \\frac{hc}{\\lambda\u0026rsquo;} + (\\frac{1}{\\sqrt{1-v^2/c^2}}-1)m_e \\end{align} \\\\\\ \\\\ 根据动量守恒有: \\\\\\ \\\\ \\begin{align} \\frac{m_ev}{\\sqrt{1-v^2/c^2}}\\cdot sin\\theta = \\frac{hc}{\\lambda\u0026rsquo;}\\cdot sin\\phi \\\\ \\frac{m_ev}{\\sqrt{1-v^2/c^2}}\\cdot cos\\theta + \\frac{hc}{\\lambda\u0026rsquo;}\\cdot cos\\phi = \\frac{hc}{\\lambda} \\end{align} \\\\\\ \\\\ 根据上述三式: \\\\\\ \\\\ \\lambda\u0026rsquo; =\\lambda + \\frac{{h}}{m_ec}(1-cos\\phi) \\\\\\ \\\\ \\Delta E = h \\nu - h\\nu \u0026rsquo; = h\\nu(1-cos\\theta) \\\\\\ \\\\ \\pmb{Compton \\ S{h}ift} \\\\\\ \\\\ \\Delta\\lambda = \\lambda\u0026rsquo; - \\lambda = \\frac{{h}}{m_ec}(1-cos\\phi) \\\\\\ \\\\ \\pmb{自由电子的康普顿波长} \\\\\\ \\\\ \\lambda_C = \\frac{{h}}{m_ec} = 2.43\\times 10^{-3}nm = 2.43pm $$\n2.2.3 光子与原子的碰撞 撞击原子核 或 核外电子。失去能量，频率降低(康普顿效应)\n撞击自由电子后消失,光电子逸出(光电效应)\n撞击核外电子后消失，电子能量增加(激发态)\n撞击后消失，产生电子和正电子(Pair Production)\n这种情况下,正负电子对的动能为 $$ K = hf - 2mc^2 $$\n2.2.4 光电效应与康普顿效应 光电效应是当光照在金属中时,金属里的自由电子由于变化的电场的作用而振动.若光振幅足够大,电子会飞出金属表面.于是金属就带了电.这个实验其实证明了光的波动性,即证明了光是一种电磁波.\n康普顿效应是让光波射入石墨,企图让石墨中的电子对光进行散射,光子和电子碰撞时将一部分能量转移给电子.这样,光的能量减小,波长增加.而且如果将光子当作实物粒子的话,计算结果与实验结果符合.这便证明了光子也具有动量.即证明了光的粒子性.通常只发生在频率很高的电磁波当中\n三、波粒二象性 互补原则 3.1 互补原理 —— 波尔 理解一个物理实验，必须使用波理论或者光理论，而不是同时使用两种理论\n3.2 波粒二象性 光同时具有粒子和波的属性\n$$ E(\\pmb{粒子}的能量) = {h}f(\\pmb{波}的频率) $$\n3.3 物质的波属性 德布罗意波 $$ 对于光，\\because p = \\frac{{h}}{\\lambda} \\\\\\ \\\\ 因此，\\lambda = \\frac{{h}}{p} $$\n解释 波的属性，例如干涉与衍射，只有在物体较小时才比较显著 四、早期原子模型 4.1 图示 4.2 氢原子光谱 4.2.1 黑体辐射产生原因是 由原子和分子振动产生的\n4.2.2 吸收光谱 定义 连续光谱穿过稀有气体，产生的光谱中会有黑线，波长与稀有气体释放的相同，这叫吸收光谱\n结论 稀有气体吸收和释放的光的频率是相同的\n4.2.3 Balmer公式 适用范围 表示氢原子的发射(的光电子的)波长 $$ \\frac{1}{\\lambda} =R(\\frac{1}{2^2}-\\frac{1}{n^2})，n=3,4,5,\u0026hellip; \\\\\\ \\\\ Redberg常数 \\ \\ \\ \\pmb{R = 1.0974\\times 10^7 m^{-1}} \\\\\\ \\\\ 365nm \\le \\lambda \\le 656nm $$\n4.3 Balmer公式的延伸与图示 Lyman Series $$ \\frac{1}{\\lambda} =R(\\frac{1}{1^2}-\\frac{1}{n^2})，n=3,4,5,\u0026hellip; \\\\\\ \\\\ 91nm \\le\\lambda \\le 122nm \\\\\\ $$\nPaschen series $$ \\\\ \\frac{1}{\\lambda} =R(\\frac{1}{3^2}-\\frac{1}{n^2})，n=3,4,5,\u0026hellip; \\\\\\ \\\\ 820nm\\le \\lambda \\le 1280nm $$\n氢原子能级图 4.4 波尔模型 4.4.1 能级与跃迁 向低能级跃迁释放光子 $$ {h}f =E_u - E_l $$\n4.4.2 波尔量子化条件 条件 $$ 假设电子角动量 \\ L = n \\frac{{h}}{2\\pi} \\ \\ \\ \\ n: 轨道的量子数 \\\\\\ \\\\ 又 L =mvr_n \\\\\\ \\\\ \\therefore v = \\frac{nh}{2\\pi m r_n} (1) $$\n波尔提出这个纯纯是因为它符合Balmer 公式，合着是瞎猜，一个一个试出来的 验证 图示 证明 $$ 根据牛顿第二定律 \\\\\\ \\\\ F = ma \\\\\\ \\\\ \\frac{1}{4\\pi \\varepsilon_0} \\frac{(Ze)(e)}{r^2_n} = m \\frac{v^2}{r_n} \\\\\\ \\\\ \\therefore r_n = \\frac{Ze^2}{4\\pi \\varepsilon_0 mv^2} \\\\\\ \\\\ 又根据(1)式， v = \\frac{nh}{2\\pi r_n m} \\\\\\ \\\\ \\therefore \\pmb{r_n = \\frac{\\varepsilon_0 n^2 h^2}{Ze^2 \\pi m}} \\\\\\ \\\\ \\pmb {r_n = \\frac{n^2}{Z} r_1} \\\\\\ \\\\ 波尔半径 \\ r_1 = \\frac{\\varepsilon_0 h^2}{\\pi m e^2} = 0.529 \\times 10^{-10}(m) = 0.0529(nm) $$\n4.4.3 能级 能级推导 $$ 核外电子的电势能U = - eV \\\\\\ \\\\ U = -\\frac{Ze^2}{4\\pi \\varepsilon_0 r_n} \\\\\\ \\\\ 核外电子的总能量 E_n = E_k + E_p = \\frac{1}{2}mv^2 -\\frac{Ze^2}{4\\pi \\varepsilon_0 r_n} \\\\\\ \\\\ 在波尔量子化条件下，v = \\frac{n h}{2\\pi m r_n } , r_n = \\frac{\\varepsilon_0 n^2 \\hbar^2}{Ze^2 \\pi m}\\\\\\ \\\\ \\therefore \\pmb{E_n = -(\\frac{Z^2e^4m}{8\\varepsilon_0^2 h^2})(\\frac{1}{n^2})} \\\\\\ \\\\ \\therefore \\pmb{E_n = \\frac{Z^2}{n^2}E_1} \\\\\\ \\\\ 其中，E_1 = \\frac{me^4}{8\\varepsilon_0^2h^2} =-13.6eV $$\n关于能级解释 stateDiagram 核外电子(E\u003c0) --\u003e 自由电子(E\u003e=0): 消耗能量,挣脱束缚 其他概念 电离能/结合能：使核外电子从基态到脱离(自由到基态)原子核的最小能量 能级与波长 $$ \\frac{1}{\\lambda} = \\frac{f}{c} = \\frac{hf}{hc} = \\frac{1}{hc}(E_n - E_{n\u0026rsquo;}) \\\\\\ \\\\ \\lambda = \\frac{hc}{E_n - E_{n\u0026rsquo;}} \\\\\\ \\\\ 其中 \\pmb{hc = 1.24 \\times 10^3(eV\\cdot nm)} \\\\\\ \\\\ 换E \\\\\\ \\\\ \\frac{1}{\\lambda} = \\frac{Z^2e^4m}{8\\varepsilon_0^2h^3 c}\\Big(\\frac{1}{n\u0026rsquo;^2}- \\frac{1}{n^2}\\Big) \\\\\\ \\\\ 由此可以得到: R = \\frac{me^4}{8\\varepsilon_0 h^3 c} $$\n五、德布罗意原子假设 5.1 对波尔量子化条件的证明（回顾驻波知识） $$ 德布罗意波长 \\lambda = \\frac{h}{p} = \\frac{h}{mv} (v较小时) \\\\\\ \\\\ 2\\pi r_n =n \\lambda = n\\frac{h}{mv}，n = 1,2,3, \u0026hellip;\\\\\\ \\\\ $$\n5.2 波尔模型的局限性 只适用于氢原子和单电子离子\n量子力学最终解释了这一切\n","date":"2022-12-13T23:55:09+08:00","image":"https://downeyflyfan.com/p/%E6%97%A9%E6%9C%9F%E9%87%8F%E5%AD%90%E7%90%86%E8%AE%BA%E5%92%8C%E5%8E%9F%E5%AD%90%E6%A8%A1%E5%9E%8B/1_hub06219d070f66f8c658580c5f1108b51_11730_120x120_fill_q75_box_smart1.jpg","permalink":"https://downeyflyfan.com/p/%E6%97%A9%E6%9C%9F%E9%87%8F%E5%AD%90%E7%90%86%E8%AE%BA%E5%92%8C%E5%8E%9F%E5%AD%90%E6%A8%A1%E5%9E%8B/","title":"早期量子理论和原子模型"},{"content":"普通问题 PKGBUILD和它的用法 内容与本质 一个shell脚本 一个 makepkg -s -r -i -c -si 自动安装依赖 卸载不需要的依赖项 自动升级安装 删除临时构建文件 常用 没有声音怎么办 1 2 3 sudo vim /etc/default/grub` GRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;loglevel=3 snd_hda_intel.dmic_detect=0\u0026#34; sudo grub-mkconfig -o /boot/grub/grub.cfg 如何创建hexo博客 创建目录mkdir blog\n设置权限\n进入并初始化目录\n1 2 3 hexo init hexo s(start) 进入本地网站localhost:4000 Ctrl + C取消本地网站\n创建新博客hexo n \u0026lt;文章名\u0026gt;\n读写新博客cd source/_posts vim blog.md\n回到blog目录\n清除 hexo clean\n安装deployer\nsudo npm install --save hexo-deployer-git 生成 hexo g(generate)\n部署 hexo d(deploy)\n如何创建hugo博客 sudo pacman -S hugo下载hugo\nhugo version查看hugo版本有没有extended\nhugo new site blog 创建hugo的博客文件夹\n进入blog文件夹git init初始化 git clone ...下载主题 主题可以在https://themes.gohugo.io/上查找并下载 hugo new post/name.md创建新的博客文章 进入content/post可进行编辑 hugo server -D启动本地服务器 使用hugo -D将已写的blog放入public文件夹\nCtrl+C退出服务器\n建立github仓库 仓库名\u0026lt;username\u0026gt;.github.io 在config.toml中添加`theme``为自己想要的theme\nhugo -D在本地生成public文件准备部署\n进入public文件夹\n使用我写的脚本.push 对于public文件夹\nhugo -D创建 清理内存 使用paccache -r清除缓存包\n使用yay -Sc清楚缓存包\n使用 sudo pacman -Scc清除安装包\n使用 sudo pacman -Qdtq找出无用的依赖包并清除\n清理日志\n1 2 3 sudo journalctl --disk-usage #查看日志内存 sudo journalctl --vacuum-time=5d #超过5天的自动删除 sudo journalctl --vacuum-size=500M #超过500M的自动删除 删除特定名称的文件 1 sudo find / -name \u0026#34;openssl\u0026#34; -type f -delete 定期清理浏览器缓存 开机分区的安装 新建boot分区 1 fidsk -l 挂载分区 挂载根目录分区与开机分区 1 2 mount /dev/nvme0n1p6 /mnt mount /dev/nvme0n1p8 /mnt/boot 生成文件系统自动挂载分区(可删除先前的) 1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 安装内核 1 2 arch-chroot /mnt pacman -S base linux linux-firmware 安装引导 安装徽码 1 $ pacman -S intel-ucode 安装引导 1 2 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch --recheck grub-mkconfig -o /boot/grub/grub.cfg 退出并重启 1 2 3 $ exit $ umount -R /mnt $ reboot 常见指令及其选项组合 解压类 解压.tar.gz文件 tar -zxvf 待解决 ","date":"2022-12-13T00:05:44+08:00","permalink":"https://downeyflyfan.com/p/linux%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Linux的问题"},{"content":"一、拉普拉斯变换的定义 数学公式 $$ F(s) = \\mathcal L\\lbrace f(t) \\rbrace = \\int_0^{+\\infin} f(t)e^{-st}dt $$\n$t$ 代表时域 由于$e$没有量纲，所以$s$代表频率 解释 将时域变为频域 二、阶跃函数与斜坡函数 2.1 单位阶跃函数图示 2.2 阶跃函数数学定义 $$ \\begin{cases}Ku(t-a) =0 \u0026amp; t \\lt a \\\\ Ku(t-a) = K \u0026amp; t \\ge a \\end{cases} $$\n若需要定义从$a^-$到$a^+$的过渡是线性的(非突变),则可以假设 $$ Ku(0) = 0.5K \\\\\\ \\\\ u(t) = \\begin{cases} 0 \u0026amp; t \\lt 0 \\\\ 1 \u0026amp; t \\ge 0 \\end{cases} \\\\\\ \\\\ u(t) = \\frac{dr(t)}{dt} $$\n2.3 单位斜坡函数 定义 $$ r(t) = tu(t) = \\int_{-\\infin}^t u(\\lambda)d\\lambda $$\n三、冲激函数 3.1 作用 定义间断点处的导数及其拉氏变换\n3.2 举例 $$ f(0) \\rightarrow \\delta(t)，\\epsilon \\rightarrow 0 \\\\\\ \\\\ \\delta(t)即为冲激函数 $$\n3.3 条件 冲激函数是由可变参数函数的参数$\\rightarrow 0$时形成的\n幅值趋于$\\infin$\n函数持续时间趋于0\n当参数变化时，函数下的面积为常数\n在此例中，面积为1 $$ f(t) = \\frac{K}{2\\epsilon} e^{-|t|/\\epsilon} $$\n3.4 定义 $$ \\int_{-\\infin}^{+\\infin} K \\cdot \\delta (t) dt = K \\\\\\ \\\\ \\delta(t) = 0, t \\ne 0 \\\\\\ \\\\ \\delta(t) = \\underset{\\tau \\rightarrow 0 }{lim} \\frac{1}{\\tau}rect\\Big(\\frac{t + \\frac{\\tau}{2}}{\\tau}\\Big) $$\n3.5 特性 筛选特性 $$ \\int_{-\\infin}^{+\\infin} f(t)\\delta(t-a)dt = f(a) \\\\\\ \\\\ I =\\int_{-\\infin}^{+\\infin} f(t)\\delta(t-a)dt = \\int_{a-\\epsilon}^{a+\\epsilon}f(t)\\delta(t-a) dt $$\n冲激函数的拉氏变换 $$ \\mathcal L \\lbrace \\delta(t) \\rbrace = \\int_0^{+\\infin} \\delta(t)e^{-st}dt = e^{-st}\\Big|_{t=0} = 1 $$\n冲激函数微分的拉氏变换 (a)图说明了冲激函数的生成过程\n(b)图是冲激函数的微分\n冲激函数微分的拉氏变换\n$$ \\mathcal L \\lbrace \\delta\u0026rsquo;(t) \\rbrace = \\underset{\\epsilon \\rightarrow 0}{lim}\\int_{-\\epsilon}^{0^-}\\frac{1}{\\epsilon^2}e^{-st}dt + \\int_{0^+}^\\epsilon \\frac{1}{\\epsilon^2}e^{-st}dt \\\\\\ \\\\ = \\underset{\\epsilon \\rightarrow 0}{lim} \\frac{e^{-s\\epsilon}+e^{-s\\epsilon}-2}{s\\epsilon^2} \\\\\\ \\\\ = \\underset{\\epsilon \\rightarrow 0}{lim} \\frac{s^2(e^{-s\\epsilon}+e^{-s\\epsilon})}{2s} \\ \\ (洛必达法则) \\\\\\ \\\\ = s \\\\\\ \\\\ 同理可得：\\mathcal L \\lbrace \\delta^{(n)}(t)\\rbrace = s^n $$\n冲激函数是阶跃函数的导数 $$ \\delta(t) = \\frac{du(t)}{dt} $$\n四、函数变换 4.1 定义 说明 典型时域变换的拉普拉斯变换\n因为要限制其为单边变换，所以设所有函数在$t\\lt 0^-$时为0 4.2 常见函数的拉氏变换 单位阶跃函数的拉氏变换 $$ \\mathcal L \\lbrace f(t)\\rbrace = \\int_{0^-}^{+\\infin} f(t)e^{-st} dt = \\int_{0^+}^\\infin 1e^{-st} dt = \\frac{1}{s} \\\\\\ \\\\ $$\n衰减指数函数的拉氏变换 $$ \\mathcal L \\lbrace e^{-at} \\rbrace = \\int_{0^+}^{+\\infin} e^{-at}e^{-st}dt = \\frac{1}{s+a} $$\n正弦函数的拉氏变换 $$ \\begin{align} \\mathcal L \\lbrace sin\\omega t\\rbrace \u0026amp; = \\int_{0^-}^{\\infin} sin(\\omega t)e^{-st}dt \\\\\\ \u0026amp; = \\int_{0^-}^{+\\infin} \\frac{e^{j\\omega t}-e^{-j\\omega t}}{2j}e^{-st}dt \\\\\\ \u0026amp; = \\frac{\\omega}{\\omega^2 + s^2} \\end{align} $$\n4.3 拉氏变换对简表 类型 $f(t)，t\\gt 0^-$ $F(s)$ 冲激函数 $\\delta(t)$ 1 阶跃函数 $u(t)$ $1/s$ 斜坡函数 $t$ $1/s^2$ 指数函数 $e^{-at}$ $1/(s+a)$ 正弦函数 $sin(\\omega t)$ $\\frac{\\omega}{\\omega^2 + s^2}$ 余弦函数 $cos(\\omega t)$ $\\frac{s}{s^2+\\omega^2}$ 衰减斜坡函数 $te^{-at}$ $\\frac{1}{s^2+a^2}$ 衰减正弦函数 $e^{-at}sin(\\omega t)$ $\\frac{\\omega}{(s+a)^2+ \\omega^2}$ 衰减余弦函数 $e^{-at}cos(\\omega t)$ $\\frac{s+a}{(s+a)^2 + \\omega^2}$ 五、算子变换 5.1 常数与加减运算 $$ \\mathcal L \\lbrace Kf(t)\\rbrace = KF(s) \\\\\\ \\\\ \\begin{align} \\mathcal L \\lbrace f_1(t) + f_2(t) - f_e(t) \\rbrace = F_1(s) + F_2(s) - F_3(s) \\end{align} $$\n5.2 微分与积分 $$ \\begin{align} \\mathcal L \\Big\\lbrace \\frac{df(t)}{dt} \\Big\\rbrace \u0026amp; = sF(s) - f(0^-) \\\\\\ \\mathcal L \\Big\\lbrace \\int_{0^-}^t f(x)dx \\Big\\rbrace \u0026amp; = \\int_{0^-}^{+\\infin} \\Big[\\int_{0^-}^t f(x)dx\\Big]e^{-st}dt \\end{align} $$\n5.3 时域平移 六、脉冲函数 6.1 方形脉冲 $$ f(t) = A \\ rect(\\frac{t}{\\tau}) $$\n$A$表示脉冲，$\\tau$表示宽度，零值点表示中点 6.2 三角脉冲 $$ f(t) = A \\ tri \\Big(\\frac{t}{\\tau}\\Big) $$\n$A$表示脉冲，$2\\tau$表示宽度,零值点表示中点 ","date":"2022-12-12T04:35:12+08:00","permalink":"https://downeyflyfan.com/p/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/","title":"拉普拉斯变换与其他函数"},{"content":"一、基本思想 1.1分类 1.1.1参数检验 已知总体分布形式，需要对其中的位置参数给出假设检验\n1.1.2非参数检验 总体分布形式未知时，对总体的分布或者数字进行假设检验\n1.2 步骤 1.2.1 假设 原假设(零假设)$H_0$，备择假设(对立假设)$H_1$\n关于总体参数$\\theta$的假设\n$$ H_0: \\theta \\ge \\theta_0，H_1:\\theta \\le \\theta_0（左边检验） \\\\\\ \\\\ H_0：\\theta \\le \\theta_0 ，H_1: \\theta \\gt \\theta_0 （右边检验）\\\\\\ \\\\ H_0：\\theta = \\theta_0 ， H_1：\\theta \\ne \\theta_0（双边检验 $$\n1.2.2 检验统计量和拒绝域 ","date":"2022-12-10T23:58:47+08:00","permalink":"https://downeyflyfan.com/p/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/","title":"假设检验"},{"content":"一、瞬时功率 $$ p = vi \\\\\\ \\\\ v = V_mcos(\\omega t + \\theta_{v}) \\\\\\ \\\\ i = I_mcos(\\omega t + \\theta_i) \\\\\\ \\\\ 更换时刻，可以得到 \\\\\\ \\\\ v = V_m cos(\\omega t + \\theta_v - \\theta_i) \\\\\\ \\\\ i = I_mcos\\omega t \\\\\\ \\\\ \\therefore p = vi =V_mI_m cos(\\omega t + \\theta_v - \\theta_i)cos\\omega t \\\\\\ \\\\ 根据积化和差与和差化积公式 \\\\\\ \\\\ p =\\frac{V_mI_m}{2}cos(\\theta_v - \\theta_i) + \\frac{V_mI_m}{2} cos(\\theta_v - \\theta_i)cos2\\omega t - \\frac{V_mI_m}{2}sin(\\theta_v - \\theta_i)sin2\\omega t [1] $$\n二、平均功率与无功功率 2.1 定义 $$ 上述[1]式中 \\\\\\ \\\\ 令 P = \\frac{V_mI_m}{2}cos(\\theta_v -\\theta_i )， Q = \\frac{V_mI_m}{2} sin(\\theta_v-\\theta_i) \\\\\\ \\\\ 其中,P = \\frac{1}{T} \\int_{t_0}^{t_0+T} pd\\tau 被称为平均功率\\\\\\ \\\\ Q被称为无功功率 \\\\\\ \\\\ 这样一来，p = P + Pcos2\\omega t -Qsin2\\omega t $$\n2.2 纯电阻电路的功率 $$ p = P + Pcos2\\omega t \\\\\\ \\\\ 此时，无功功率为0 $$\n2.3 纯电感电路的功率 $$ 电压和电流的相位差为90^{\\circ}，即\\theta_v-\\theta_i = 90^{\\circ}\\\\\\ \\\\ p = -Qsin2\\omega t \\\\\\ \\\\ \\pmb{纯电感电路的电路的平均功率为0} \\\\\\ \\\\ $$\n2.4 纯电容电路 $$ 电流超前电压90^{\\circ} ，即\\theta_v- \\theta_i = - 90^{\\circ}\\\\\\ \\\\ p = -Qsin2\\omega t \\\\\\ \\\\ 同样，平均功率为0 $$\n2.5 功率因数 $$ 功率因数 pf = cos(\\theta_v - \\theta_i) \\\\\\ \\\\ 无功因数 rf(reactive \\ factor) = sin(\\theta_v - \\theta_i) $$\n三、均方根和功率计算 $$ 平均功率 P = \\frac{1}{T}\\int_{t_0}^{t_0+T}\\frac{V_m^2cos^2(\\omega t + \\phi_v)}{R}dt = \\frac{1}{R}\\Big[\\frac{1}{T}\\int_{t_0}^{t_0+T}V_m^2cos^2(\\omega t + \\phi_v)dt\\Big] \\\\\\ \\\\ 根据均方根公式 \\\\\\ \\\\ 我们知道P = \\frac{V_{rms}^2}{R} = I_{rms}^2R\\\\\\ \\\\ P = V_{eff}I_{eff}cos(\\theta_v - \\theta_i) \\\\\\ \\\\ Q = V_{eff}I_{eff}sin(\\theta_v - \\theta_i) $$\n四、复功率 4.1 功率三角形 4.2定义 $$ S = P + jQ \\\\\\ \\\\ tan(\\theta_v -\\theta_i) = \\frac{Q}{P} = tan\\theta\\\\\\ \\\\ |S| = \\sqrt{P^2 + Q^2} $$\n五、功率计算 $$ S = P + jQ \\\\\\ \\\\ 经过推导：S = V_{eff}I_{eff}e^{j(\\theta_v-\\theta_i)} [1]\\\\\\ \\\\ 也可以变为: S = V_{eff}I_{eff} e^{j(\\theta_v - \\theta_i)} = V_{eff}e^{j\\theta_v} \\cdot I_{eff}e^{-j\\theta_i} \\\\\\ \\\\ S = \\pmb V_{eff}\\cdot \\pmb I^{}_{eff}[2] \\\\\\ \\\\ 其中，I^{eff}是I{eff}的共轭复数 \\\\\\ \\\\ 同时S = \\frac{1}{2}VI [3] $$\n5.1 复功率的变换形式 5.1.1 图示 5.1.2 推导 $$ \\pmb V_{eff} = \\pmb I_{eff}\\cdot Z \\\\\\ \\\\ = \\pmb I_{eff}(R+jX) \\\\\\ \\\\ \\therefore S = \\pmb{V_{eff}I^*{eff}} \\\\\\ \\\\ = |\\pmb{I{eff}^2}| (R+jX) \\\\\\ \\\\ = |\\pmb{I_{eff}^2}|R+j|\\pmb{I_{eff}^2}|X\\\\\\ \\\\ \\therefore P = |\\pmb{I_{eff}^2}|R = \\frac{1}{2}I_m^2R \\\\\\ \\\\ Q = |\\pmb{I_{eff}^2}|X = \\frac{1}{2}I_m^2X $$\n5.2 最大功率传输定律 5.2.1 图示 5.2.2 推导 $$ \\pmb I = \\frac{V_{Th}}{R_{Th}+R_L+j(X_{Th}+X_L)} \\\\\\ \\\\ P_L = \\pmb I^2 \\cdot R \\\\\\ \\\\ \\pmb P_L = \\frac{V_{Th}^2}{(R_{Th}+R_L)^2+(X_{Th}+X_L)^2} \\\\\\ \\\\ 通过求导分析可得 \\\\\\ \\\\ \\pmb{当Z_L = Z^*{Th}时，负载功率最大} \\\\\\ \\\\ 此时\\pmb{P{max} = \\frac{1}{4}\\frac{V_{Th}^2}{R_L} = \\frac{1}{8}\\frac{V_m^2}{R_L}} $$\n5.2.3 限制Z时的最大功率传输 $$ |Z_L| = |Z_{Th}|时,负载平均功率最大 $$\n","date":"2022-12-08T23:54:44+08:00","image":"https://downeyflyfan.com/p/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E5%8A%9F%E7%8E%87%E8%AE%A1%E7%AE%97/1_hu3d03a01dcc18bc5be0e67db3d8d209a6_78765_120x120_fill_q75_box_smart1.jpg","permalink":"https://downeyflyfan.com/p/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E5%8A%9F%E7%8E%87%E8%AE%A1%E7%AE%97/","title":"正弦稳态功率计算"},{"content":"参数的点估计 矩估计法 用样本矩估计总体矩 以样本矩估计总体矩\n$$ 设 \\mu_k = E(X^k), k = 1, \u0026hellip; m存在, v_k = E{[X-E(X)]^k} \\\\\\ \\\\ 即\\hat{\\mu}k = A_k = \\frac{1}{n}\\sum{i=1}^nX_i ^k， \\hat{v}k = B_k = \\frac{1}{n}\\sum{i=1}^n(X_i - \\overline X)^k \\\\\\ \\\\ \\hat{g}(\\mu_1\u0026hellip;\\mu_m) = g(A_1 \u0026hellip; A_m)，其中g是连续函数 $$\n基本步骤 $$ 设总体X有m个未知参数\\theta_1 \u0026hellip;\\theta_m，\\mu_1\u0026hellip;\\mu_m 存在 $$\n求前$m$阶矩关于$m$个参数的函数 $$ \\mu_k = E(X^k) = g_k(\\theta_1,\u0026hellip;\\theta_m)，k=1,\u0026hellip;,m $$\n求各参数关于前m阶矩阵的反函数 $$ \\theta_k =h_k(\\mu_1,\u0026hellip;,\\mu_k)，k=1,\u0026hellip;,m $$\n用样本各阶矩$A_1,\u0026hellip;,A_m$代替总体各阶矩阵$\\mu_1\u0026hellip;,\\mu_m$ $$ \\hat{\\theta}_k = h_k(A_1,\u0026hellip;,A_k)，k=1,\u0026hellip;,m $$\n极大似然估计法 定义 一般的，设离散型总体$X～p(x;\\theta),\\theta \\in \\Theta$，$\\theta$未知，从总体中取得样本$X_1,\u0026hellip;,X_n$,其观察值为$x_1,\u0026hellip;,x_n$，则事件$\\lbrace X_1=x_1,\u0026hellip;X_n=x_n\\rbrace$发生的概率为\n对于离散型变量 $$ L(\\theta) = P\\lbrace X_1=x_1,\u0026hellip;,X_n=x_n \\rbrace = p(x_1;\\theta)\u0026hellip;p(x_n;\\theta) = \\prod_{i=1} ^n p(x_i;\\theta)\\\\\\ \\\\ 极大似然原理为\\\\\\ \\\\ L(\\hat{\\theta}(x_1,\u0026hellip;,x_n)) = \\underset{\\theta \\in \\Theta}{max} L(\\theta) \\\\\\ \\\\ \\hat{\\theta}(x_1,\u0026hellip;,x_n)被称为极大似然估计值 \\\\\\ \\\\ 相应统计值\\hat{\\theta}(X_1,\u0026hellip;,X_n) 被称为\\theta 的极大似然估计量(MLE) $$\n对于连续型随机变量\n$$ f(x,\\theta)，\\theta \\in \\Theta \\\\\\ \\\\ 对于样本(X_1,X_2,\u0026hellip;,X_n)，其观察值(x_1,\u0026hellip;,x_n)，似然函数为L(\\theta) = \\prod_{i=1}^n f(x_i,\\theta) \\\\\\ \\\\ 极大似然原理：L(\\hat{\\theta}(x_1,\u0026hellip;,x_n)) = \\underset{\\theta \\in \\Theta}{max} \\ L(\\theta) \\\\\\ \\\\ 其中，\\theta = (\\theta_1,\u0026hellip;\\theta_k) $$\n极大似然估计的求解 记$ln L(\\theta) = l(\\theta)$，称为对然似然函数 $$ 利用\\frac{\\partial l(\\theta)}{\\partial \\theta}\\Big|_{\\hat{\\theta},1\\le i \\le k} = 0,i=1,2\u0026hellip;k解得\\hat{\\theta}，i=1,2\u0026hellip;k $$\n利用$L(\\theta)$关于某个$\\theta_i$单调，此时$\\hat{\\theta_i}$即为$\\theta_i$的极大似然估计值o\n若$\\hat{\\theta}(X_1,\u0026hellip;,X_n)$ 是$\\theta$的极大似然估计量，则$g(\\theta)$的极大似然估计量为$g(\\hat{\\theta}(X_1,\u0026hellip;X_n))$\n估计量的评选准则 无偏性准则 定义 $$ 若参数\\theta的估计量\\hat{\\theta} =\\hat{\\theta}(X_1,X_2,\u0026hellip;,X_n)，满足E(\\hat{\\theta}) = \\theta \\\\\\ \\\\ 则称\\hat{\\theta} 是\\theta 的一个\\pmb{无偏估计量} \\\\\\ \\\\ 若E(\\hat{\\theta})\\ne \\theta，那么\\pmb{B(\\hat{\\theta}) = E(\\hat{\\theta})- \\theta}称为\\hat{\\theta}的偏差 \\\\\\ \\\\ 若\\underset{n\\longrightarrow +\\infin}{lim} E(\\hat{\\theta}) = \\theta,则称\\hat{\\theta}是\\theta的\\pmb{渐进无偏估计量} $$\n纠偏方法\n如果$E(\\hat{\\theta}) = a\\theta +b,\\theta \\in \\Theta,a\\ne 0$，则$\\frac{1}{a}(\\hat{\\theta}-b)$是$\\theta$的无偏估计\n有效性准则 定义 设$\\theta_1,\\theta_2$是$\\theta$的两个无偏估计，若$Var(\\hat{\\theta}_1)\\le Var(\\hat{\\theta}_2)$对于一切$\\theta \\in \\Theta$ 成立，且不等号至少对某一$\\theta\\in\\Theta$成立,则称$\\hat{\\theta}_1$比$\\hat{\\theta}_2$有效\n均方误差准则 $$ 设\\hat{\\theta}是参数\\theta的点估计，方差存在\\\\\\ \\\\ 则称E(\\hat{\\theta}-\\theta)^2是估计量的均方误差，记为Mse(\\hat{\\theta}) \\\\\\ \\\\ Mse(\\hat{\\theta}) = E(\\hat{\\theta} - \\theta)^2 = Var(\\hat{\\theta})+[E(\\hat{\\theta})-\\theta]^2 \\\\\\ \\\\ 若\\hat{\\theta}是\\theta的无偏估计 \\\\\\ \\\\ 则有Mse(\\hat{\\theta}) = Var(\\hat{\\theta}) \\\\\\ \\\\ 设\\hat{\\theta}_1 ,\\hat{\\theta}_2是\\theta的两个估计量 \\\\\\ \\\\ 如果Mse(\\hat{\\theta}_1) \\le Mse(\\hat{\\theta}_2)对一切\\theta \\in \\Theta 成立 \\\\\\ \\\\ 且不等号至少对某一\\theta \\in \\Theta成立，则称\\hat{\\theta}_1优于\\hat{\\theta}_2 $$\n相合性准则 $$ 设\\hat{\\theta}_n = \\hat{\\theta}(X_1,\u0026hellip;,X_n)为参数\\theta的估计量 \\\\\\ \\\\ 若对于任意\\theta \\in \\Theta，当n \\longrightarrow + \\infin时，\\hat{\\theta}_n \\overset{P}{\\longrightarrow} \\theta. \\\\\\ \\\\ 即\\forall \\varepsilon \\gt 0,有 \\underset{n \\longrightarrow + \\infin}{lim}P \\lbrace |\\hat{\\theta}_n - \\theta| \\ge \\varepsilon \\rbrace = 0成立 \\\\\\ \\\\ 则称\\hat{\\theta_n}为\\theta的\\pmb{相合估计量}或\\pmb{一致估计量} $$\n区间估计 定义 设总体X的分布函数 $F(X;\\theta)$ 含有一个位置参数$\\theta$，$(X_1,\u0026hellip;,X_n)$是总体的一个样本，对给定的值$\\alpha(0\\lt \\alpha \\lt 1)$，若有统计量$\\hat{\\theta}_L = \\hat{\\theta}_L(X_1,\u0026hellip;,X_n)$，$\\hat{\\theta}_U = \\hat{\\theta}_U(X_1,\u0026hellip;,X_n)$,使得\n$$ P\\lbrace \\hat{\\theta}_L (X_1,\u0026hellip;X_n)\\lt \\theta \\lt \\hat{\\theta_U}(X_1,\u0026hellip;,X_n)\\ge 1- \\alpha，\\forall \\theta \\in \\Theta \\\\\\ \\\\ 则称随机区间(\\hat{\\theta}_L,\\hat{\\theta}_U)是\\theta 的双侧置信区间 \\\\\\ \\\\ 称1 - \\alpha 为置信水平或置信度 \\\\\\ \\\\ 称 \\hat{\\theta}_L和\\hat{\\theta}_U为\\pmb{双侧置信下限}和\\pmb{双侧置信上限} $$\n单侧置信限 ","date":"2022-12-08T03:19:37+08:00","permalink":"https://downeyflyfan.com/p/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/","title":"参数估计"},{"content":"随机样本与统计量 总体与个体 总体 研究对象的全体 个体 总体中的成员 总体容量 总体中包含的个体数 有限总体与无限总体 容量非常大的总体也可被算作无限总体 样本 随机样本 从总体中随机抽取的n个个体成为一个随机样本 简单随机样本 样本之间独立同分布的随机样本 统计量 统计量 样本的不含任何位置参数的函数 常用统计量 样本均值$\\overline X = \\frac{1}{n}\\sum_{i=1}^nX_i$\n样本方差$S^2 = \\frac{1}{n-1}\\sum_{i=1}^n(X_i-\\overline X)^2$\n样本矩\nk阶矩: $A_k = \\frac{1}{n}\\sum_{i=1}^n X_i^k$ k阶中心矩：$B_k = \\frac{1}{n} \\sum_{i=1}^k (X_i - \\overline X)^k$ 注意 统计量是试验结果，与随机变量的数学特征不同 当总体数字特征未知时 可以用样本的常用统计量估计总体数据 几个分布 $\\chi^2$分布 定义 $$ X_1 \u0026hellip; X_n相互独立，X_i ～N(0,1)，则 \\\\\\ \\\\ \\chi^2 ～ \\sum_{i=1}^nX_i^2 服从自由度为n的\\chi^2分布 \\\\\\ \\\\ 记为\\chi^2 ～\\chi^2(n) $$\n性质 设$\\chi^2 ～\\chi^2(n)$,则有$E(\\chi^2) =n,Var(\\chi^2) = 2n$\n$\\chi^2$分布可加性\n设$Y～\\chi^2(n),i=1,2\u0026hellip;$，且$Y_1,Y_2$相互独立，有$Y_1 + Y_2 ～\\chi^2(n_1+ n_2)$ t分布 定义 $$ 设 X ～N(0,1),Y～\\chi^2(n)，并且假设X,Y相互独立 \\\\\\ \\\\ 则称 T = \\frac{X}{\\sqrt{Y/n}} 服从自由度为n的t分布 \\\\\\ \\\\ 记为 T ～ t(n) \\\\\\ \\\\ t(n)分布的概率密度函数为 \\\\\\ \\\\ f(t) = \\frac{\\Gamma (\\frac{n+1}{n})}{\\sqrt{n\\pi}\\Gamma(\\frac{n}{2})} (1+\\frac{t^2}{n})^{-\\frac{n+1}{2}}，-\\infin \\lt t \\lt + \\infin $$\nF分布 定义 $$ X～\\chi^2(n_1)，Y～\\chi^2(n_2) \\\\\\ \\\\ 称随机变量F = \\frac{X/n_1}{Y/n_2}服从自由度(n_1,n_2)的F分布 \\\\\\ \\\\ 记为F～F(n_1,n_2) \\\\\\ \\\\ 其中，n_1为第一自由度，n_2为第二自由度 $$\n性质 $F～F(n_1,n_2)$，则$F^{-1}～F(n_2,n_1)$ 正态分布下的抽样分布 定理1 $$ 设 X_1 \u0026hellip; X_n是来自正态总体N(\\mu,\\sigma^2) 的简单随机样本，有 \\\\\\ \\\\ \\overline X ～ N\\Big(\\mu,\\frac{\\sigma^2}{n}\\Big) \\\\\\ \\\\ \\frac{(n-1)S^2}{\\sigma^2} ～ \\chi^2(n-1)\\\\\\ \\\\ \\overline X 与S^2 相互独立 \\\\\\ \\\\ \\frac{\\overline X - \\mu}{S/\\sqrt{n}} ～ t(n-1) $$\n","date":"2022-12-08T02:49:15+08:00","image":"https://downeyflyfan.com/p/%E7%BB%9F%E8%AE%A1%E9%87%8F%E4%B8%8E%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/1_hua1e7aca0572cc6cac23f9744770eccdd_7413_120x120_fill_q75_box_smart1.jpg","permalink":"https://downeyflyfan.com/p/%E7%BB%9F%E8%AE%A1%E9%87%8F%E4%B8%8E%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/","title":"统计量与抽样分布"},{"content":"伽利略-牛顿相对论 传统思维\n狭义相对论与洛伦兹变换 狭义相对论的基本原理 光速不变原理 光速是绝对的，它相对于任何物体的速度都是不变的\n狭义相对论原理 物理规律在一切惯性参考系中都是等价的\n六大公式 钟慢效应(时间) 图示 推导 $$ 对于车外的人来说, \\Delta t = \\frac{2\\sqrt{d^2 + (\\frac{1}{2}v\\Delta t)^2}}{c} \\\\\\ \\\\ 对于车内的人来说：\\Delta t\u0026rsquo; = \\frac{2d}{c} \\\\\\ \\\\ 根据以上两式可得：\\Delta t = \\frac{\\Delta t\u0026rsquo; }{\\sqrt{1-v^2/c^2}} \\\\\\ $$\n尺短效应(长度) 图示 推导 $$ 对于车外的人来说: \\\\\\ \\\\ \\Delta t = \\frac{l}{c-v}+\\frac{l}{c+v} \\\\\\ \\\\ 对于车内的人来说 \\\\\\ \\\\ \\Delta t\u0026rsquo; = \\frac{2l_0}{c} \\\\\\ \\\\ 由以上两式可知: L = \\sqrt{1-v^2/c^2} \\cdot L_0 $$\n洛伦兹变换(速度) $$ \\begin{cases} x = \\gamma (x\u0026rsquo;+vt\u0026rsquo;) \\\\ y =y\u0026rsquo; \\\\ z = z\u0026rsquo; \\\\ t = \\gamma (t\u0026rsquo; + vx\u0026rsquo;/c^2)\\end{cases} \\Rightarrow\\begin{cases}dx =\\gamma(dx\u0026rsquo; + vdt\u0026rsquo;)\\\\ dy = dy\u0026rsquo; \\\\ dz = dz\u0026rsquo; \\\\ dt = \\gamma(dt\u0026rsquo; + vdx\u0026rsquo;/c^2) \\end{cases} \\\\\\ \\\\ 我们可以得出: \\frac{dx}{dt} = \\frac{dx\u0026rsquo;+vdt\u0026rsquo;}{dt\u0026rsquo;+vdx\u0026rsquo;/c^2} = \\frac{\\frac{dx\u0026rsquo;}{dt\u0026rsquo;}+v}{1+\\frac{v}{c^2}\\frac{dx\u0026rsquo;}{dt\u0026rsquo;}} \\\\\\ \\\\ 其中 u =\\frac{du}{dt}，u\u0026rsquo; =\\frac{dx\u0026rsquo;}{dt\u0026rsquo;} \\\\\\ \\\\ \\therefore u_x = \\frac{u_x\u0026rsquo;+ v}{1+u_x\u0026rsquo;v/c^2} \\\\\\ \\\\ 其中，v是坐标系S\u0026rsquo;相对于坐标系S的移动速度 \\\\\\ \\\\ u和u\u0026rsquo;分别是两个坐标系中移动物体的速度 $$\n相对论系数 第一个图示 $$ 如上图，黑色坐标系为一在原地不动的人，蓝色坐标系为一前进的火车 \\\\\\ \\\\ 对于静止不动的人来说，在t=0时刻，一光束从火车上反射到石头处(蓝色竖杠) \\\\\\ \\\\ 在t=t时刻，光束到达石头，火车前进了vt \\\\\\ \\\\ 此时，人离石头距离x = ct $$\n第二个图示 $$ 对于火车来说，在t=t时刻,石头离它的距离x\u0026rsquo;=ct\u0026rsquo; \\\\\\ \\\\ 由于两个时空因为引力产生的度量不同 \\\\\\ \\\\ \\therefore\\begin{cases} x = \\gamma(x\u0026rsquo;+vt\u0026rsquo;) \\\\ x\u0026rsquo; = \\gamma(x-vt)\\end{cases} \\\\\\ \\\\ 又\\begin{cases} x = ct \\\\ x\u0026rsquo;= ct\u0026rsquo; \\end{cases} \\\\\\ \\\\ \\Rightarrow \\gamma = \\frac{1}{\\sqrt{1-\\frac{c^2}{v^2}}} $$\n质量 $$ 在一次动量守恒的碰撞中，从撞击者和被撞击者的角度分别来看\\\\\\ \\\\ mv = (m+m_0)u [1] \\\\\\ \\\\ -mv = (m+ m_0)u\u0026rsquo; [2] \\\\\\ \\\\ u =\\frac{u\u0026rsquo;+v}{1+u\u0026rsquo;v/c^2} [3] \\\\\\ \\\\ 根据以上三式可得出： m=\\frac{m_0}{\\sqrt{1-v^2/c^2}} \\\\\\ \\\\ 此时，牛顿方程\\pmb F = \\frac{d\\pmb p}{dt} = \\frac{d(m\\pmb v)}{dt} = m\\frac{d\\pmb v}{dt} + \\pmb v\\frac{dm}{dt} \\pmb{不再成立} $$\n质能与动量 $$ E_k = \\int_0^v \\pmb F\\cdot d\\pmb r = \\int_0^v\\frac{d(m\\pmb v)}{dt}\\cdot d\\pmb r = \\int_0^r \\pmb v \\cdot d(m\\pmb v) \\\\\\ \\\\ \\because \\pmb v\\cdot d(m\\pmb v) = v^2 dm +m\\pmb v \\cdot d\\pmb v \\\\\\ \\\\ 并且，m=\\frac{m_0}{\\sqrt{1-v^2/c^2}} \\Rightarrow dm = \\frac{mvdv}{c^2-v^2} \\\\\\ \\\\ \\pmb{质能方程：E_k = \\int_{m_0}^mc^2dm= mc^2-m_0c^2} \\\\\\ \\\\ 动能方程是质能方程的特殊情况 \\\\\\ \\\\ E_k = mc^2 - m_0c^2 = m_0c^2(\\frac{1}{\\sqrt{1-v^2/c^2}}-1) 泰勒公式展开 \\\\\\ \\\\ = \\frac{1}{2}m_0v^2 + \\frac{3}{8}m_0 \\frac{v^4}{c^3} + \u0026hellip; $$\n相对论公式总结 六大方面: 质量、长度、速度、时间、能量、动量\n$$ m = \\frac{1}{\\sqrt{1-v^2/c^2}}m_0 \\\\\\ \\\\ L = \\sqrt{1-v^2/c^2} L_0 \\\\\\ \\\\ u = \\frac{u\u0026rsquo;+v}{1+u\u0026rsquo;v/c^2} \\\\\\ \\\\ t = \\frac{1}{\\sqrt{1-v^2/c^2}}t_0 \\\\\\ \\\\ \\pmb p = m\\pmb v = \\frac{m_0\\pmb v}{\\sqrt{1-v^2/c^2}} = \\frac{\\sqrt{K^2 + 2Kmc^2}}{c} \\\\\\ \\\\ E = \\Delta mc^2 $$\n","date":"2022-12-07T05:29:32+08:00","image":"https://downeyflyfan.com/p/%E7%8B%AD%E4%B9%89%E7%9B%B8%E5%AF%B9%E8%AE%BA/1_hu2de589d636666dff036e9f7186e7da49_5116_120x120_fill_q75_box_smart1.jpg","permalink":"https://downeyflyfan.com/p/%E7%8B%AD%E4%B9%89%E7%9B%B8%E5%AF%B9%E8%AE%BA/","title":"狭义相对论"},{"content":"题目 问题 当自动驾驶汽车的比例从10%到50%到90% 影响(影响交通状况的改变)如何改变 是否存在均势(equilibria) ? (什么意思!!!)\n是否存在一个临界点，在该点，改变十分显著\n什么情况下该给这些车(哪些车呢)设置专用车道\n你的分析表明是否有其他策略改变？\n要求 模型应当考虑到以下因素对于交通流量的影响 车道数量 车流高峰 平均交通量 自动驾驶汽车 应当解决 自动驾驶汽车之间的沟通 自动驾驶汽车和非自动驾驶汽车之间的沟通 题目中提供的数据必须要代入你的模型 一些可能有用的信息 高峰期车流量平均占全天的8%\n限速60英里/小时\n里程碑自南向北、自西向东标记\n车道宽度12英尺\n题目中的90号高速是州道，直到它和州际5号路相交\n数据只准用本题提供的数据\n论文1 - 55583 Self-driving vehicle\u0026rsquo;s prospect in traffic network 解决方案 前提和假设 不考虑换道\n考虑安全距离$=v_{ins}\\times t_{response}$\n说实话，这个安全距离的公式有点扯 混合动态道路模型 变量\n单位长度$l_u=4m$(人为设置) 车道数量$n_l=n_{left}+n_{right}$ 邻车距离$d=pos_{former}-pos_{latter}-1$，单位就是单位长度$l_u$ 路的长度$L_R = \\frac{L_{real}}{l_u}$,单位还是$l_u$ 最大速度$V_{max} = 60 mile/h = 27m/s = 7 units/s$ 司机反应时间$t_{response} = 1s$ (根据现实因素人为设置) 瞬时速度$v_{ins}$，单位为$l_u$ 车流量$TC$ ","date":"2022-12-05T04:52:51+08:00","image":"https://downeyflyfan.com/p/2017-mcm/1_hu5bf196b560b3e88b9db7104d8955f026_12174_120x120_fill_q75_box_smart1.jpg","permalink":"https://downeyflyfan.com/p/2017-mcm/","title":"2017 MCM"},{"content":"并联RLC固有响应 图示 推导 $$ \\frac{v}{R} +\\frac{1}{L}\\int_0^t vd\\tau + I_0 + C\\frac{dv}{dt} = 0 \\\\\\ \\\\ 对t取微分得到:\\frac{1}{R}\\frac{dv}{dt} + \\frac{v}{L} + C\\frac{d^2v}{dt^2} = 0 \\\\\\ \\\\ 整理得: \\frac{d^2 v}{dt^2} + \\frac{1}{RC}\\frac{dv}{dt} +\\frac{v}{LC} = 0 [1] $$\n回顾二次微分方程的解法 $$ 假设 v = A e ^{st} \\\\\\ \\\\ 代入[1]式可以得到: Ae^{st} (s^2 + \\frac{s}{RC} + \\frac{1}{LC}) = 0 \\\\\\ \\\\ 解s^2 + \\frac{s}{RC} + \\frac{1}{LC} = 0 \\\\\\ \\\\ 得 s_1 = -\\frac{1}{2RC} + \\sqrt{(\\frac{1}{2RC})^2 - \\frac{1}{LC}} \\\\\\ \\\\ s_2 = -\\frac{1}{2RC} - \\sqrt{(\\frac{1}{2RC})^2 - \\frac{1}{LC}} \\\\\\ \\\\ 最终得到 v = A_1 e^{s_1 t}+A_2 e ^{s_2 t } \\\\\\ \\\\ 改写s_1,s_2 \\\\\\ \\\\ s_1 = -\\alpha + \\sqrt{\\alpha^2 - \\omega_0^2} \\\\\\ \\\\ s_2 = -\\alpha - \\sqrt{\\alpha^2 - \\omega_0^2} \\\\\\ $$\n固有响应参数 参数 名称 取值 $s_1,s_2$ 特征根 如上 $\\alpha$ 奈培频率 $1/2RC$ $\\omega_0$ 谐振角频率 $1/\\sqrt{LC}$ 响应分类 若为两个不同的实根，则为过阻尼响应\n若为两个相同的实根，则为临界阻尼响应\n若为两个共轭复数根，则为欠阻尼响应\n并联RLC电路固有响应的形式 过阻尼响应 通过解 $$ v(0^+) = A_1 + A_2 \\\\\\ \\\\ \\frac{dv(0^+)}{dt} = \\frac{i_C(0^+)}{C} = s_1A_1 + s_2 A_2 $$\n得到$A_1,A_2$的值，进而得到$v$的值 欠阻尼响应 求解 $$ 令\\omega_d = \\sqrt{\\omega_0^2 - \\alpha^2} \\\\\\ \\\\ v(t) = A_1 e^{(-\\alpha + j\\omega_d)t} + A_2e^{(-\\alpha - j\\omega_d)t} \\\\\\ \\\\ = e^{-\\alpha t}(A_1 cos\\omega_d t + j A_1 sin\\omega_d t + A_2cos\\omega_d t - jA_2 sin\\omega_d t) （使用欧拉公式）\\\\\\ \\\\ = e^{-\\alpha t} [(A_1 + A_2)cos\\omega_d t + (A_1-A_2)sin\\omega_d t] \\\\\\ \\\\ 令B_1 = A_1+A_2， B_2 = A_1 - A_2 \\\\\\ \\\\ v(t) = e^{-\\alpha t} (B_1cos\\omega_d t + B_ 2sin\\omega_d t) \\\\\\ \\\\ 进而得到 \\\\\\ \\\\ \\pmb{v(0^+)= B_1} \\\\\\ \\\\ \\pmb{\\frac{dv(0^+)}{dt} = \\frac{i_c(0^+)}{C} =-\\alpha B_1 + \\omega_d B_2} $$\n特性\n欠阻尼系统中，响应是振荡的\n过阻尼系统里，响应趋近于一个最终值\n临界阻尼响应 $$ \\because s_1 =s_2 =\\alpha \\\\\\ \\\\ \\therefore v(t) = D_1 t e^{-\\alpha t} + D_2 e^{-\\alpha t} \\\\\\ \\\\ v(0^+) = D_2 \\\\\\ \\\\ \\frac{dv(0^+)}{dt} = D_1 - \\alpha D_2 $$\n并联RLC阶跃响应 图示 电路的二次微分方程 $$ I = C\\frac{dv}{dt} + i_L + \\frac{v}{R} \\\\\\ \\\\ 其中, v =L\\frac{di}{dt}，\\frac{dv}{dt} = L\\frac{d^2 i }{dt^2} \\\\\\ \\\\ 代入上式并整理得 \\\\\\ \\\\ \\frac{d^2i_L}{dt^2} + \\frac{1}{RC} \\frac{di_L}{dt} + \\frac{i_L}{LC} = \\frac{I}{LC} $$\n串联RLC的固有响应和阶跃响应 固有响应 图示 结果 $$ 过阻尼： i(t) = A_1e^{s_1t} + A_2 e^{s_2 t} \\\\\\ \\\\ 欠阻尼: i(t) = B_1e^{-\\alpha t} cos\\omega_d t + B_ 2e^{-\\alpha t} sin\\omega_d t \\\\\\ \\\\ 临界阻尼: i(t) = D_1 t e^{-\\alpha t} + D_2 e^{-\\alpha t} \\\\\\ \\\\ 其中，奈培频率 \\alpha = \\frac{R}{2L} \\\\\\ \\\\ 谐振角频率 \\omega_0 =\\sqrt{\\frac{1}{LC}} $$\n双集成运放电路 两级联运算放大器 图示 输入输出电压关系 $$ 对于第一个反相输入端 \\\\\\ \\\\ \\frac{0-v_g}{R_1}+ C\\frac{d(0-v_{o1})}{dt} = 0 \\Rightarrow \\frac{dv_{o1}}{dt} = -\\frac{1}{R_1C_1}v_g \\\\\\ \\\\ 同理: \\frac{dv_{o2}}{dt} = - \\frac{1}{R_2C_2}v_g \\\\\\ \\\\ \\therefore \\frac{d^2v_{o2}}{dt^2} = \\frac{1}{R_1C_1}\\frac{1}{R_2C_2}v_g $$\n具有反馈电阻的两级运算放大电路 图示 输入输出电压关系 $$ 对于第一个反相输入端 \\\\\\ \\\\ \\frac{0-v_g}{R_a} + \\frac{0-v_{o1}}{R_1}+ C\\frac{d(0-v_{o1})}{dt} = 0 \\\\\\ \\\\ \\frac{dv_{o1}}{dt} + \\frac{v_{o1}}{C_1R_1}= -\\frac{v_g}{C_1R_a} \\\\\\ \\\\ 同理: \\frac{dv_o}{dt} +\\frac{v_{o}}{C_2R_2} =-\\frac{v_g}{C_1R_b} \\\\\\ \\\\ 令\\tau_1 = R_1C_1 ， \\tau_2 = R_2C_2 \\\\\\ \\\\ 对上式去微分，可以得到 \\\\\\ \\\\ \\frac{d^2v_o}{dt^2} + (\\frac{1}{\\tau_1}+\\frac{1}{\\tau_2})\\frac{dv_o}{dt} +\\frac{1}{\\tau_1\\tau_2}v_o = \\frac{v_g}{R_aC_1 R_bC_2} \\\\\\ \\\\ 解方程得其特征根为 \\\\\\ \\\\ s_1 = -\\frac{1}{\\tau_1}，s_2 = -\\frac{1}{\\tau_2} $$\n","date":"2022-12-05T04:19:53+08:00","permalink":"https://downeyflyfan.com/p/rlc%E7%94%B5%E8%B7%AF/","title":"RLC电路"},{"content":"基本概念 定义 树是n个节点的有限集，有且仅有一个特定的称为根的节点\n图示 特点\n根节点是唯一的 子树的个数没有限制，但他们一定是互不相交的 树中的概念 结点的度(Degree) 结点拥有的子树数 叶结点 度为0的结点 分支结点 度不为0的节点 内部结点 除了根节点以外的分支节点 树的度 树内各结点的度的最大值 结点的关系 Child 结点的子树 Parent 该结点 Sibing 同一个Parent的Child 其他概念 树的深度(Depth)\n结点的最大层次 有序树\n树中结点的各子树从左至右是有序的，则称其为有序树 森林\nm棵互不相交的树的集合 树的ADT 树的存储结构 Parent表示法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define MAXSIZE 100 //具体数字依实际情况而定 typedef int TElemType; typedef struct PTNode { TElemType data; int parent; }PTNode; typedef struct { PTNode Nodes[MAXSIZE]; int r,n; }PTree; Child表示法 多重链表表示法 每个结点有多个指针域，每个指针域指向一棵子树的根节点\nChild表示法 把每个结点的孩子结点排列起来，以单链表作为存储结构将他们存储起来\n图示 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 typedef struct CTNode //定义孩子结点 { int child; struct CTNode *next; }*ChildPtr; typedef struct //定义头结点 { TElemType data; ChildPtr firstchild; }CTBox; typedef struct //定义树 { CTBox nodes[MAXSIZE]; int r,n; // 根的位置和结点数 }CTree; Sibling表示法 方法 设置两个指针，指向该结点的fristchild和rightsib\n结构定义 1 2 3 4 5 typedef struct CSNode { TElemType data; struct CSNode *firstchild,*rightsib; }CSNode,*CSTree; 图示 二叉树 定义 n个结点的有限集合，由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树构成\n特点 每个结点最多两棵子树\n左子树和右子树是有顺序的,一定要区分开\n五种形态\n空二叉树\n只有一个根结点\n根结点只有左子树\n根结点只有右子树\n根结点既有左子树又有右子树\n特殊二叉树 斜树 左斜树和右斜树并称斜树 满二叉树 分支节点均有两个子树的二叉树 图示 完全二叉树 定义\n编号为$i(1\\le i\\le n)$的结点与满二叉树中相应位置编号相同的二叉树 特点\n叶子结点只出现在最下两层 最下层的子叶一定集中在左部连续位置 同样结点数的二叉树，完全二叉树的深度最小 图示 二叉树的性质 在二叉树的第$i$层上，最多只有$2^{i-1}$个结点\n深度为$k$的二叉树，至多有$2^k -1$个结点\n叶结点为$n_0$,度为2的结点数为$n_2$，则$n_0 = n_2 + 1$\n具有$n$个结点的完全二叉树的深度为$\\lfloor log_2 n\\rfloor + 1$\n对于完全二叉树的任意结点$i(1\\le i \\le n)$\n$i=1$，则为根结点 $i \\gt 1$，则parent结点为$\\lfloor i/2 \\rfloor$ $2i \\gt n$，则其无左孩子，否则其左孩子是结点$2i$ $2i+1 \\gt n$，则其无右孩子，否则其右孩子是结点$2i+1$ 二叉树的存储结构 顺序存储结构 一般只用于完全二叉树 二叉链表 结点结构 lchild data rchild 代码表示 1 2 3 4 5 typedef struct BiTNode { TElemType data; struct BiTNode *lchild,*rchild; }BiTNode,*BiTree; 遍历二叉树 定义 从根结点出发，依照某找次序，依次遍历结点，使得每个结点仅被访问一次\n方法 前序遍历 定义 若二叉树为空，则空操作返回;否则先访问根结点,再前序遍历左子树，最后前序遍历右子树\n代码实现 1 2 3 4 5 6 7 8 9 // 通过递归实现前序遍历 void PreOrderTranverse(BiTree *T) { if (T==NULL) return; printf(\u0026#34;%c\u0026#34;,T-\u0026gt;data); //显示结点数据 PreOrderTranverse(T-\u0026gt;lchild); PreOrderTranverse(T-\u0026gt;rchild); } 中序遍历 定义 若二叉树为空，则空操作返回;否则从根结点开始，先中序遍历左子树，再访问根结点，最后中序遍历右子树\n代码实现 1 2 3 4 5 6 7 8 void InOrderTranverse(BiTree *T) { if (T==NULL) return; InOrderTranverse(T-\u0026gt;lchild); printf(\u0026#34;%c\u0026#34;,T-\u0026gt;data); InOrderTranverse(T-\u0026gt;rchild); } 后序遍历 定义可根据上述自行推导\n代码实现\n1 2 3 4 5 6 7 8 void PostOrderTranverse(BiTree *T) { if (T==NULL) return; PostOrderTranverse(T-\u0026gt;lchild); PostOrderTranverse(T-\u0026gt;rchild); printf(\u0026#34;%c\u0026#34;,T-\u0026gt;data); } 二叉树遍历的性质 已知前序和中序遍历(后序和中序遍历)可以确定唯一的二叉树.\n已知前序和后序遍历，无法确定唯一的二叉树.\n二叉树的建立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void CreateBiTree(BiTree *T) { TElemType ch; scanf(\u0026#34;%c\u0026#34;,\u0026amp;ch); if (ch == \u0026#34;#\u0026#34;) *T = NULL; else { *T = (BiTree)malloc(sizeof(BiTNode)); if (!*T) exit(0); (*T)-\u0026gt;data = ch; CreateBiTree(\u0026amp;(*T)-\u0026gt;lchild); CreateBiTree(\u0026amp;(*T)-\u0026gt;rchild); } } 线索二叉树 线索 指向前驱和后继的指针被称为线索，加上线索的二叉链表就被称为二叉链表，相应的二叉树被称为线索二叉树(Threaded Binary Tree)\n线索化 定义 对于二叉树使用某种方式遍历使其成为线索二叉树\n结点结构 lchild ltag data rtag rchild ltag为0时，指向lchild;为1时，指向前驱\nrtag为0时，指向rchild;为1时，指向后继\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 typedef enum {Link, Thread} PointerTag; // Link == 0 代表指向child; // Link == 1 代表指向tag; typedef struct BiThrNode { TElemType data; struct BiThrNode *lchild,*rchild; PointerTag Ltag,Rtag; }BiThrNode,*BiThrNode; // 中序遍历进行中序线索化 void InThreading (BiThrTree p) { if (p) { InThreading(p-\u0026gt;lchild); InThreading(p-\u0026gt;rchild); } } ","date":"2022-12-05T03:16:42+08:00","permalink":"https://downeyflyfan.com/p/%E6%A0%91tree/","title":"树(Tree)"},{"content":"一些基本概念 定义的 一个或多个字符组成的有限序列，又叫字符串\n子串与主串 连续字符组成的子序列称为该串的子串 包含子串的串称为主串 串的比较 方法 通过在Unicode中的顺序（Unicode的前256个字符与ASCII相同）比较\n例子\n当给定两个串$s=\u0026ldquo;a_1a_2\u0026hellip;a_n\u0026rdquo;,t=\u0026ldquo;b_1b_2\u0026hellip;b_n\u0026rdquo;$时，当且仅当$a_i=b_i,i=1,2\u0026hellip;,n$时，我们认为$s=t$ 串的ADT 串的存储结构 顺序存储结构 \\0用来表示串的结束 链式存储结构 朴素的模式匹配算法 算法说明 对字串的每一个字符作为子串的开头，与目标进行匹配\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int Index(String S, String T, int pos) { int i = pos; //主串当前位置下标 int j = 1; // 子串中当前位置下标 while(i \u0026lt;= StringLength(S) \u0026amp;\u0026amp; j \u0026lt;= StringLength(T)) { if(S[i] == T[j]) { i++; j++; } else { i = i-j+2; j=1; } } if (j \u0026gt; StringLength(T)) return i-T[0]; else return 0; } KMP模式匹配算法 原理 i、j分别为S和T的下标\n定义$next[j]$\n作用 反映$j$值的变化 公式 $$ next[j] =\\begin{cases} 0 \u0026amp; j =1 \\\\ Max \\lbrace k | 1\\lt k \\le (j-1) ，且 \u0026lsquo;p_1p_2\u0026hellip;p_{k-1}\u0026rsquo; = \u0026lsquo;p_{j-k+1}\u0026hellip;p_{j-1}\u0026rsquo; \\rbrace \u0026amp; 当此集合不空时 \\\\ 1 \u0026amp; 其他情况 \\end{cases} $$\n对于第二行公式的解释 从$1$到$j-1$相同的字符串\n$next$值推导的例子 $j$ 1 2 3 4 5 6 7 8 9 $T$ a a a a a a a a b $next[j]$ 0 1 2 3 4 5 6 7 8 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Next数组的实现 void get_next(String T,int *next) { int i,j; i = 1; j = 0; next[1] = 0; while(i\u0026lt;StringLength(T)) { if (j==0 || T[i] == T[j]) { i++; j++; next[i] = j; } else j = next[j]; } } // 返回子串T在S中第pos个字符后的位置 int Index_KMP(String S, String T, int pos) { int i = pos; int j = 1; int next[255]; get_next(T,next); //对串T作分析，得到next数组 while(i \u0026lt;= StringLength(S) \u0026amp;\u0026amp; j \u0026lt;= StringLength(T)) { if (j == 0 || S[i] = T[j]) { i++; j++; } else { j = next[j]; } } if (j\u0026gt;StringLength(T)) return i-StringLength(T); else return 0; } KMP模式匹配算法的改进 设置$nextval[j]$ 数组 例 $j$ 1 2 3 4 5 6 7 8 9 $T$ a b a b a a a b a $next[j]$ 0 1 1 2 3 4 2 2 3 $nextval[j]$ 0 1 0 1 1 4 2 1 0 1 2 3 4 5 6 7 8 9 void get_nextval(String T, int *nextval) { if (j==0 || T[i] == T[j]) { i++; j++; if () } } ","date":"2022-12-04T04:45:14+08:00","permalink":"https://downeyflyfan.com/p/%E4%B8%B2/","title":"串"},{"content":"第一章 intersection 交\nunion 并\ndifference 差\nadditivity 可加性\ncomplementation 对立\nconvolution 卷积\nvariance 方差\ncovariance 协方差\ncorrelated 相关\nstandard deviation 标准差\nrandom event 随机事件\ncertain event 必然事件\nimpossible event 不可能事件\nelementary/fundamental event 基本事件\nsample point 样本点\nsample space 样本空间\nClassical probability 古典概型\ngeometric probability 几何概型\nconditional probability 条件概型\ntotal probability 全概率\npair wise independence 两两相互独立\nSampling without replacement 不放回抽样\nSampling with replacement 放回抽样\npermutation 排列数($A_m^n$)\ncombination 组合数 ($C_m^n$)\n第二部分 Distribution function 分布函数\ndiscrete random variable 离散型随机变量\ntwo-point distribution （0-1）分布\nbinomial distribution 二次分布\nPoisson distribution 泊松分布\nhyper geometric distribution 超几何分布\nContinuous random variable 连续型随机变量\nprobability density function 概率密度函数\nuniform distribution 均匀分布\nExponential distribution 指数分布\nstandard normal distribution 标准正态分布\nCauchy distribution 柯西分布\nn-dimensional random vector n维随机变量\nbivariate random variable 二维随机变量\njoint distribution function 联合分布函数\nbivariate discrete random variable 二维离散型随机变量\njoint distribution law 联合分布律\nbivariate continuous random variable 二维连续型随机变量\njoint probability density function 联合概率密度函数\nbivariate normal distribution 二维正态分布\nmarginal distribution function 边缘分布函数\nmarginal distribution law 边缘分布律\nmarginal probability density function 边缘概率密度函数\nconditional distribution function 条件分布函数\nconditional probability density function 条件概率密度函数\n第三部分 mathematical expectation 数学期望\nstandard random variable 标准随机变量\nmoment generating function 矩母函数\ncharacteristic function 特征函数\npositive correlated 正相关\nmixed moment 混合矩\nnegative correlated 负相关\nmixed central moment 混合中心矩\nmoment of order k about the origin 阶原点矩\ncentral moment of order k 阶中心矩\ncovariance matrix 协方差矩阵\nconvergence in probability 依概率收敛\nBernouli large numbers law 伯努力大数定律\nMathematical statistics数理统计\nindividuality 个体\npopulation 总体\nsample size 样本大小\nsimple random sample 随机样本\nstatistic 统计量\nsample variance样本方差\nsample standard deviation 样本标准差\nsample central moment of order k样本的阶中心矩\nskewness [\u0026lsquo;skju:nis] 偏度\ncoefficient of variation 变异系数\norder statistics 次序统计量\ndegrees or freedom 自由度\n第四部分 sampling distribution 抽样分布\nparameter estimation 参数估计\npoint estimation 点估计\nestimator 估计量\nestimate 估计值\nlikelihood function 似然函数\nmethod of moment 矩估计法\nunbiased estimator 无偏估计量\nmaximum likelihood estimate 最大似然估计\nsystem of likelihood equations似然方程组\nconsistent estimator 一致估计量\nconfidence level 置信水平\nconfidence interval 置信区间\nupper confidence limit 置信上限\nparametric hypothesis 参数估计\nnon-parametric hypothesis 非参数估计\nalternative hypothesis 备择假设\nnull hypothesis 零假设\nSignificance level 显著性水平\nrejection region 拒绝域\nacceptance region 接受域\ntest for goodness of fit 拟和优度检验\ncontingency table 列连表\nregression function 回归函数\nregression equation 回归方程\nlinear regression model 线形回归模型\nregression coefficient 回归系数\nnormal linear model 正态线形模型\nleast squares estimate 最小二乘估计\nmethod of least squares 最小二乘法\nsum of squares of residual 残差平方和\nsum of squares of regression 回归平方和\nsum of residual 剩余平方和\ntotal sum of squares of deviations 总变差平方和\ncoefficient of determination 判定系数\npoint interval 点预测\nprediction interval 预测区间\none-way analysis variance 单因素方差分析\ntwo-way analysis of variance 双因素方差分析\ninteraction effect交互效应\n","date":"2022-12-03T19:17:23+08:00","permalink":"https://downeyflyfan.com/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/","title":"概率论英语词汇"},{"content":"正弦信号源 正弦响应 表达 $$ v =V_mcos(\\omega t+\\phi) \\ [1] \\\\\\ \\\\ f =\\frac{1}{T} \\\\\\ \\\\ \\omega=2\\pi f =\\frac{2\\pi}{T} \\\\\\ \\\\ 均方根V_{rms} = \\sqrt{\\frac{1}{T} \\int_{t_0}^{t_0+T}V_m^2cos^2(\\omega t +\\phi)dt} \\\\\\ \\\\ 对于[1]，均方根为\\frac{V_m}{\\sqrt{2}} $$\n正弦响应 正弦电源激励下的RL电路 电流与时间 $$ L\\frac{di}{dt} + Ri = V_mcos(\\omega t + \\phi) \\Rightarrow \\\\\\ \\\\ i = \\frac{-V_m}{\\sqrt{R^2+\\omega^2L^2}}cos(\\phi -\\theta)e^{-(R/L)t}+\\frac{V_m}{\\sqrt{R^2+\\omega^2L^2}}cos(\\omega t + \\phi - \\theta) $$\n稳态响应的性质 稳态响应为一正弦函数\n响应频率与信号源频率相同\n稳态响应的最大值$\\neq$ 信号源的幅值\n稳态响应的相位角与信号源的不同\n相量 频域 正弦信号源的相量 $$ 欧拉定律: e^{\\pm j \\theta} = cos\\theta \\pm j\\cdot sin\\theta \\\\\\ \\\\ \\therefore v = V_mcos(\\omega t +\\phi) = V_m \\Re\\lbrace e^{j(\\omega t +\\phi)} \\rbrace = \\Re\\lbrace{V_me^{j\\omega t}\\cdot e^{j\\phi}}\\rbrace \\\\\\ \\\\ 相量\\pmb V = V_me^{j\\phi} =P\\lbrace{V_mcos(\\omega t + \\phi)}\\rbrace \\\\\\ \\\\ \\pmb V = V_mcos\\theta + jV_msin\\theta \\\\\\ \\\\ 注意, 1e^{j\\phi} = 1 \\angle{\\phi}^{\\circ} $$\n相量算术 $$ 加减法 \\\\\\ \\\\ 将向量转换为复数形式加减 \\\\\\ \\\\ \\pmb{乘除法} \\\\\\ \\\\ \\pmb{V_a\\angle{\\phi}^{\\circ} \\pm V_b\\angle{\\theta}^{\\circ} = V_aV_b\\angle({\\phi \\pm \\theta})^{\\circ}} $$\n反相量变换 定义 $$ P^{-1}\\lbrace V_me^{j\\phi}\\rbrace = \\Re \\lbrace V_m e^{j\\omega t} e^{j\\phi}\\rbrace $$\n相量法的特点 $$ 如果V = \\sum_{i=1}^n V_i\\Rightarrow \\pmb{V = \\sum_{i=1}^n V_i} $$\n频域下的无源电路元件 伏安特性 $$ i =I_mcos(\\omega t + \\phi) \\\\\\ \\\\ 对于电阻\\\\\\ \\\\ \\pmb V=R\\pmb I \\\\\\ \\\\ 对于电感 \\\\\\ \\\\ v = L\\frac{di}{dt} = -\\omega LI_msin(\\omega t + \\phi) = -\\omega L I_m cos(\\omega t +\\phi -\\frac{\\pi}{2}) \\\\\\ \\\\ \\pmb V = -\\omega L I_m e^{j(\\phi - \\frac{\\pi}{2})} = -\\omega L I_m e^{j\\phi}e^{j(-\\pi/2)} = j\\omega I_m L e^{j\\phi} = j\\omega L \\pmb I \\\\\\ \\\\ 对于电容 \\\\\\ \\\\ \\pmb V =\\frac{1}{j\\omega C} \\pmb I = -\\frac{j}{\\omega C} \\pmb I $$\n阻抗和电抗 定义 阻抗是一种电气参数，表示一个电路中电流和电压之间的相对关系，它是一个复数量，由实部和虚部组成。\n电抗是一种电气参数，表示一个电路中电流和电压之间的相对关系，但它只是一个实数量，只由实部组成。\n阻抗与导纳 $$ \\pmb V = Z\\pmb I \\\\\\ \\\\ Z = R + jX \\\\\\ \\\\ Z: Impedence \\ R: resistance \\ X: reactance \\\\\\ \\\\ Y = G +jB \\\\\\ \\\\ Y: Admittance \\ G: Conductance \\ B: susceptance $$\n阻抗和电抗 电路元件 阻抗 电抗 电阻 $R$ - 电感 $j\\omega L$ $\\omega L$ 电容 $\\frac{1}{j\\omega C}$ $-1/\\omega C$ 串并联 三角形-星形变换 并联阻抗与串联阻抗的合并 串联阻抗 $$ Z_{ab}=\\sum_{i=1}^n Z_i $$\n并联阻抗与串联阻抗的合并 公式 $$ 导纳 Y= \\frac{1}{Z_{ab}}=\\sum_{i=1}^n\\frac{1}{Z_i} \\\\\\ \\\\ Y = \\frac{1}{Z} = G +jB(S) $$\n导纳和电纳 电路参数 导纳 电纳 电阻 G - 电感 $j(-1/\\omega L)$ $-1/\\omega L$ 电容 $j\\omega C$ $\\omega C$ 三角形-星形变换 图示 关系 与时域下的关系一样一样 电源变换 戴维南-诺顿等效电路 具体情况与时域下的相同 变压器 线性变压器电路 电路图 推导 $$ 左边电路KVL方程: \\pmb {V_s} = \\pmb I_1(Z_s + R_1 + j\\omega L_1 ) - j\\omega M\\pmb I_2 \\\\\\ \\\\ 右边KVL方程 :\\pmb{I_2}(R_2+Z_L+j\\omega L_2) - j\\omega M \\pmb{I_1} = 0 \\\\\\ \\\\ 令 Z_{11} = Z_s+R_1+j\\omega L_1， Z_2 = Z_L+R_2 + j\\omega L_2 \\\\\\ \\\\ 我们可以得到 $$\n结论 $$ \\pmb I_1 =\\frac{Z_{22}}{Z_{11}Z_{22}+\\omega^2M^2} \\pmb V_s \\\\\\ \\\\ \\pmb I_2 = \\frac{j\\omega M}{Z_{11}Z_{22}+\\omega^2M^2}\\pmb V_s = \\frac{j\\omega M}{Z_{22}}\\pmb I_1 \\\\\\ \\\\ 对于电源内部, Z_{int} = \\frac{V_s}{I} = Z_{11}+ \\frac{\\omega^2M^2}{Z_{22}}\\\\\\ \\\\ Z_{ab} = Z_{11} + \\frac{\\omega^2 M^2}{Z_{22}}-Z_s = R_1+j\\omega L_1 + \\frac{\\omega^2 M^2}{(R_2+j\\omega L_2+Z_L)} [1] $$\n反射阻抗 $$ [1]式中的Z_r =\\frac{\\omega^2 M^2}{(R_2+j\\omega L_2+Z_L)}被称为\\pmb{反射阻抗} \\\\\\ \\\\ 将Z_L=R_L+jX_L \\\\\\ \\\\ 得到Z_r = \\frac{\\omega^2 M^2}{|Z_{22}|^2}[(R_2+R_L)-j(\\omega L_2 + X_L)] $$\n理想变压器 前提 耦合系数为1($k=1$)\n$L_1 = L_2 \\rightarrow +\\infin$\n寄生电阻造成的线圈损失忽略不计\n继续推导 $$ 当耦合为紧耦合时，两磁通相同 \\\\\\ \\\\ \\frac{L_1}{L_2} = (\\frac{N_1}{N_2})^2 \\\\\\ \\\\ \\because L_1 = L_2 \\rightarrow +\\infin \\\\\\ \\\\ \\therefore X_{ab} = (\\frac{N_1}{N_2})^2 X_L \\\\\\ \\\\ Z_{ab} = R_1 + (\\frac{N_1}{N_2})^2 R_2 + (\\frac{N_1}{N_2})^2 (R_L + jX_L) \\\\\\ \\\\ $$\n电流比与电压比 $$ \\frac{V_1}{N_1} = \\frac{V_2}{N_2} \\\\\\ \\\\ I_1N_1 = I_2N_2 $$\n理想电压器的阻抗匹配 图示 关系\n$$ 令 a = \\frac{N_1}{N_2} \\\\\\ \\\\ 易知\\frac{V_1}{I_1} = a^2 \\frac{V_2}{I_2} = a^2 Z_L\\\\\\ \\\\ Z_{IN} = \\frac{V_1}{V_2}= a^2Z_L \\\\\\ \\\\ 即：理想变压器的次级线圈的负载阻抗以水平因子a^2反映到了初级线圈上 $$\n","date":"2022-12-03T18:42:48+08:00","permalink":"https://downeyflyfan.com/p/%E6%AD%A3%E5%BC%A6%E7%A8%B3%E6%80%81%E5%88%86%E6%9E%90/","title":"正弦稳态分析"},{"content":"RL电路的固有响应 电路图 电流与时间 $$ 对于最右边的网孔列KVL方程 \\\\\\ \\\\ L\\frac{di}{dt}+iR = 0 \\\\\\ \\\\ \\pmb{i(t)=I_0e^{(-R/L)t}，t\\gt 0}\\\\\\ \\\\ 零时刻，电压产生突变 \\\\\\ \\\\ v(0^-) = 0，v(0^+) = I_0R ，v(0)位置 $$\n功率 能量 $$ p =i^2R = I_0^2Re^{(-2R/L)t} \\\\\\ \\\\ W = \\int_0^t p d\\tau = \\frac{1}{2}LI_0^2(1-e^{-2(R/L)t}), t\\ge 0 $$\n时间常数 定义 $\\tau =L/R$ 替换后 $$ i(t) = I_0e^{-(t/\\tau)} \\\\\\ \\\\ v(t)= I_0Re^{-(t/\\tau)} \\\\\\ \\\\ p =I_0^2 R e^{-2t/\\tau} \\\\\\ \\\\ W =\\frac{1}{2}LI_0^2(1-e^{-2t/\\tau}) $$\n总结 先求$I_0$\n再求$\\tau = L/R$\n最后求$i(t)$\nRC电路的固有响应 电路图 电压与时间 功率 能量 $$ 引入时间常数\\tau = RC \\\\\\ \\\\ 推导方式同RL电路 \\\\\\ \\\\ v(t)=V_0e^{-t/\\tau} \\\\\\ \\\\ i(t) = \\frac{V_0}{R} e^{-t\\tau} \\\\\\ \\\\ p = \\frac{V_0^2}{R} e^{-2(t/\\tau)}\\\\\\ \\\\ w = \\frac{1}{2}CV^2(1-e^{-2(t/\\tau)}) $$\nRL RC电路的阶跃响应 RL 电路的阶跃响应 图示 电流与时间 $$ V_s = Ri + L\\frac{di}{dt} \\\\\\ \\\\ i(t) = \\frac{V_s}{R} + (I_0-\\frac{V_s}{R})e^{-t/\\tau} \\\\\\ \\\\ \\Rightarrow \\pmb {i(t) = \\frac{V_s}{R}(1-e^{-t/\\tau})} \\\\\\ \\\\ i(t) \\rightarrow \\frac{V_s}{R} $$\n电流与时间的变化率 $$ \\frac{di}{dt} = \\frac{V_s}{R}e^{-t/\\tau}\\\\\\ \\\\ \\frac{di}{dt}(0) = \\frac{V_S}{R} \\\\\\ $$\n其他变量 $$ v = L\\frac{di}{dt} = (V_s-I_0R)e^{-t/\\tau} \\\\\\ \\\\ $$\nRC电路的阶跃响应 电路图 公式 $$ V = V_s + (V_0 - V_s)e^{-\\frac{t}{RC}} \\\\\\ \\\\ i =(I_S-\\frac{V_0}{R})e^{-t/\\tau},t\\ge 0 $$\n阶跃响应与固有响应的一般解法 公式表达 $$ 对于方程\\frac{dx}{dt}+\\frac{x}{\\tau} = K \\\\\\ \\\\ 终值x_f = K\\tau \\\\\\ \\\\ \\pmb{x(t) =x_f+[x(t_0)-x_f]e^{-(t-t_0)/\\tau}} $$\n步骤 确定电路的有关变量 对于RC电路，选择电容电压 对于RL电路，选择电感电流 决定初始量 对于电容电压或电感电流, 因为不能突变,,$x(t_0^-)=x(t_0)=x(t_0^+)$ 对于其他量，应当注意其突变 计算$x_f$\n计算$\\tau$\n按序换路 做题就行 无限响应 电路响应按照指数规律增长而不是衰减\n积分放大器 图示 推导 $$ v_n = v_p =0 \\\\\\ \\\\ i_n =i_f + i_ s = 0\\Rightarrow i_f = -i_s \\\\\\ \\\\ i_f=C_f\\frac{dv_0}{dt} \\\\\\ \\\\ \\frac{dv_0}{dt}=\\frac{1}{C_f}(-i_s)= -\\frac{1}{R_sC_f}v_S \\\\\\ \\\\ v_0(t) = -\\frac{1}{R_sC_f} \\int_{t_0}^t v_s d\\tau + v_0(t_0) $$\n","date":"2022-12-03T02:18:32+08:00","permalink":"https://downeyflyfan.com/p/rlrc%E7%94%B5%E8%B7%AF%E7%9A%84%E5%93%8D%E5%BA%94/","title":"RL,RC电路的响应"},{"content":"电感 电感的电压与电流 $$ 根据定义\\\\\\ \\\\ v=L\\frac{di}{dt} \\\\\\ \\\\ di = \\frac{v}{L}dt \\\\\\ \\\\ L\\int_{i(0)}^{i(t)} di = \\int_0^t vd\\tau \\\\\\ \\\\ i(t)=\\frac{1}{L}\\int_0^tvd\\tau +i(0) $$\n电感的功率和能量 $$ p = vi =Li\\frac{di}{dt} \\\\\\ \\\\ \\int_0^t p d\\tau = \\int_{i(0)}^{i(t)}Lidi \\\\\\ \\\\ pt = \\frac{1}{2}L(i(t)^2-i(0)^2) \\\\\\ \\\\ 当i(0)=0时,W=\\frac{1}{2}Li^2 $$\n特点 端电流不允许跃变\n端电压允许跃变\n端电流为常量时，短路\n电容 电压 电流 功率 能量 $$ 推导方式与电感相同，可以得出 \\\\\\ \\\\ i = C\\frac{dV}{dt} \\\\\\ \\\\ V =\\frac{1}{C} \\int_0^ti(\\tau) d\\tau + v(0) \\\\\\ \\\\ W =\\frac{1}{2}Cv^2 $$\n特点 端电压不能突变\n端电流可以突变\n当电压为常数时，相当于断路\n电容 电感 串并联 电感串并联 $$ 串联: L_{eq} =\\sum_{i=1}^n L_i \\\\ \\\\ 并联：\\frac{1}{L_{eq}}= \\sum_{i=1}^n \\frac{1}{L_i} \\\\\\ $$\n电容串并联 $$ 串联: \\frac{1}{C_{eq}} = \\sum_{i=1}^n \\frac{1}{C_i} \\\\ \\\\ 并联: C_{eq} = \\sum_{i=1}^n C_i \\\\\\ $$\n互感 详见物理学——电磁感应部分\n","date":"2022-12-03T01:56:41+08:00","permalink":"https://downeyflyfan.com/p/%E7%94%B5%E6%84%9F%E7%94%B5%E5%AE%B9%E4%B8%8E%E4%BA%92%E6%84%9F/","title":"电感、电容与互感"},{"content":"栈的定义和操作名称 定义 栈是限定仅可在表尾进行删除和插入的线性表 后进先出形(LIFO)的线性表 基本概念 栈顶(top) 栈可删除和插入的一端 栈底(bottom) 另一端为栈底 空栈 没有元素的栈 操作 插入 也叫进栈，压栈，入栈 删除 弹栈，出栈 栈的ADT 1 2 3 4 5 6 7 8 9 10 11 12 Data 同线性表 Operation IintStack(*S):初始化建立空栈 DestroyStack(*S): 摧毁一个栈 ClearStack(*S):清空栈 StackEmpty(S):栈为空，返回true,否则返回false GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素 Push(*S,e):插入 Pop(*S,*e):删除，并用e返回被删除的元素 StackLength:返回栈S的元素个数 endADT 栈的顺序存储结构 结构定义 1 2 3 4 5 6 typedef int SElemType; //根据实际情况确定栈的元素类型 typedef struct { SElemType data[MAXSIZE]; int top;//用于栈顶指针 }SqStack; 入栈\n1 2 3 4 5 6 7 8 Status Push(SqStack *S, SElemType e) { if (S-\u0026gt;top==MAXSIZE-1)//栈满 return -1; S-\u0026gt;top++; S-\u0026gt;data[S-\u0026gt;top]=e; return 0; } 出栈\n1 2 3 4 5 6 7 8 Status Pop(SqStack *S, SElemType *e) { if (S-\u0026gt;top==-1)//空栈 return -1; *e = S-\u0026gt;data[S-\u0026gt;top]; S-\u0026gt;top--; return -1; } 两栈共享空间 结构 将两栈的顶部接到一起 结构代码 1 2 3 4 5 6 typedef struct { SElemType data[MAXSIZE]; int top1; int top2; }SqDoubleStack 操作 插入 1 2 3 4 5 6 7 8 9 10 Status Push(SqDoubleStack *S, SElemType e, int StackNumber) //StackNumber 用来判断插入栈1还是栈2 { if(S-\u0026gt;top1++=S-\u0026gt;top2)//栈满 return -1; if(StackNumber == 1) S-\u0026gt;data[++S-\u0026gt;top1]=e; if(StackNumber == 2) S-\u0026gt;data[--S-\u0026gt;top2]=e; } 删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Status Pop(SqDoubleStack *S, SElemType *e,int StackNumber) { if (StackNumber == 1) { if (S-\u0026gt;top1==-1)//空栈 return -1; *e = S-\u0026gt;data[S-\u0026gt;top1]; top1++; } if (StackNumber == 2) { if (S-\u0026gt;top2 == MAXSIZE)//空栈 return -1; *e = S-\u0026gt;data[S-\u0026gt;top2]; top2--; } return 0; } 栈的链式存储结构 定义 简称链栈 特点 栈顶在头部 没有头结点 结构代码 1 2 3 4 5 6 7 8 9 10 11 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode,*LinkStackPtr; typedef struct LinkStack { LinkStackPtr top; int count; }LinkStack; 操作 进栈 1 2 3 4 5 6 7 8 Status Push(LinkStack *S, SElemType e) { LinkStackPtr s = (LinkStackPtr) malloc(sizeof(StackNode)); s-\u0026gt;data=e; s-\u0026gt;next=S-\u0026gt;top; S-\u0026gt;count++; return 0; } 出栈 1 2 3 4 5 6 7 8 9 10 11 12 Status Pop(LinkStack *S, SElemType *e) { LinkStackPtr p; if (StackEmpty(*S))//空栈 return -1; *e = S-\u0026gt;top-\u0026gt;data; p = S-\u0026gt;top; S-\u0026gt;top=S-\u0026gt;top-\u0026gt;next; free(p); S-\u0026gt;count--; return 0; } 栈的应用 递归 斐波那契数列 数学定义 $$ F(n)=\\begin{cases}0 \u0026amp; n=0 \\\\ 1 \u0026amp; n=1 \\\\ F(n-1)+F(n-2) \u0026amp; n \\ge 2\\end{cases} $$\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int Fib(int n) { if (n == 0) return 0; else if (n==1) return 1; else return F(n-1)+F(n-2); } int main() { int i = 0; for(i=0;i\u0026lt;40;i++) { printf(\u0026#34;%d\u0026#34;,Fib(n)); } return 0; } 文字定义 调用自己的函数(包括直接和间接)称作递归函数\n四则运算表达式求值 后缀表达式 原则 数字依次进栈 有运算符号,出两个数字 下面的数字在运算符号前 上面的数字在运算符号后 例 9 3 1 - 3 * + 10 2 / + = 20\n中缀表达式转后缀表达式 中缀表达式就是平时用到的表达式\n转换\n数字按顺序输出\n符号依次进栈\n若下方的符号运算优先级高于上方，输出该符号及其上方的符号\n队列(FIFO) 定义 只允许在一端插入，另一端删除的线性表\n队尾 只允许插入的一端 队头 只允许删除的一端 ADT 1 2 3 4 Data 同线性表，有前驱和后继，元素类型相同 Operation 循环队列 定义 队列的头尾相连的顺序存储结构\n结构 初始化 长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 结构定义 typedef int QElemType; typedef struct { QElemType data[MAXSIZE]; int front; int rear; }SqQueue; // 初始化 Status Sqinit(SqQueue *Q) { Q-\u0026gt;front = 0; Q-\u0026gt;rear = 0; return 0; } // 长度 int QueueLegnth(SqQueue Q) { return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE); } 入列和出列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 入列 Status EnQueue(SqQueue *Q,QElemType e) { if ((Q-\u0026gt;rear + 1) == Q-\u0026gt;front) return -1; Q-\u0026gt;data[Q-\u0026gt;rear] = e; Q-\u0026gt;rear = (Q-\u0026gt;rear+1)%MAXSIZE; return 0; } // 出列 Status DeQueue(SqQueue *Q, QElemType *e) { if (Q-\u0026gt;rear == Q-\u0026gt;front) return -1; *e=Q-\u0026gt;data[Q-\u0026gt;front]; Q-\u0026gt;front = (Q-\u0026gt;front + 1)% MAXSIZE; } 队列的链式存储结构 定义 线性表的单链表，称为链队列\n结构 1 2 3 4 5 6 7 8 9 10 typedef struct Node { QElemType data; struct Node *next; }QNode,*QueuePtr; typedef struct { QueuePtr front,rear; }LinkQueue; 入列 出列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 入列 Status EnQueue (LinkQueue *Q, QElemType e) { QueuePtr s = (QueuePtr) malloc (sizeof(Node)); if(!s) exit(0); s-\u0026gt;data = e; s-\u0026gt;next = NULL; Q-\u0026gt;rear-\u0026gt;next = s; Q-\u0026gt;rear = s; return 0; } // 出列 Status DeQueue(LinkQueue *Q, QElemType *e) { QueuePtr p; if (Q-\u0026gt;front == Q-\u0026gt;rear) return -1; p = Q-\u0026gt;front-\u0026gt;next; *e = p-\u0026gt;data; Q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; if(Q-\u0026gt;rear = p) Q-\u0026gt;rear = Q-\u0026gt;free; free(p); return 0; } ","date":"2022-12-01T23:55:15+08:00","permalink":"https://downeyflyfan.com/p/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","title":"栈和队列"},{"content":"运算放大器端子 重要的端子 反相输入\n同相输入\n输出\n正电源\n负电源\n图示 运放电路符号 运放简化电路符号 端电压和端电流 端电压变量 $$ 理想状态 \\\\\\ \\\\ v_p = v_n $$\n端电流变量 $$ 理想状态 \\\\\\ \\\\ i_p=i_n=0 \\\\\\ \\\\ i_0=-(i_{c^-}+i_{c^+}) $$\n运放的电压传输特性 图示 $$ 理想状态 \\\\\\ \\\\ A \\rightarrow \\infin $$\n公式 $$ v_0=\\begin{cases}+V_{CC} \u0026amp; A(v_p-v_n)\\gt V_{CC} \\\\ A(v_p-v_n) \u0026amp; -V_{CC}\\le A(v_p-v_n) \\le +V_{CC} \\\\ -V_{CC} \u0026amp; A(v_p-v_n) \\lt -V_{CC}\\end{cases} $$\n反相放大器电路 图示 推导 $$ i_f+i_s=i_n = 0 \\\\\\ \\\\ v_n=v_p=0 \\\\\\ \\\\ \\frac{v_0}{R_f}+\\frac{v_s}{R_s} = 0\\\\\\ \\\\ \\therefore v_0=-\\frac{R_f}{R_s}v_s \\\\\\ \\\\ |v_0|\\le V_{CC} $$\n求和放大器电路 图示 推导 $$ 通过节点电压法可以得到 \\\\\\ \\\\ v_0=-(\\frac{R_f}{R_a}v_a+\\frac{R_f}{R_b}v_b+\\frac{R_f}{R_c}v_c) \\\\\\ \\\\ 若R_a=R_b=R_c=R_s \\\\\\ \\\\ v_0=-\\frac{R_f}{R_s}(v_a+v_b+v_c) \\\\\\ \\\\ 若R_f=R_S \\\\\\ \\\\ v_0=v_a+v_b+v_c，输入与输出电压正好反相 $$\n同相放大器电路 图示 推导 $$ \\frac{v_0-v_n}{R_f}+\\frac{v_n}{R_s}=0\\\\\\ \\\\ v_0=\\frac{R_f+R_S}{R_s}v_n $$\n差分放大器 图示 推导 $$ 对于反相节点\\\\\\ \\\\ \\frac{v_n-v_a}{R_A}+\\frac{v_0-v_n}{R_b}= 0 \\\\\\ \\\\ 对于同相节点 \\\\\\ \\\\ v_p=\\frac{R_d}{R_c+R_d}v_b = v_n \\\\\\ \\\\ \\Rightarrow v_0=\\frac{R_d(R_a+R_b)}{R_a(R_c+R_d)}v_b-\\frac{R_b}{R_a}v_a\\\\\\ \\\\ 当\\frac{R_a}{R_b}=\\frac{R_c}{R_d} \\\\\\ \\\\ v_0=\\frac{R_b}{R_a}(v_b-v_a) $$\n关于差分放大器的其他问题 共模输入与差模输入 $$ v_{dm} = v_b-v_a \\\\\\ \\\\ v_{cm} = \\frac{v_a+v_b}{2} \\\\\\ \\\\ \\therefore v_0=A_{cm}v_{cm}+A_{dm}v_{dm} \\\\\\ \\\\ 当R_a=R_c，R_b=R_d \\\\\\ \\\\ v_0 = (o)v_{cm}+\\frac{R_b}{R_a}v_{dm} $$\n","date":"2022-12-01T20:47:09+08:00","permalink":"https://downeyflyfan.com/p/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"运算放大器"},{"content":"大数定律 总体表述 $$ E(X_i)=\\mu \\\\\\ \\\\ 在一定条件下 \\\\\\ \\\\ Y=\\frac{X_1+X_2+\u0026hellip;+X_n}{n}收敛到\\mu $$\n依概率收敛 定义 随机变量序列$Y_1,Y_2,Y_3 \u0026hellip;$,若存在某常数$c$，使得$\\forall \\varepsilon \\gt 0$,都有$\\underset{n\\rightarrow \\infin}{lim} P \\lbrace |Y_n-c|\\ge \\varepsilon\\rbrace = 0$,则称$\\lbrace Y_n,n\\ge 1 \\rbrace$依概率收敛于常数$c$\n记为 $Y_n \\overset{P}{\\longrightarrow} c$\n这是一种概率意义上的收敛，而不是数学意义上的收敛\n性质 若$X_n \\overset{P}{\\longrightarrow} a, Y_n\\overset{P}{\\longrightarrow} b$ , $g$在$(a,b)$上连续，则$g(X_n,Y_n)\\overset{P}{\\longrightarrow} g(a,b)$\n若$X_n \\overset{P}{\\longrightarrow} a$，$f(x)$在点$a$连续，则$f(X_n)\\rightarrow f(a)$\n马尔可夫不等式与切比雪夫不等式 马尔可夫不等式 定义 设随机变量$Y$的$k$阶矩存在$(k\\gt 1)$，则对于$\\forall \\varepsilon \\gt 0$，都有 $P\\lbrace |Y|\\ge \\varepsilon \\rbrace \\le \\frac{E(|Y^k|)}{\\varepsilon^k}$\n等价形式 $$ P\\lbrace Y \\ge \\varepsilon \\rbrace \\le\\frac{E(Y^k)}{\\varepsilon^k} $$\n证明 $$ 对于\\forall \\varepsilon \\gt0 ，令Z =\\begin{cases}\\varepsilon \u0026amp; |Y|\\ge \\varepsilon \\\\ 0 \u0026amp; |Y| \\lt \\varepsilon \\end{cases} \\\\\\ \\\\ \\therefore Z \\le |Y| \\Rightarrow Z^k \\le |Y|^k \\Rightarrow E(Z^k) \\le E(|Y|^k) \\\\\\ \\\\ 根据Z的定义 \\\\\\ \\\\ E(Z^k) = \\varepsilon^k P\\lbrace |Y|\\ge \\varepsilon\\rbrace \\\\\\ \\\\ \\therefore P\\lbrace |Y|\\ge \\varepsilon\\rbrace = \\frac{E(Z^k)}{\\varepsilon^k} \\le \\frac{E(|Y|^k)}{\\varepsilon^k} $$\n切比雪夫不等式 —— 马尔可夫不等式的特殊情况 定义 对于$\\forall \\varepsilon \\gt 0$，都有 $P\\lbrace |X-E(X)| \\ge \\varepsilon \\rbrace \\le \\frac{Var(X)}{\\varepsilon^2}$\n等价形式 $$ P\\lbrace |X-E(X)| \\lt \\varepsilon \\rbrace = 1 - \\frac{Var(X)}{\\varepsilon^2} $$\n证明 $$ 在马尔可夫不等式中， 令Y = X -E(X)，k = 2 \\\\\\ \\\\ 有P(|X-E(X)|\\ge \\varepsilon ) = \\frac{E[(X-E(X))^2]}{\\varepsilon^2} = \\frac{Var(X)}{\\varepsilon^2} $$\n几个大数定律 (弱)大数定律 $$ 设Y_1\u0026hellip;.Y_n为一个随机变量序列 \\\\\\ \\\\ 若存在常数序列 \\lbrace c_n,n\\ge 1 \\rbrace，使得 \\\\\\ \\\\ n \\longrightarrow \\infin 时,\\frac{1}{n}\\sum_{i=1}^nY_i-c_n \\overset{P}{\\longrightarrow} 0 \\\\\\ \\\\ 即,\\forall \\varepsilon \\ge 0, 有\\underset{n\\longrightarrow \\infin}{lim} P\\lbrace \\Big | \\frac{1}{n} \\sum_{i=1}^n Y_i -c_n\\Big| \\ge \\varepsilon\\rbrace = 0 \\\\\\ \\\\ 则称\\lbrace Y_i,i\\ge 1 \\rbrace服从\\pmb{(弱)大数定律} \\\\\\ \\\\ 特别的，当c_n =c，n=1,2\u0026hellip;时，可以改写为 \\\\\\ \\\\ \\frac{1}{n}\\sum_{i=1}^nY_i \\overset{P}{\\longrightarrow} c，n\\longrightarrow +\\infin $$\n切比雪夫大数定律 定义 $$ X_1, \u0026hellip; X_n相互独立,且有相同的数学期望\\mu和方差\\sigma^2 \\\\\\ \\\\ 当n\\longrightarrow +\\infin 时，\\frac{1}{n}\\sum_{k=1}^nX_k \\overset{P}{\\longrightarrow} \\mu $$\n证明 $$ \\because E(\\frac{1}{n}\\sum_{i=1}^nX_i) = \\frac{1}{n}E(\\sum_{i=1}^nX_i) = \\mu \\\\\\ \\\\ Var(\\frac{1}{n}\\sum_{i=1}^nX_i) = \\frac{1}{n^2}Var(\\sum_{i=1}^nX_i) = \\frac{\\sigma^2}{n} \\\\\\ \\\\ 利用切比雪夫不等式 \\\\\\ \\\\ 0 \\le P(\\Big| \\frac{1}{n}\\sum_{i=1}^nX_i - \\mu\\Big| \\ge \\varepsilon) \\le Var(X)/\\varepsilon^2 = \\frac{\\sigma2}{n\\varepsilon^2} \\longrightarrow 0 $$\n辛倾大数定律 $$ X_1,\u0026hellip;X_n\\pmb{独立同分布},E(X_i) = \\mu \\\\\\ \\\\ 当n \\longrightarrow + \\infin，\\frac{1}{n}\\sum_{i-1}^nX_i \\overset{P}{\\longrightarrow} \\mu \\\\\\ \\\\ \\pmb{推论}\\\\\\ \\\\ 若h(x)是连续函数，E(h(X_i)) = a 存在 \\\\\\ \\\\ 则当 n \\longrightarrow + \\infin， \\frac{1}{n} \\sum_{i=1}^n h(X_i) \\overset{P}{\\longrightarrow} a $$\n贝努力大数定律 定义 $$ 设n_A 为n重贝努力试验中A事件发生的次数 \\\\\\ \\\\ 且A事件在每次试验中发生的概率为P \\\\\\ \\\\ 有 \\frac{n_A}{n}\\longrightarrow P ，n\\longrightarrow + \\infin $$\n证明 $$ 设 X_i =\\begin{cases}1 \u0026amp; 第i次试验中A发生 \\\\ 0 \u0026amp; 第i次试验中A不发生 \\end{cases} \\\\\\ \\\\ 即X_i～B(1,p) ，且X_i相互独立\\\\\\ \\\\ 有 n_A = \\sum_{i=1}^kX_i \\\\\\ \\\\ \\frac{n_A}{n} = E(X_i) = p $$\n中心极限定律 独立同分布的中心极限定律 $$ X_1\u0026hellip;X_n独立同分布 \\\\\\ \\\\ E(X_i) = \\mu， Var(X_i) = \\sigma^2 \\\\\\ \\\\ 对于\\forall x \\in R, \\underset{n\\longrightarrow + \\infin}{lim} P(\\frac{\\sum_{i=1}^kX_i - n\\mu}{\\sqrt n \\sigma} ) = \\int_{-\\infin}^x \\frac{1}{\\sqrt{2\\pi}}e^{- \\frac{t^2}{2}} dt = \\Phi(X) \\\\\\ \\\\ \\therefore 当 n 充分大时 \\\\\\ \\\\ \\sum_{i=1}^k X_i \\overset{近似}{～} N(n\\mu,n\\sigma^2) \\\\\\ \\\\ \\frac{1}{n}\\sum_{i=1}^k X_i \\overset{近似}{～}N(\\mu,\\frac{\\sigma^2}{n}) $$\n拉普拉斯中心极限定律 $$ \\underset{n\\longrightarrow + \\infin}{lim} P\\Big(\\frac{n_A-np}{\\sqrt{np(1-p)}}\\le x\\Big) = \\int_{-\\infin}^x \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}} dt = \\Phi(X) $$\n","date":"2022-12-01T04:04:03+08:00","image":"https://downeyflyfan.com/p/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/1_hu3d03a01dcc18bc5be0e67db3d8d209a6_207802_120x120_fill_q75_box_smart1.jpg","permalink":"https://downeyflyfan.com/p/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/","title":"大数定律和中心极限定理"},{"content":"数学期望 定义 离散型 设离散型随机变量$X$的分布律为$P(X=x_k)=p_k,k=1,2\u0026hellip;$，若级数$\\sum_{k=1}^{+\\infin}|x_k|p_k\\lt + \\infin$，那么称该级数为$X$的数学期望, 记为\n$$ E(X)=\\sum_{k=1}^{+\\infin}x_kp_k $$\n连续型 $$ E(X)=\\int_{-\\infin}^{+\\infin}xf(x)dx $$\n随机变量函数的数学期望 一元随机变量函数 $Y=g(X)$,且级数收敛,则\n$$ 对于\\pmb{离散型} \\\\\\ \\\\ E(Y)=E[g(X)] = \\sum_{k=1}^{+\\infin}g(x_k)p_k \\\\\\ \\\\ 对于\\pmb{连续型} \\\\\\ \\\\ E(Y)=E(g(X)) = \\int_{-\\infin}^{+\\infin}g(x)f(x)dx $$\n二元随机变量函数 $Z=h(X,Y)$\n$$ 对于\\pmb{离散型} \\\\\\ \\\\ E(Z)=E[h(X,Y)] = \\sum_{i=1}^{+\\infin}\\sum_{j=1}^{+\\infin}h(x_i,y_j)p_{ij} \\\\\\ \\\\ 对于\\pmb{连续型} \\\\\\ \\\\ E(Z) = E(h(X,Y)) = \\int_{-\\infin}^{+\\infin}\\int_{-\\infin}^{+\\infin}h(x,y)f(x,y)dxdy $$\n数学期望的特性 线性组合的数学期望 $$ E(c_0+\\sum_{i=1}^nc_ix_i) = c_0+\\sum_{i=1}^nc_iE(X_i) $$\n随机变量的独立性 $$ 满足E(\\prod_{i=1}^n X)=\\prod_{i=1}^nE(X_i)的随机变量\\\\\\ \\\\ X_i，i=1,2\u0026hellip; n 相互独立 $$\n方差 定义 方差 $$ Var(X)=E\\lbrace\\big [X-E(X)\\big ]^2\\rbrace $$ 记方差为$Var(X)$或$D(X)$\n标准差 记$\\sqrt{Var(X)}$为$\\sigma(x)$，称为标准差或均方差，与$X$有相同的量纲\n计算公式 $$ Var(X)=E\\lbrace X^2-2XE(X)+E^2(X) \\rbrace \\\\\\ \\\\ \\pmb {Var(X) =E(X^2)-E^2(X)} $$\n方差的性质 线性组合的方差 $$ Var(c_0+\\sum_{i=1}^n c_iX_i) = \\sum_{i=1}^nc_i^2Var(X_i) $$\n方差=0 $$ Var(X)=0\\Leftrightarrow P(X=C)=1,C=E(X) $$\n几种常见分布的均值和方差 分布 概率分布律或概率密度函数 数学期望 方差 0-1分布 $P(X=k)=p^k(1-p)^{1-k}$ $p$ $p(1-p)$ 二项分布 $P(X=k)=C_n^kp^k(1-p)^{1-k}$ $np$ $np(1-p)$ 泊松分布 $P(X=k)=\\frac{e^{-\\lambda}\\lambda^k}{k!}$ $\\lambda$ $\\lambda$ 均匀分布 $f(x) = \\begin{cases} 1/(b-a) \u0026amp; a\\lt x \\lt b \\\\ 0 \u0026amp; otherwise \\end{cases}$ $\\frac{a+b}{2}$ $\\frac{(b-a)^2}{12}$ 指数分布 $f(x) =\\begin{cases}\\lambda e^{-\\lambda x} \u0026amp; x \\gt 0\\\\ 0 \u0026amp; otherwise \\end{cases}$ $1/\\lambda$ $1/\\lambda^2$ 正态分布 $f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},x \\in R$ $\\mu$ $\\sigma^2$ 协方差和相关系数 协方差 定义 定义$E\\lbrace[X-E(X)][Y-E(Y)]\\rbrace$为协方差，记为$Cov(X,Y)$\n$$ Cov(X,Y) = \\lbrace[X-E(X)][Y-E(Y)]\\rbrace $$\n计算公式 $$ Cov(X,Y)=E(XY)-E(X)E(Y) $$\n方差性质补充 $$ Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y) $$\n性质 $Cov(aX,bY)=ab\\cdot Cov(X,Y)$\n$Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$\n当$Var(X)Var(Y)\\neq 0$，$(Cov(X,Y))^2\\le Var(X)Var(Y)$\n相关系数 定义 $$ \\rho_{XY}=\\frac{Cov(X,Y)}{\\sqrt{Var(X)Var(Y)}} \\\\\\ \\\\ \\rho_{XY}=Cov(\\frac{X-E(X)}{\\sqrt{Var(X)}},\\frac{X-E(Y)}{\\sqrt{Var(Y)}}) $$\n性质 $\\rho_{XY}\\le 1$\n存在常数$a,b$，使$P(Y=a+bX)=1$,特别地;$\\rho_{XY}=1$时，$b\\gt 0$ , $\\rho_{XY}=-1$时，$b\\lt 0 \\Rightarrow |\\rho_{XY}|=1$\n作用 一个表征$X,Y$之间的线性关系紧密程度的量\n当$\\rho_{XY}\\gt 0$,$X与Y$正相关\n当$\\rho_{XY}\\lt 0$,$X与Y$负相关\n当$\\rho_{XY} = 0$,$X与Y$不相关\n其他数字特征 k阶(原点)矩 $$ E(X^k)，k=1,2,\u0026hellip; $$\nk阶中心矩 $$ E\\lbrace[X-E(X)]^k\\rbrace，k=1,2\u0026hellip; $$\nk+l阶混合(原点)矩 $$ E\\lbrace X^kY^l\\rbrace, k,l=1,2 $$\nk+l阶混合中心矩 $$ E\\lbrace[X-E(X)]^k[Y-E(Y)]^k\\rbrace $$\n多元随机变量的数字特征 数学期望向量 设n元随机变量$\\pmb X =(X_1,X_2,\u0026hellip;X_n)^T$,则称\n$$ E(\\pmb X)= (E(X_1),E(X_2),\u0026hellip;E(X_n))^T $$\n为$n$元随机变量的数学期望向量 协方差矩阵 设二元随机变量$(X_1,X_2)$的四个二阶中心矩存在，则\n$$ \\begin{pmatrix}Var(X_1) \u0026amp; Cov(X_1,X_2) \\\\ Cov(X_2,X_1) \u0026amp; Var(X_2) \\end{pmatrix} $$\n称为协方差矩阵 ","date":"2022-11-30T22:10:32+08:00","permalink":"https://downeyflyfan.com/p/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/","title":"随机变量的数字特征"},{"content":"静电的基本现象和规律 电荷守恒 场强叠加 库仑定律 $$ \\pmb F_{12}=k\\frac{q_1q_2}{r^2}\\pmb r_{12} \\\\\\ \\\\ 单位: C \\ \\ 1C=1A\\cdot s \\\\\\ \\\\ e = 1.602\\times 10^{-19} (C) \\\\\\ \\\\ 在MKSA单位制中，k=\\frac{1}{4\\pi \\varepsilon_0} \\\\\\ \\\\ \\varepsilon_0 = 8.85\\times 10^{-12} \\ C/(N\\cdot m^2)，k=8.99\\times 10^9(N\\cdot m^2/C^2) \\\\ $$\n电场 电场强度 电场强度的定义 $$ \\pmb E=\\frac{\\pmb F}{q_0}=\\frac{1}{4\\pi\\varepsilon_0}\\frac{q_0}{r^2}\\pmb{\\widehat r} \\\\\\ $$\n高斯定理 立体角(暂定) $$ d\\Omega=\\frac{dS}{r^2} \\Rightarrow d\\Omega = \\frac{\\widehat{\\pmb r}\\cdot d\\pmb S}{r^2} \\\\\\ $$\n高斯定理的表述和证明 表述 通过任意闭合曲面的电通量等于该面包围的所有电量的代数和除以$\\varepsilon_0$\n证明 $$ d\\Phi_E=\\pmb E\\cdot d \\pmb S=\\frac{q}{4\\pi\\varepsilon_0} \\frac{\\widehat{\\pmb r}\\cdot d\\pmb S}{r^2} = \\frac{q}{4\\pi\\varepsilon_0}d\\Omega \\\\\\ \\\\ \\oiint d\\Phi_E=\\frac{q}{4\\pi\\varepsilon_0}\\oiint d\\Omega = \\frac{q}{\\varepsilon_0} \\\\\\ \\\\ \\Phi_E = \\int \\pmb E \\cdot d\\pmb S = \\frac{Q_{in}}{\\varepsilon_0} \\\\\\ \\\\ $$\n","date":"2022-11-30T04:50:46+08:00","permalink":"https://downeyflyfan.com/p/%E9%9D%99%E7%94%B5%E5%9C%BA/","title":"静电场"},{"content":"[toc]\n一、术语 节点 两个或更多元件的连接点 基本节点 三个或更多元件的连接点 路径 基本元件相连的踪迹(相同元件不能重复出现) 支路 连接两个节点的路径 基本支路 连接两个基本节点的路径，不通过基本节点 回路 闭环路径 平面电路 画在平面上没有交叉的电路 超节点 当一个电压源在两个基本节点之间，这两个节点可以组合成一个超节点 超网孔 相邻网孔间只有电流源，可以合并为一个超网孔 二、方法 节点电压法 步骤 调整电路布局，使得电路没有交叉\n选择参考节点\n确定节点电压\n非参考节点到参考节点的电压升 在非参考节点处列$KCL$方程 注意可以合并形成的超节点 网孔电流法 寻找网孔电流\n在每个网孔中列$KCL$方程\n两种方法的选择 谁的方程最少\n是否包含超节点\n是否包含超网孔\n题目要求解的是什么\n电源变换 图示 方法 电压源串电阻 $\\Leftrightarrow$ 电流源并电阻 $$ i_s=\\frac{v_s}{R} $$\n戴维南-诺顿等效电路 图示 戴维南电阻推导 $$ 先计算开路电压V_{Th} \\\\\\ \\\\ 再计算短路电流 i_{sc}=\\frac{V_{Th}}{R_{Th}} \\\\\\ \\\\ R_{Th}=\\frac{V_{Th}}{i_{sc}} $$\n诺顿等效电路 最大功率传输 将电路简化为戴维南电阻连着负载$R_L$ $$ p = i^2R_L = (\\frac{V_{Th}}{R_{Th}+R_L})^2R_L \\\\\\ \\\\ 令\\frac{dp}{dR_L} = 0 \\Rightarrow R_L=R_{Th} \\\\\\ \\\\ p_{max} = \\frac{V_{Th}^2}{4R_L} $$\n叠加原理 当一个线性系统被一个以上的独立源激励或驱动时，总响应是单独响应的和\n总结 网孔电流法只适用于平面电路\n节点电压法适用于平面电路和非平面电路\n","date":"2022-11-29T04:29:48+08:00","permalink":"https://downeyflyfan.com/p/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%B3%95/","title":"电路分析法"},{"content":"[toc]\n一、麦克斯韦电磁理论 1.1 位移电流 理清四个概念 $$ 电场强度\\pmb E\\\\\\ \\\\ 电位移矢量(电感应强度) \\pmb D=\\varepsilon_0 \\pmb E+\\pmb P，单位:C/m^2\\\\\\ \\\\ 磁感应强度\\pmb B\\\\\\ \\\\ 磁场强度\\pmb H=\\frac{\\pmb B}{\\mu_0} $$\n库仑定律+场强叠加定律$\\Rightarrow$ $$ 电场的高斯定律\\\\\\ \\\\ \\oiint\\pmb D\\cdot d\\pmb S=q_0\\\\\\ \\\\ 静电场的环路定律\\\\\\ \\\\ \\oint\\pmb E\\cdot d\\pmb l=0 $$\nBio-Sarurt定律$\\Rightarrow$ $$ 磁场的高斯定律\\\\\\ \\\\ \\oiint \\pmb B\\cdot d\\pmb S=0\\\\\\ \\\\ 安培环路定律 \\\\\\ \\\\ \\oint \\pmb H\\cdot d\\pmb l=I_0 $$\n磁场变化的规律 $$ 法拉第电磁感应定律\\\\\\ \\\\ \\xi =-\\frac{\\partial \\Phi_B}{\\partial t} $$\n位移电流的推导 $$ \\\\ \\oint \\pmb H \\cdot d\\pmb l = I_0=\\oiint \\pmb j_0\\cdot d\\pmb S=-\\frac{dq_0}{dt}\\\\\\ \\\\ \\because \\oiint \\pmb D\\cdot d\\pmb S=q_0\\Rightarrow \\frac{dq_0}{dt}=\\oiint \\frac{\\partial \\pmb D}{\\partial t}d\\pmb S，代入上式\\\\\\ \\\\ \\oiint (\\pmb j_0+\\frac{\\partial \\pmb D}{\\partial t})d\\pmb S=0\\Rightarrow \\pmb j_0+\\frac{\\partial \\pmb D}{\\partial t}是个连续量\\\\\\ \\\\ 其中,\\frac{\\partial \\pmb \\Phi_0}{\\partial t}=\\iint \\frac{\\partial \\pmb D}{\\partial t}\\cdot d\\pmb S叫做\\pmb{位移电流}\\\\\\ \\\\ \\frac{\\partial \\pmb D}{\\partial t}叫做\\pmb{位移电流密度}\\\\\\ \\\\ I_0=\\iint \\pmb j_0\\cdot d\\pmb S叫做\\pmb{全电流}\\\\\\ \\\\ 故\\oint \\pmb H\\cdot d\\pmb l = I_0 + \\frac{\\partial \\pmb \\Phi_D}{\\partial t } $$\n位移电流与传导电流 位移电流是电场变化产生的 传导电流是电荷在导体中移动产生的 1.2 麦克斯韦方程组 积分形式 $$ \\oiint \\pmb D\\cdot d\\pmb S=q_0\\\\\\ \\\\ \\oint \\pmb E\\cdot d\\pmb l=-\\iint\\frac{\\partial \\pmb B}{\\partial t }\\cdot d\\pmb S\\\\\\ \\\\ \\oiint \\pmb B\\cdot d\\pmb S=0\\\\\\ \\\\ \\oint \\pmb H\\cdot d\\pmb l=I_0+\\iint\\frac{\\partial \\pmb D}{\\partial t}d\\pmb S\\\\\\ \\\\ $$\n微分形式 $$ \\nabla \\cdot \\pmb D=\\rho_0\\\\\\ \\\\ \\nabla\\times\\pmb E=-\\frac{d\\pmb B}{dt}\\\\\\ \\\\ \\nabla \\cdot \\pmb B=0\\\\\\ \\\\ \\nabla \\times \\pmb H=\\pmb j_0+\\frac{\\partial \\pmb D}{\\partial t} $$\n最基本形式 $$ \\nabla\\cdot \\pmb E=\\frac{\\rho_0}{\\varepsilon_0}\\\\\\ \\\\ \\nabla\\times\\pmb E=-\\frac{d\\pmb B}{dt}\\\\\\ \\\\ \\nabla \\cdot \\pmb B=0\\\\\\ \\\\ \\nabla\\times \\pmb B= \\varepsilon_0\\mu_0\\frac{\\partial \\pmb E}{\\partial t } +\\mu_0\\pmb j_0 $$\n1.3 边界条件(暂定) 二、电磁波理论 2.1 平面电磁波的解(暂定) 自由空间的麦克斯韦方程 $$ \\nabla\\cdot \\pmb D=0 \\\\\\ \\\\ \\nabla\\times \\pmb E=-\\mu_0\\frac{\\partial \\pmb H}{\\partial t}\\\\\\ \\\\ \\nabla\\cdot \\pmb H=0\\\\\\ \\\\ \\nabla\\times\\pmb H=\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t} $$\n电磁场中的位置关系 $$ \\pmb E\\perp\\pmb B\\perp 传播方向\\pmb k\\\\\\ \\\\ $$\n2.2 平面电磁波的性质 电磁波是横波\n$\\pmb E$和$\\pmb B$同相位\n$\\pmb{E\\times N}$与传播方向始终同向\n$\\pmb E$和$\\pmb B$的幅值成比例\n$$ \\varepsilon_0^2E_0=\\mu_0^2H_0^2 = B_0^2 $$\n电磁波的速率$v=\\frac{1}{\\sqrt{\\varepsilon_0\\mu_0}}=c$ 三、电磁场的能流密度矢量和动量 3.1 ","date":"2022-11-29T01:00:20+08:00","permalink":"https://downeyflyfan.com/p/%E9%BA%A6%E5%85%8B%E6%96%AF%E9%9F%A6%E7%94%B5%E7%A3%81%E7%90%86%E8%AE%BA%E4%B8%8E%E7%94%B5%E7%A3%81%E6%B3%A2/","title":"麦克斯韦电磁理论与电磁波"},{"content":"[toc]\n一、二元离散型随机变量 定义 设$X=X(e)$和$Y=Y(e)$是定义在$S$上的随机变量，由它们构成的向量$(X,Y)$叫做二元随机变量\n联合概率分布 定义 若二元随机变量的取值有限，则称$(X,Y)$是离散型随机变量\n概率分布律 $$ P(X=x_i,Y=y_j)=p_{ij},i,j=1,2\u0026hellip; $$\n性质 $p_{ij}\\ge 0$ $\\sum_{i=1}^\\infin\\sum_{j=1}^\\infin p_{ij}=1$ 边际分布 $$ P(Y=y_j)=P(X\\le+\\infin,Y=y_j)=\\sum_{i=1}^\\infin p_{ij}=p_{\\cdot j},j=1,2\u0026hellip;\\\\\\ \\\\ P(X=x_i)= P(X=x_i,Y\\le+\\infin)=\\sum_{j=1}^{+\\infin}p_{ij}=p_{i\\cdot},i=1,2\u0026hellip; $$\n条件分布 $$ P(X=x_i|Y=y_j)=\\frac{p_{ij}}{p_{\\cdot j}},i=1,2\u0026hellip; $$\n二、二元随机变量的分布函数 联合分布函数 定义 $$ F(x,y)=P(X\\le x,Y\\le y) $$\n性质 $F(x,y)$关于$x,y$单调不减\n$F(x,y)\\le 1,F(+\\infin,+\\infin)=1$\n$F(x,y)$关于$x,y$右连续\n若$x_1\\le x_2,y_1\\le y_2$,$F(x_2,y_2)-F(x_2,y_1)-F(x_1,y_2)+F(x_1,y_1)\\ge0$\n边缘分布函数 定义 二元随机变量$(X,Y)$中$X$和$Y$的分布函数$F_X(x),F_Y(y)$被称为边缘分布函数\n$$ F_X(x)=F(x,+\\infin)\\\\\\ \\\\ F_Y(y)=F(+\\infin,y) $$\n条件分布函数 $$ F_{X|Y}(x|y)=P(X\\le x|Y=y)=\\frac{P(X\\le x,Y=y)}{P(Y=y)} $$\n三、二元连续型随机变量 (联合)概率密度函数 定义 若对于为二元随机变量$(X,Y)$,若存在$f(x,y)$ $$ F(x,y)=\\int_{-\\infin}^y\\int_{-\\infin}^xf(u,v)dudv $$ 称$(X,Y)$为二元随机变量的联合概率密度函数 性质 $\\int_{-\\infin}^{\\infin}\\int_{-\\infin}^{+\\infin}f(x,y)dxdy=1$\n对于$f(x,y)$上的连续点有\n$$ \\frac{\\partial^2 F(x,y)}{\\partial x\\partial y}=f(x,y) $$\n边缘概率密度函数 定义 $$ f_X(x)=\\int_{-\\infin}^{+\\infin}f(x,y)dy\\\\\\ \\\\ f_Y(y)=\\int_{-\\infin}^{+\\infin}f(x,y)dx $$\n边缘分布函数 $$ F_X(x)=\\int_{-\\infin}^xf_X(u)du \\\\\\ \\\\ F_Y(y)=\\int_{-\\infin}^yf_Y(v)dv $$\n条件概率密度函数 定义 $$ f_{X|Y}(x,y)=\\frac{f(x,y)}{f_Y(y)}\\\\\\ \\\\ f_{Y|X}(x,y)=\\frac{f(x,y)}{f_X(x)} $$\n性质 $\\int_{-\\infin}^{+\\infin}f_{X|Y}(x,y)=1$\n$P(a\\lt X\\lt b|Y=y)=\\int_a^bf_{X|Y}(x,y)dx$\n$f(x,y)=f_{X|Y}(x|y)f(y)=f_{Y|X}(y|x)f(x)$\n二元均匀分布与二元正态分布 二元均匀分布 定义 $$ f(x,y)\\begin{cases} \\frac{1}{D的面积} \u0026amp; (x,y)\\in D\\\\ 0 \u0026amp; otherwise\\end{cases} $$\n性质 二元均匀分布的条件分布仍为均匀分布 二元正态分布 $$ f(x,y)=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}\\cdot exp(\\frac{-1}{2(1-\\rho^2)}[\\frac{(x-\\mu_1)^2}{\\sigma_1^2}-2\\rho\\frac{(x-\\mu_1)(y-\\mu_2))}{\\sigma_1\\sigma_2}+\\frac{(y-\\mu_2)^2}{\\sigma_2^2}])\\\\\\ \\\\ x,y\\in R,-1\\lt \\rho\\lt 1, \\sigma_1\\gt 0,\\sigma_2\\gt 0 $$\n四、随机变量的独立性 定义 若对所有实数$x,y$，有$F(x,y)=F_X(x)F_Y(y)$,称随机变量$X,Y$相互独立\n分类 若为离散型随机变量 $$ X,Y相互独立\\Leftrightarrow p_{ij}=p_i\\cdot p_j对于一切i,j成立 $$\n若为连续型随机变量 $$ X,Y相互独立\\Leftrightarrow f(x,y)=f(x)f(y) $$\n五、二元随机变量的函数的分布 $Z=X+Y$分布函数 推导 $$ F_Z(z)=P(Z\\le z)=\\underset{x+y\\le z}\\iint f(x,y)dxdy\\\\\\ \\\\ = \\int_{-\\infin}^{+\\infin}[\\int_{-\\infin}^{z-y} f(x,y)dx]dy \\\\\\ \\\\ = \\int_{-\\infin}^{+\\infin}[\\int_{-\\infin}^zf(u-y,y)du]dy \\ (u=x+y) \\\\\\ \\\\ = \\int_{-\\infin}^z[\\int_{-\\infin}^{+\\infin}f(u-y,y)dy]du \\\\\\ \\\\ 又根据定义有: F_Z(z)=\\int_{-\\infin}^z f_Z(u)du\\\\\\ \\\\ \\therefore f_Z(z)=\\int_{-\\infin}^{+\\infin}f(z-y,y)dy \\\\\\ \\\\ f_Z(z)=\\int_{-\\infin}^{+\\infin}f(x,z-x)dx $$\n定义卷积公式 当$X$和$Y$独立时 $$ f_Z(z)=\\int_{-\\infin}^{+\\infin}f_X(z-y)f_Y(y)dy=\\int_{-\\infin}^{+\\infin}f_X(x)f_Y(z-x)dx $$\n","date":"2022-11-29T00:55:01+08:00","permalink":"https://downeyflyfan.com/p/%E5%A4%9A%E5%85%83%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/","title":"多元随机变量及其分布"},{"content":"随机变量 定义 设随机试验的样本空间为$S={e}$，若$X=X(e)$定义为S上的实值单值函数，则称$X=X(e)$为随机变量\n一般采用大写字母$X,Y,Z$表示随机变量\n引入随机变量是为了描述随机变量\n分类 一般的，若$I$是一个实数集合，则$X\\in I$为事件${e:X(e)\\in I}$\n离散型随机变量 连续型随机变量 解释 某随机变量的随机分布是该随机变量能够取到某些值的一系列概率的集合\n离散型随机变量及其分布 2.1 定义 取值至多可数的随机变量称为离散型随机变量\n2.2 概率分布律 $X$ $x_1$ $x_2$ \u0026hellip; $x_n$ $P$ $p_1$ $p_2$ \u0026hellip; $p_n$ 2.3 性质 $p_i\\geq 0$\n$\\sum_{i=1}^np_i=1$\n2.4 几个重要的随机变量分布 2.4.1 0-1分布（两点分布） 若X的分布律为： $X$ $0$ $1$ $p$ $q$ $1-q$ 称$X ～ 0-1(P)$，或$B(1,p)$\n分布律还可以写成 $P(X=k)=p^k(1-p)^{1-k},k=0,1$ 2.4.2 二项分布 n重贝努利试验 设试验E只有两个可能的结果，将E独立、重复进行n次，称这一串独立重复试验为n重贝努利试验\n二项分布的定义 设$A$在$n$重贝努力试验中发生X次，称$X$服从参数为$n,p$的二项分布\n记为$X～B(n,p)$ 概率分布律 $$ P(X=k)=C_n^kp^k(1-p)^{n-k},k=0,1,\u0026hellip;n $$\n2.4.3 泊松分布 服从概率分布律为 $$ P(X=k)=\\frac{\\lambda^ke^{-\\lambda}}{k!},k=0,1,2\u0026hellip;,\\lambda\\ge0 $$\n的随机变量$X$服从参数为$\\lambda$的泊松分布 记为 $X～P(\\lambda)$ 泊松分布与二项分布 $$ 当n\\gt 10,p\\lt0.1时\\\\\\ \\\\ C_n^kp^k(1-p)^{1-k}\\approx \\frac{e^{\\lambda}\\lambda^k}{k!},\\lambda = np $$\n2.4.4 超几何分布 满足 $$ P(X=k)=\\frac{C_a^kC_b^{n-k}}{C_N^n},k=l_1,l_1+1\u0026hellip;l_2\\\\\\ \\\\ l_1=max(0,n-b),l_2=min(a,n) $$ 则称$X$服从超几何分布 记为$X～H(N,n,M)$,N是总数，n是样本量，M是A或B 2.4.5 几何分布 满足 $$ P(X=k)=p(1-p)^{1-k},k=1,2,3\u0026hellip;,0\\lt p\\lt 1 $$\n称$X$服从参数$p$的几何分布 记为$X～GE(p)$ 2.4.6 帕斯卡分布 定义 满足 $$ P(X=k)=C_{k-1}^{r-1}p^r(1-p)^{k-r},k=r,r+1\u0026hellip;,0\\lt p\\lt 1 $$\n称为帕斯卡分布 含义 每次试验成功概率为p,进行到成功r次为止的分布即位帕斯卡分布\n其中，几何分布是帕斯卡分布中$r=1$的特殊情况 分布函数 概率质量函数 分布函数 定义 $X$为一随机变量，对任意实数$x$，函数$F(x)=P(X\\le x)$记为$X$的分布函数\n任何随机变量都有相应的分布函数 性质 $0\\le F(x)\\le 1$\n$F(x)$单调不减\n$F(-\\infin)=0，F(+\\infin)=1$\n$F(x)$右连续，即$F(x+0^+)=F(x)$\n$F(x)-F(x-0)=P(X=x)$\n概率质量函数(p.f.) 定义 $$ f(x) = P(X=x) \\\\\\ \\\\ 其中,\\lbrace x:f(x)\\gt 0 \\rbrace 叫做support \\ of \\ distribution \\ of \\ X $$\n四、连续型随机变量及其概率密度函数 4.1 定义 对于随机变量$X$的分布函数$F(X)$,若存在非负的函数$f(x)$，使对于任意实数$x$\n$$ F(x)=\\int_{-\\infin}^{\\infin}f(t)dt $$\n$X$为连续型随机变量 $f(x)$为概率密度函数($p.d.f$)，简称密度函数 4.2 $f(x)$的性质 $f(x)\\ge 0$\n$\\int_{-\\infin}^{+\\infin}f(x)dx=1$\n对于任意实数$x_1,x_2(x_2\\gt x_1)$ $$ P{x_1\\lt X\\lt x_2}=F(x_2)-F(x_1)=\\int_{x_1}^{x_2}f(t)dt $$\n$P(X=a)=0,a\\in R$\n在$f(x)$的连续点，$F\u0026rsquo;(x)=f(x)$\n4.3 几个重要的连续型随机变量分布 4.3.1 均匀分布 定义 满足 $$ f(x)=\\begin{cases}\\frac{1}{b-a} \u0026amp; x\\in(a,b)\\\\ 0 \u0026amp; otherwise\\end{cases} $$ 则称$X$在区间$(a,b)$上服从均匀分布，记为$X～(a,b)$ 性质 当在区间$(a,b)$时,概率只与横坐标长度有关，与横坐标位置无关\n分布函数\n$$ F(x)=\\begin{cases} 0 \u0026amp; x\\le a\\\\ \\frac{x-a}{b-a} \u0026amp; a\\le x \\le b \\\\ 1 \u0026amp; x \\ge b\\end{cases} $$\n4.3.2 正态分布（高斯分布） 定义 满足 $$ f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}, -\\infin \\lt x \\lt +\\infin, \\\\\\ \\\\ -\\infin \\lt \\mu \\lt +\\infin，\\sigma \\gt 0 $$\n称$X$服从参数为$\\mu,\\sigma$的正态分布 记为 $X～N(\\mu,\\sigma^2)$ 性质 $f(x)$关于$x=\\mu$对称\n$f_{max}=f(\\mu)=\\frac{1}{\\sqrt{2\\pi}\\sigma}$\n$\\underset{|x-\\mu|\\rightarrow\\infin}{lim}f(x)=0$\n独立的$n$个正态变量的线性组合仍然服从正态分布\n标准正态分布 推导 $$ 令t=\\frac{x-\\mu}{\\sigma}，dx=\\sigma dt\\\\\\ \\\\ f(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}},-\\infin\\lt t \\lt +\\infin \\\\\\ \\\\ $$\n上述概率密度函数记为标准正态分布\n$$ 密度函数\\varphi(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}\\\\\\ \\\\ 分布函数\\Phi(x)=\\int_{-\\infin}^x\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt\\\\\\ \\\\ 且\\pmb{\\Phi(x)+\\Phi(-x)=1} $$\n4.3.3 指数分布 定义 满足 $$ f(x)=\\begin{cases} \\lambda e^{-\\lambda x} \u0026amp;x\\gt 0 \\\\ 0 \u0026amp; x \\le 0 \\end{cases} $$\n的$X$服从参数为$\\lambda$的指数分布 记为$X～E(\\lambda)$ 性质 分布函数 $$ F(x)= \\begin{cases} 1 - e^{-\\lambda x} \u0026amp; x\\gt 0\\\\ 0 \u0026amp; x\\le 0\\end{cases} $$\n无记忆性 $$ For \\ t_0 \\gt 0,t\\gt 0\\\\\\ \\\\ P(X\\gt t_0+t|X\\gt t_0)=\\frac{P(X\\gt t_0+t)}{P(X\\gt t_0)}\\\\\\ \\\\ =\\frac{1-F(t_0+t)}{1-F(t_0)} = e^{-\\lambda t}=P(X\\gt t) $$\n五、随机变量函数的分布 5.1 定理1 设$X～f_X(x)，-\\infin \\lt x\\lt +\\infin，g\u0026rsquo;(x)\\neq 0. \\ Y=g(X)，x=h(y)$,则$Y$的概率密度函数为\n$$ f_Y(y)=\\begin{cases}f_x(h(y))\\cdot|h\u0026rsquo;(y)| \u0026amp; \\alpha \\lt x\\lt \\beta \\\\ 0 \u0026amp; otherwise\\end{cases} $$\n5.2 定理2 一般的，若$X～N(\\mu,\\sigma^2)，Y=aX+b\\Rightarrow Y～ N(a\\mu+b,a^2\\sigma^2)$\n六、总结 对于$F(x)$,概率是函数值；对于$f(x)$，概率是面积\n概率为1不一定是必然事件,概率为0不一定是不可能事件,积事件为0不一定为互斥事件\n无记忆性说明在结束之前，变量$X$始终服从指数分布\n","date":"2022-11-28T23:12:50+08:00","permalink":"https://downeyflyfan.com/p/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/","title":"随机变量及其分布"},{"content":"样本空间 随机事件 随机试验 可重复 结果的可能性已知 结果未知 样本空间 定义 随机试验E的所有结果构成的集合称为E的样本空间，记为$S={e}$\n特征 exhaustive\n必须包含所有的元素 mutually exclusive\n不能有相同的元素 随机事件 定义 我们称样本空间$S$的子集$A$为$E$的随机事件$A$,简称事件$A$,当且仅当$A$所包含一个样本点发生，称事件$A$发生\n特征 A是相应的样本空间S的一个子集 当且仅当A的一个样本的出现A才发生 事件的分类 基本事件 由一个样本点组成的单点集 必然事件 每次试验S总是发生，则S被称为必然事件 不可能事件 空集$\\Phi$为不可能事件 事件的关系与运算 $$ \\pmb{包含关系}\\\\\\ \\\\ A \\subset B: A发生\\Rightarrow B一定发生\\\\\\ \\\\ \\begin{cases} A\\subset B\\\\ B\\subset A \\end{cases} \\Rightarrow A = B\\\\\\ \\\\ \\pmb{积事件与和事件}\\\\\\ \\\\ 和事件:\\bigcup^n_{i=1}A_i: A_i中至少有一个发生\\\\\\ \\\\ 积事件: \\bigcap_{i=1}^nA_i:A_i同时发生\\\\\\ \\\\ A\\bigcap B可以简写成AB,以此类推\\\\\\ \\\\ \\pmb{互斥事件/互不相容 \\ \\ disjoint \\ event \\ or \\ mutually \\ exclusive}\\\\\\ \\\\ 当AB=\\phi时，A,B互斥\\\\\\ \\\\ \\pmb{逆事件/对立事件}\\overline A\\\\\\ \\\\ 记\\overline A为A的逆事件,有\\begin{cases} A\\bigcup \\overline A =S \\\\ A\\overline A = \\phi \\end{cases}\\\\\\ \\\\ 上述定理 的逆定理也成立\\\\\\ \\\\ \\pmb{差事件} \\\\\\ \\\\ A\\overline B = A - B \\Leftrightarrow {x|x\\in A ,x\\notin B}\\\\\\ \\\\ \\pmb{补集} \\\\\\ \\\\ A^C = {{s \\in S|s \\notin A}} $$\n和、积关系式 —— 德摩根定律 $$ (A \\bigcup B)^c = A^c \\bigcap B^c \\\\\\ \\\\ (A \\bigcap B)^c = A^c \\bigcup B^c \\\\\\ \\\\ 推广 \\\\\\ \\\\ \\overline{\\bigcap_{i=1}^n A_i}=\\bigcup_{i=1}^n\\overline {A_i}=\\overline {A_1}\\bigcup \\overline {A_2}\u0026hellip;\\overline {A_n}\\\\\\ \\\\ \\overline{\\bigcup_{i=1}^n A_i} = \\bigcap_{i=1}^n \\overline{A_i}= \\overline{A_1} \\ \\overline{A_2}\u0026hellip;\\overline{A_n}\\\\\\ \\\\ $$\n其他公式 $$ P(A\\overline B) = P(A)-P(AB) \\\\\\ \\\\ A\\bigcap \\Big(B\\bigcup C\\Big) = AB\\bigcup AC $$\n频率与概率 频率 定义 $$ f_n(A)=\\frac{n_A}{n} $$\n$n_A$为事件出现的次数 n为试验的总次数 性质 $0\\leq f_n(A)\\leq 1$\n$f_n(S) = 1$\n若$A_1,A_2\u0026hellip;A_n$两两互斥,则$f_n(\\bigcup_{i=1}^k A_i) = \\sum_{i=1}^kf_n(A_i)$\n$f_n(A)$随n的增大稳定，稳定值记为p\n概率 定义 非负, $P(A)\\ge 0$\n规范, $P(S)=1$\n可列可加性\n若$A_1,A_2\u0026hellip;A_n$两两互斥(disjoint events),则$P(\\bigcup_{i=1}^k A_i) = \\sum_{i=1}^kP(A_i)$ 性质 $P(\\phi)=0$\n若$A_1,A_2\u0026hellip;A_n$两两互斥,则$P(\\bigcup_{i=1}^k A_i) = \\sum_{i=1}^kP(A_i)$\n$P(A)=1-P(\\overline A)$\n概率的减法公式\n$$ 若A\\subset B，则P(B-A)=P(B)-P(A) \\Rightarrow P(B) \\gt P(A)\\\\\\ \\\\ 一般情况下,P(B-A)= P(B)-P(AB) $$\n概率的加法公式 $$ 对于两个事件A和B\\\\\\ \\\\ P(A\\bigcup B) =P(A)+P(B)-P(AB)\\\\\\ \\\\ 对于三个事件A,B,C\\\\\\ \\\\ P(A\\bigcup B\\bigcup C) = P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)\\\\\\ \\\\ 一般情况\\\\\\ \\\\ P(\\bigcup_{i=1}^n A_i)=\\sum_{i=1}^nP(A_i)-\\underset{1\\leq i\\lt j\\leq n}\\sum P(A_iA_j)+\u0026hellip;+(-1)^{n-1}P(A_1 A_2\u0026hellip; A_n) $$\n等可能概型(古典概型) 定义 满足 S中样本点有限,出现每一样本点的概率相同的试验被称为等可能概型\n等可能性 有限性 组合数 $$ A_n^m = \\frac{n!}{(n-k)!} $$\n选择数 定义 $$ C_m^n = \\tbinom{m}{n} =\\frac{n!}{m!(n-m)!} $$\n二项式系数 $$ (x + y)^n = \\sum_{k=1}^n \\tbinom{n}{k} x^ky^{n-k} $$\n放回抽样总结 有序:$n^k$\n无序:$C_{n+k-1}^k$\n多项式系数 含义 从$n$个数中选$k$组，每一组的个数分别为$n_1,\u0026hellip;,n_k$\n公式 $$ \\tbinom{n}{n_1,n_2,\u0026hellip;,n_k} = \\frac{n!}{n_1!\u0026hellip;n_k!} \\\\\\ \\\\ 其中: \\sum_{i=0}^k n_i = n $$\n条件概率 定义 $$ P(B|A)=\\frac{P(AB)}{P(A)} = \\frac{N(AB)}{N(A)},P(A)\\neq 0 $$\n性质 $$ P(B|A)具有概率所具有的性质\\\\\\ \\\\ 乘法公式\\\\\\ \\\\ P(AB) = P(A)\\cdot P(B|A)=P(B)\\cdot P(A|B)\\\\\\ \\\\ P(ABC) = P(A)P(B|A)P(C|AB)\\\\\\ \\\\ P(A_1 A_2 \u0026hellip;A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\u0026hellip;P(A_n|A_1A_2 \u0026hellip; A_{n-1}) $$\n全概率公式与Bayes公式 划分 不漏: $B_1\\bigcup B_2\u0026hellip;\\bigcup B_n= S$ 不重: $B_i B_j= \\phi,i\\neq j$ 则称$B_1,B_2\u0026hellip;B_n$为S的一个划分\n全概率公式 $$ P(A)=\\sum_{i=1}^nP(B_j)\\cdot P(A|B_j) $$\nBayes公式 定义式 $$ P(B_i|A)=\\frac{P(B_i)P(A|B_i)}{\\sum_{j=1}^nP(B_j)\\cdot P(A|B_j)}=\\frac{P(AB_i)}{P(A)} $$\n条件概率形式 $$ P(B_i|A\\bigcap C) = \\frac{P(B_i|C)\\cdot P(A|B_i\\bigcap C)}{\\sum_{j=1}^n P(B_j|C)\\cdot P(A|B_j\\bigcap C)} $$\nPrior Probability 和 Posterior Probability 事件独立性与独立试验 两两独立 定义 若$P(AB)=P(A)P(B)$，则A与B相互独立\n性质 性质1 $$ 对于独立事件A,B\\\\\\ \\\\ P(A|B)=P(A),P(B|A)=P(B) $$\n性质2 如果$A$和$B$相互独立，那么 $A$和$B^c$;$A^c$和$B^c$ 也相互独立\n相互独立 定义 $$ 若P(A_1A_2\u0026hellip;A_n) = P(A_1)P(A_2)\u0026hellip;P(A_n) \\\\\\ \\\\ 那么称A_1,A_2,\u0026hellip;,A_n相互独立 $$\n数量 $$ 若以上事件两两独立，则有C_n^2+C_n^3 + \u0026hellip;+C_n^n \\\\\\ \\\\ = (2^n -n - 1)个算式得到满足 $$\n不相容 $\\neq$ 独立 条件独立 定义 $$ 当P(A_1A_2\u0026hellip;A_n|B) = P(A_1|B)P(A_2|B)\u0026hellip;P(A_n|B)时 \\\\\\ \\\\ 事件A_1,A_2,\u0026hellip;,A_n对于B条件独立 $$\n定理 $$ 若P(C|B) \\ge 0 \\\\\\ \\\\ 则当P(A|C\\bigcap B) = P(A|B)时 \\\\\\ \\\\ A与C关于B条件独立 $$\n注意 两两独立不等于相互独立 实际问题可以根据事情情况检验独立性 在大量重复实验中，小概率事件必然发生 ","date":"2022-11-28T05:08:00+08:00","permalink":"https://downeyflyfan.com/p/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"基本概念"},{"content":"[toc]\n一、基尔霍夫定理 1.1 基尔霍夫电流定律 定义 在电路中，任何节点上的所有电流的代数和为0\n其中，基尔霍夫电流方程被称为KCL方程 1.2 基尔霍夫电压定律 定义 在电路中，环绕任何闭合路径的电压为0\n1.3 应用 1.3.1 含源受控电路的分析 二、常见的特殊电路 2.1 惠斯通电桥 图示 推导 $$ 当电路平衡，即i_g = 0时，有以下推导:\\\\\\ \\\\ KCL\\begin{cases}i_1=i_3 \\\\ i_2=i_x\\end{cases} \\\\\\ \\\\ KVL\\begin{cases} i_1R_1=i_2R_2\\\\ i_3R_3=i_xR_x\\end{cases}\\\\\\ \\\\ \\Rightarrow R_1R_x=R_2R_3\\Leftrightarrow R_x=\\frac{R_2}{R_1}R_3 $$\n2.2 $\\Delta - Y(\\pi-T)$等效电路 $\\Delta$与$\\pi$结构的转换 $Y$和$T$的转换 $\\Delta-Y$变换\n图示 公式\n$$ 通过串并联的简单计算可以得到\\\\\\ \\\\ R_1=\\frac{R_bR_c}{R_a+R_b+R_C} \\\\\\ \\\\ R_2=\\frac{R_aR_c}{R_a+R_b+R_C} \\\\\\ \\\\ R_3=\\frac{R_aR_b}{R_a+R_b+R_C} \\\\\\ \\\\ 反过来\\\\\\ \\\\ R_a=\\frac{R_1R_2+R_2R_3+R_1R_3}{R_1}\\\\\\ \\\\ R_b=\\frac{R_1R_2+R_2R_3+R_1R_3}{R_2} \\\\\\ \\\\ R_c=\\frac{R_1R_2+R_2R_3+R_1R_3}{R_3} $$\n三、补充 3.1 电流 电压 功率 功 电流 单位时间、单位面积内穿过的电荷数 $$ i(t) = \\frac{dq}{dt} $$\n电压 移动一个电荷所需要的功 $$ v(t)= \\frac{dw}{dq} $$\n功率 $$ vi = \\frac{dw}{dt} = p $$\n功 $$ w = \\int p dt = \\int vi dt $$\n3.2 独立源 非独立源 分类 按流动频率分 AC DC 按独立性分 独立源 电压控制的电流源(VCCS) 电流控制的电压源(CCVS) 电压控制的电压源(VCVS) 电流控制的电流源(CCCS) 电流源相当于开路，电压源相当于短路\n电阻 电容 电感 都属于被动元件(Passive Component)\n一定要注意单位\n3.3 电阻和电导 电阻 $$ R = \\frac{U}{I} = \\frac{\\rho L}{S} $$\n","date":"2022-11-27T06:07:17+08:00","permalink":"https://downeyflyfan.com/p/%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6%E4%B8%8E%E7%AE%80%E5%8D%95%E7%94%B5%E9%98%BB%E7%94%B5%E8%B7%AF/","title":"电阻元件与简单电阻电路"},{"content":"一、RMS (Python) 1. 执行步骤 I/O交互: 输入执行实际时间和任务周期 根据优先级对任务分类 找到周期的最小公约数lcm 分别记录一个lcm内每个任务的 总执行时间 开始执行时间(到达时间) 将每个任根据优先级放在时间表中 输入执行实际时间和任务周期 2. 说明 lcm和hyperperiod在此代码中均指所有任务周期的最小公约数 代码 以下代码来自https://github.com/rragesh/RateMonotonic_Scheduler\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #!/usr/bin/env python3 # ------------------------------------------ # RM_scheduling.py: Rate Monotonic Scheduler # Author: Ragesh RAMACHANDRAN # ------------------------------------------ import json import copy from sys import * from math import gcd from collections import OrderedDict import matplotlib.pyplot as plt import numpy as np import statistics as st from collections import defaultdict tasks = dict() RealTime_task = dict() metrics = defaultdict(dict) d = dict() dList = [] T = [] C = [] U = [] # For gantt chart y_axis = [] from_x = [] to_x = [] def Read_data(): \u0026#34;\u0026#34;\u0026#34; Reading the details of the tasks to be scheduled from the user as Number of tasks n: Period of task P: Worst case excecution time WCET: \u0026#34;\u0026#34;\u0026#34; global n global hp global tasks global dList dList = {} n = int(input(\u0026#34;\\n \\t\\tEnter number of Tasks:\u0026#34;)) # Storing data in a dictionary for i in range(n): dList[\u0026#34;TASK_%d\u0026#34;%i] = {\u0026#34;start\u0026#34;:[],\u0026#34;finish\u0026#34;:[]} dList[\u0026#34;TASK_IDLE\u0026#34;] = {\u0026#34;start\u0026#34;:[],\u0026#34;finish\u0026#34;:[]} for i in range(n): tasks[i] = {} print(\u0026#34;\\n\\n\\n Enter Period of task T\u0026#34;,i,\u0026#34;:\u0026#34;) p = input() tasks[i][\u0026#34;Period\u0026#34;] = int(p) print(\u0026#34;Enter the WCET of task C\u0026#34;,i,\u0026#34;:\u0026#34;) w = input() tasks[i][\u0026#34;WCET\u0026#34;] = int(w) # Writing the dictionary into a JSON file with open(\u0026#39;tasks.json\u0026#39;,\u0026#39;w\u0026#39;) as outfile: json.dump(tasks,outfile,indent = 4) def Hyperperiod(): \u0026#34;\u0026#34;\u0026#34; Calculates the hyper period of the tasks to be scheduled \u0026#34;\u0026#34;\u0026#34; temp = [] for i in range(n): temp.append(tasks[i][\u0026#34;Period\u0026#34;]) HP = temp[0] for i in temp[1:]: HP = HP*i//gcd(HP, i) print (\u0026#34;\\n Hyperperiod:\u0026#34;,HP) return HP def Schedulablity(): \u0026#34;\u0026#34;\u0026#34; Calculates the utilization factor of the tasks to be scheduled and then checks for the schedulablity and then returns true is schedulable else false. \u0026#34;\u0026#34;\u0026#34; for i in range(n): T.append(int(tasks[i][\u0026#34;Period\u0026#34;])) C.append(int(tasks[i][\u0026#34;WCET\u0026#34;])) u = int(C[i])/int(T[i]) U.append(u) U_factor = sum(U) if U_factor\u0026lt;=1: print(\u0026#34;\\nUtilization factor: \u0026#34;,U_factor, \u0026#34;underloaded tasks\u0026#34;) sched_util = n*(2**(1/n)-1) print(\u0026#34;Checking condition: \u0026#34;,sched_util) count = 0 T.sort() for i in range(len(T)): if T[i]%T[0] == 0: count = count + 1 # Checking the schedulablity condition if U_factor \u0026lt;= sched_util or count == len(T): print(\u0026#34;\\n\\tTasks are schedulable by Rate Monotonic Scheduling!\u0026#34;) return True else: print(\u0026#34;\\n\\tTasks are not schedulable by Rate Monotonic Scheduling!\u0026#34;) return False print(\u0026#34;\\n\\tOverloaded tasks!\u0026#34;) print(\u0026#34;\\n\\tUtilization factor \u0026gt; 1\u0026#34;) return False def estimatePriority(RealTime_task): \u0026#34;\u0026#34;\u0026#34; Estimates the priority of tasks at each real time period during scheduling \u0026#34;\u0026#34;\u0026#34; tempPeriod = hp P = -1 #Returns -1 for idle tasks for i in RealTime_task.keys(): if (RealTime_task[i][\u0026#34;WCET\u0026#34;] != 0): if (tempPeriod \u0026gt; RealTime_task[i][\u0026#34;Period\u0026#34;] or tempPeriod \u0026gt; tasks[i][\u0026#34;Period\u0026#34;]): tempPeriod = tasks[i][\u0026#34;Period\u0026#34;] #Checks the priority of each task based on period P = i return P def Simulation(hp): \u0026#34;\u0026#34;\u0026#34; The real time schedulng based on Rate Monotonic scheduling is simulated here. \u0026#34;\u0026#34;\u0026#34; # Real time scheduling are carried out in RealTime_task global RealTime_task RealTime_task = copy.deepcopy(tasks) # validation of schedulablity neessary condition for i in RealTime_task.keys(): RealTime_task[i][\u0026#34;DCT\u0026#34;] = RealTime_task[i][\u0026#34;WCET\u0026#34;] if (RealTime_task[i][\u0026#34;WCET\u0026#34;] \u0026gt; RealTime_task[i][\u0026#34;Period\u0026#34;]): print(\u0026#34; \\n\\t The task can not be completed in the specified time ! \u0026#34;, i ) # main loop for simulator for t in range(hp): # Determine the priority of the given tasks priority = estimatePriority(RealTime_task) if (priority != -1): #processor is not idle print(\u0026#34;\\nt{}--\u0026gt;t{} :TASK{}\u0026#34;.format(t,t+1,priority)) # Update WCET after each clock cycle RealTime_task[priority][\u0026#34;WCET\u0026#34;] -= 1 # For the calculation of the metrics dList[\u0026#34;TASK_%d\u0026#34;%priority][\u0026#34;start\u0026#34;].append(t) dList[\u0026#34;TASK_%d\u0026#34;%priority][\u0026#34;finish\u0026#34;].append(t+1) # For plotting the results y_axis.append(\u0026#34;TASK%d\u0026#34;%priority) from_x.append(t) to_x.append(t+1) else: #processor is idle print(\u0026#34;\\nt{}--\u0026gt;t{} :IDLE\u0026#34;.format(t,t+1)) # For the calculation of the metrics dList[\u0026#34;TASK_IDLE\u0026#34;][\u0026#34;start\u0026#34;].append(t) dList[\u0026#34;TASK_IDLE\u0026#34;][\u0026#34;finish\u0026#34;].append(t+1) # For plotting the results y_axis.append(\u0026#34;IDLE\u0026#34;) from_x.append(t) to_x.append(t+1) # Update Period after each clock cycle for i in RealTime_task.keys(): RealTime_task[i][\u0026#34;Period\u0026#34;] -= 1 if (RealTime_task[i][\u0026#34;Period\u0026#34;] == 0): RealTime_task[i] = copy.deepcopy(tasks[i]) with open(\u0026#39;RM_sched.json\u0026#39;,\u0026#39;w\u0026#39;) as outfile2: json.dump(dList,outfile2,indent = 4) def drawGantt(): \u0026#34;\u0026#34;\u0026#34; The scheduled results are displayed in the form of a gantt chart for the user to get better understanding \u0026#34;\u0026#34;\u0026#34; colors = [\u0026#39;red\u0026#39;,\u0026#39;green\u0026#39;,\u0026#39;blue\u0026#39;,\u0026#39;orange\u0026#39;,\u0026#39;yellow\u0026#39;] fig = plt.figure() ax = fig.add_subplot(111) # the data is plotted from_x to to_x along y_axis ax = plt.hlines(y_axis, from_x, to_x, linewidth=20, color = colors[n-1]) plt.title(\u0026#39;Rate Monotonic scheduling\u0026#39;) plt.grid(True) plt.xlabel(\u0026#34;Real-Time clock\u0026#34;) plt.ylabel(\u0026#34;HIGH------------------Priority---------------------\u0026gt;LOW\u0026#34;) plt.xticks(np.arange(min(from_x), max(to_x)+1, 1.0)) plt.show() def showMetrics(): \u0026#34;\u0026#34;\u0026#34; Displays the resultant metrics after scheduling such as average response time, the average waiting time and the time of first deadline miss \u0026#34;\u0026#34;\u0026#34; N = [] startTime = [] releaseTime = [] finishTime = [] avg_respTime = [] avg_waitTime = [] # Calculation of number of releases and release time for i in tasks.keys(): release =int(hp)/int(tasks[i][\u0026#34;Period\u0026#34;]) N.append(release) temp = [] for j in range(int(N[i])): temp.append(j*int(tasks[i][\u0026#34;Period\u0026#34;])) # temp.append(hp) releaseTime.append(temp)\t# Calculation of start time of each task for j,i in enumerate(tasks.keys()): start_array,end_array = filter_out(dList[\u0026#34;TASK_%d\u0026#34;%i][\u0026#34;start\u0026#34;],dList[\u0026#34;TASK_%d\u0026#34;%i][\u0026#34;finish\u0026#34;],N[j]) startTime.append(start_array) finishTime.append(end_array) # Calculation of average waiting time and average response time of tasks for i in tasks.keys(): avg_waitTime.append(st.mean([a_i - b_i for a_i, b_i in zip(startTime[i],releaseTime[i])])) avg_respTime.append(st.mean([a_i - b_i for a_i, b_i in zip(finishTime[i],releaseTime[i])])) # Printing the resultant metrics for i in tasks.keys(): metrics[i][\u0026#34;Releases\u0026#34;] = N[i] metrics[i][\u0026#34;Period\u0026#34;] = tasks[i][\u0026#34;Period\u0026#34;] metrics[i][\u0026#34;WCET\u0026#34;] = tasks[i][\u0026#34;WCET\u0026#34;] metrics[i][\u0026#34;AvgRespTime\u0026#34;] = avg_respTime[i] metrics[i][\u0026#34;AvgWaitTime\u0026#34;] = avg_waitTime[i] print(\u0026#34;\\n Number of releases of task %d =\u0026#34;%i,int(N[i])) print(\u0026#34;\\n Release time of task%d = \u0026#34;%i,releaseTime[i]) print(\u0026#34;\\n start time of task %d = \u0026#34;%i,startTime[i]) print(\u0026#34;\\n finish time of task %d = \u0026#34;%i,finishTime[i]) print(\u0026#34;\\n Average Response time of task %d = \u0026#34;%i,avg_respTime[i]) print(\u0026#34;\\n Average Waiting time of task %d = \u0026#34;%i,avg_waitTime[i]) print(\u0026#34;\\n\u0026#34;) # Storing results into a JSON file with open(\u0026#39;Metrics.json\u0026#39;,\u0026#39;w\u0026#39;) as f: json.dump(metrics,f,indent = 4) print(\u0026#34;\\n\\n\\t\\tScheduling of %d tasks completed succesfully....\u0026#34;%n) def filter_out(start_array,finish_array,release_time): \u0026#34;\u0026#34;\u0026#34;A filtering function created to create the required data struture from the simulation results\u0026#34;\u0026#34;\u0026#34; new_start = [] new_finish = [] beg_time = min(start_array) diff = int(hp/release_time) # Calculation of finish time and start time from simulation results if(release_time\u0026gt;1): new_start.append(beg_time) prev = beg_time for i in range(int(release_time-1)): beg_time = beg_time + diff new_start.append(beg_time) count = start_array.index(prev) for i in range(start_array.index(prev),start_array.index(beg_time)-1): count+=1 new_finish.append(finish_array[count]) prev = beg_time new_finish.append(max(finish_array)) else: end_time = max(finish_array) new_start.append(beg_time) new_finish.append(int(end_time)) return new_start,new_finish if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;\\n\\n\\t\\t_RATE MONOTONIC SCHEDULER_\\n\u0026#34;) Read_data() sched_res = Schedulablity() if sched_res == True: hp = Hyperperiod() Simulation(hp) showMetrics() drawGantt() else: Read_data() sched_res = Schedulablity() 二、EDF Code in C 1. 思路 先算出所有周期的最小公约数T 先选择截止时间最早的任务A作为当前处理任务 判断A是否在当前周期T内: 若不在，就根据截止时间选择其他任务 若其他任务都无法在当前周期T的剩余时间内完成（即，截止时间$\\lt$周期内的剩余时间 ）,则选择截止时间最短的运行到周期结束 注意，由于该模型中的任务不可再分割，不可抢占，所以我们应对传统EDF模型进行更改，使得在该情况下,不继续执行任务\n在下一个周期开始后，循环上述 2、3步骤 2. 说明 该思路中的优先级以截止时间衡量 3. 代码 更多代码和库请见 https://github.com/elzoughby/EDF-scheduling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include \u0026#34;heapSort.c\u0026#34; void arrayPrint(int*, int); int lcm(int* ar, int m); void arrayPrint(int* arr, int n) { for(int i=0; i\u0026lt;n; i++) { printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); } int lcm(int* ar, int m)\t{ int res = ar[0]; int a,b; for(int i=1; i\u0026lt;m; i++) { if(res\u0026gt;ar[i]) { b= res; a= ar[i]; } else { b = ar[i]; a = res; } int r=1; while(r\u0026gt;0) { r = b%a; b = a; a = r; } res = (ar[i]*res)/b; } return res; } int main(int argc, char **argv) { int m = 3; int arr[3][4] = {{3,20,7,0},{2,5,4,0},{2,10,9,0}}; int* exec = (int*)(malloc(sizeof(int)*m)); int* period = (int*)(malloc(sizeof(int)*m)); int* deadline = (int*)(malloc(sizeof(int)*m)); int* arrival = (int*)(malloc(sizeof(int)*m)); int* rdl = (int*)(malloc(sizeof(int)*m)); int* offset = (int*)(malloc(sizeof(int)*m)); int* rexec = (int*)(malloc(sizeof(int)*m)); int* index = (int*)(malloc(sizeof(int)*m)); for(int i=0; i\u0026lt;m; i++)\t{ exec[i] = arr[i][0]; rexec[i] = arr[i][0]; period[i] = arr[i][1]; deadline[i] = arr[i][2]; offset[i] = arr[i][3]; arrival[i] = arr[i][3]; rdl[i] = arr[i][3] + arr[i][2]; } int lcmm = lcm(period,m); int* heapdead = (int*)(malloc(sizeof(int)*lcmm*m)); int* heapindex = (int*)(malloc(sizeof(int)*lcmm*m)); int** e = (int**)(malloc(sizeof(int)*m)); int** plote = (int**)(malloc(sizeof(int)*m)); for(int i=0; i\u0026lt;m; i++)\t{ e[i] = (int*)(malloc(sizeof(int)*lcmm)); plote[i] = (int*)(malloc(sizeof(int)*lcmm*100)); } int value; int indexterm; int heapsize = 0; for(int i=0; i\u0026lt;lcmm; i++) {\tfor(int j=0; j\u0026lt;m; j++)\t{ e[j][i] = 0; for(int k=0; k\u0026lt;100; k++) plote[j][i*100+k] = 0; if(arrival[j] == i)\t{ rdl[j] = deadline[j] + i; minHeapPush(heapdead, heapindex, \u0026amp;heapsize, rdl[j], j ); arrival[j] += period[j]; rexec[j] = exec[j]; } } if(heapsize \u0026gt; 0)\t{\tminHeapPop(heapdead,heapindex,\u0026amp;value,\u0026amp;indexterm,\u0026amp;heapsize); printf(\u0026#34;%d \u0026#34;,indexterm+1); e[indexterm][i] = 1; for(int k=0; k\u0026lt;100; k++) plote[indexterm][i*100+k] = 1; if(value\u0026gt;i) { rexec[indexterm]--; if(rexec[indexterm]\u0026gt;0)\t{ minHeapPush(heapdead, heapindex, \u0026amp;heapsize, value, indexterm ); } } } else { printf(\u0026#34;0 \u0026#34;); } } printf(\u0026#34;\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ arrayPrint(e[i],lcmm); } FILE *filePtr; filePtr = fopen(\u0026#34;polar.dat\u0026#34;,\u0026#34;w\u0026#34;); for(int i=0; i\u0026lt;lcmm*100; i++) { //fprintf(filePtr, \u0026#34;%d\\t\u0026#34;, j); //for(int i=0; i\u0026lt;3; i++)\t{\tfprintf(filePtr, \u0026#34;%d\\t%d\\t%d\\t%d\\n\u0026#34;,i, plote[0][i], plote[1][i], plote[2][i]); //} //fprintf(filePtr, \u0026#34;\\n\u0026#34;); } /* for(int i=0; i\u0026lt;m; i++)\t{ for(int j=0; j\u0026lt;lcmm; j++)\t{ printf(\u0026#34;%d\\t\u0026#34;,plote[i][j]); } printf(\u0026#34;\\n\u0026#34;); } */ return 0;\t} /*minHeapBuild(deadline,index,m); minHeapPop(deadline,index,\u0026amp;value,\u0026amp;indexterm,\u0026amp;m); printf(\u0026#34;%d %d\\n\u0026#34;,value,indexterm); minHeapPop(deadline,index,\u0026amp;value,\u0026amp;indexterm,\u0026amp;m); printf(\u0026#34;%d %d\\n\u0026#34;,value,indexterm); minHeapPop(deadline,index,\u0026amp;value,\u0026amp;indexterm,\u0026amp;m); printf(\u0026#34;%d %d\\n\u0026#34;,value,indexterm); minHeapPush(deadline, index, \u0026amp;m, 10, 2); minHeapPush(deadline, index, \u0026amp;m, 8, 3); minHeapPush(deadline, index, \u0026amp;m, 7, 9); arrayPrint(deadline,m); arrayPrint(index,m);*/ MLFQ-Scheduler 1. 操作系统调度中的规则 优先级高的先执行 优先级相同的轮转运行 工作进入系统时，将其放在最高优先级 工作用完其时间片后，降低其优先级 经过一段时间S,就降低其优先级 2. 在该模型中 由于该模型不可抢占，我们需要对规则进行改变\npulse width短的任务优先级更高 优先级高的先执 优先级相同的随机选择运行顺序 增加的任务，将其放在最高优先级 规定每个任务拥有相同的时间配额，一旦每个任务的时间配额用完，就降低其优先级 先删除优先级最低的任务 3. 代码 更多代码请见https://github.com/shreyaakamath/Xv6-MLFQ-Scheduler/tree/master/xv6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 // ConsoleApplication1.cpp : Defines the entry point for the console application. // // data_structs_3.cpp : Defines the entry point for the console application. //COPY FOR EXPERIMENTATION #include \u0026#34;stdafx.h\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; //Data initialization struct process_data { int wait; int pxs; int arrive; int jind; int resp; int TT; int queue; bool IO; int a, b, c, d, e, f, g, h, i, j, k, l, m, n, O, p, q; int datas[17] = { a,b,c,d,e,f,g,h,i,j,k,l,m,n, O,p,q }; }; struct slinklist { process_data data; struct slinklist * next; }; typedef struct slinklist node; node * start = NULL; node *getnode(int px[], int pxs)//Creates newnode with predetermined input { node *newnode; newnode = (node*)malloc(sizeof(node)); newnode-\u0026gt;data.wait = 0; newnode-\u0026gt;data.arrive = 0; newnode-\u0026gt;data.jind = 0; newnode-\u0026gt;data.resp = 0; newnode-\u0026gt;data.TT = 0; newnode-\u0026gt;data.pxs = pxs; newnode-\u0026gt;data.queue = 1; newnode-\u0026gt;data.IO = false; for (int j = 0; j \u0026lt; 17; j++) newnode-\u0026gt;data.datas[j] = 0; for (int j = 0; j \u0026lt; pxs; j++) newnode-\u0026gt;data.datas[j] = px[j]; newnode-\u0026gt;next = NULL; return newnode; } void create_s_list(int n, int P0[8], int p1[13], int p2[17], int p3[17], int p4[15], int p5[17], int p6[17], int p7[15], int p8[17], int p1s, int p2s, int p3s, int p4s, int p5s, int p6s, int p7s, int p8s)//Creates n number of nodes for a Single Linked List { int i; node *newnode; node *temp; int *P1[] = { p1, p2, p3, p4, p5, p6, p7, p8 };//array of arrays int P2[] = { p1s,p2s,p3s,p4s,p5s,p6s,p7s,p8s };//size of arrays for (i = 0; i \u0026lt; n; i++) { newnode = getnode(P1[i], P2[i]); if (start == NULL) { start = newnode; } else { temp = start; while (temp-\u0026gt;next != NULL) temp = temp-\u0026gt;next; temp-\u0026gt;next = newnode; } } } //Performs Round Robin Scheduling with TQ = 6; Displays Context Switch Info void queue1_Sch(int \u0026amp;time) { node *temp; int minarrive;//arrival time of soonest queue 1 process int minIndex = 0;//index of soonest queue 1 process bool Onearrived;//indicates if a queue 1 process has arrived while (true) { temp = start; Onearrived = false; minarrive = INT_MAX; for (int i = 0; i \u0026lt; 8; i++)//gets index of Queue 1 process with soonest arrival time { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.queue ==1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive\u0026lt;=time) { minarrive = temp-\u0026gt;data.arrive; minIndex = i; Onearrived = true; } temp = temp-\u0026gt;next; } if (Onearrived == false)//if no queue 1 process has arrived break; int ctr = 1;//make temp point to process in execution temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } //Context Switch Information Displayed cout \u0026lt;\u0026lt; endl\u0026lt;\u0026lt; \u0026#34;Current Execution Time: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Process on CPU: P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;Ready Queue:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.IO == false)//if process is not in either IO or CPU execution { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Burst time:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } cout \u0026lt;\u0026lt; \u0026#34;Processes in I/O:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1)//If process is in IO and not in execution... { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; I/O time Remaining:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex)//Select Process in execution again-\u0026gt;index of node with lowest arrival time { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind == 0)//Response Time, jind gets either incremented from one pass in the loop, or process gets demoted to lower queue { temp-\u0026gt;data.resp = time; } temp-\u0026gt;data.wait += (time - temp-\u0026gt;data.arrive);//total waiting time is waiting time + (time(it just got on the cpu) minus the arrival time of process if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026gt; 6)//if burst is greater than 6 { time += 6;// incrementing time the length of TQ temp-\u0026gt;data.arrive = time; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= 6; temp-\u0026gt;data.queue = 2; temp-\u0026gt;data.IO = false;//process in not in IO in this case } else if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;= 6) { time += temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]; temp-\u0026gt;data.arrive = time + temp-\u0026gt;data.datas[temp-\u0026gt;data.jind + 1]; temp-\u0026gt;data.jind = temp-\u0026gt;data.jind + 2; temp-\u0026gt;data.IO = true;//Process in IO after finishing burst } ctr = 1;//deincrements IO times of processes currently in IO temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] -= 6; if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] \u0026lt;= 0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind \u0026gt; (temp-\u0026gt;data.pxs - 1))//if jind surpasses data, process is done { temp-\u0026gt;data.IO = false; temp-\u0026gt;data.arrive = -1; temp-\u0026gt;data.TT = time; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34; Process \u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Completed\u0026#34; \u0026lt;\u0026lt; endl; } } } //Performs Round Robin Scheduling TQ = 12 with preemption; Displays Context Switch Info void queue2_Sch(int \u0026amp;time) { node *temp; int minarrive; int minQ1arr = INT_MAX; //arrival time of soonest Q1 process int minIndex = 0; bool Twoarrived;//indicates if queue 2 process is in the ready queue int timecalc;//preserves time of execution temp = start; for (int i = 0; i \u0026lt; 8; i++)//Find arrival time of soonest Q1 process { if (temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.queue == 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt; minQ1arr) minQ1arr = temp-\u0026gt;data.arrive; temp = temp-\u0026gt;next; } while (true) { temp = start; Twoarrived = false; minarrive = INT_MAX; timecalc = time; temp = start; for (int i = 0; i \u0026lt; 8; i++)//gets index of Queue 2 process with soonest arrival time { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.queue == 2 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive\u0026lt;=time) { Twoarrived = true; minarrive = temp-\u0026gt;data.arrive; minIndex = i;//index of process with soonest arrival time } temp = temp-\u0026gt;next; } if (Twoarrived == false) return; int ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } //Context Switch Information Displayed cout \u0026lt;\u0026lt; endl\u0026lt;\u0026lt; \u0026#34;Current Execution Time: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Process on CPU: P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Ready Queue:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.IO == false) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Burst time:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } cout \u0026lt;\u0026lt; \u0026#34;Processes in I/O:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; I/O time Remaining:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } temp-\u0026gt;data.wait += (time - temp-\u0026gt;data.arrive);//total waiting time is waiting time + (time(it just got on the cpu) minus the arrival time of process if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026gt; 12)//if burst is greater than 12 { for (int i = 0; i \u0026lt; 12; i++) { time++; if (time \u0026gt;= minQ1arr)//if a Q1 process arrives break; } temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= (time - timecalc); temp-\u0026gt;data.arrive = time; if((time-timecalc)\u0026gt;=12) temp-\u0026gt;data.queue = 3; temp-\u0026gt;data.IO = false; } else if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;= 12)// If burst is less than the time quantum { for (int i = 0; i \u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]; i++) { time++; if (time \u0026gt;= minQ1arr)//if a Q1 process arrives break; } if ((time - timecalc) \u0026gt;= temp-\u0026gt;data.datas[temp-\u0026gt;data.jind])//if the burst was finished { temp-\u0026gt;data.arrive = time + temp-\u0026gt;data.datas[temp-\u0026gt;data.jind + 1]; temp-\u0026gt;data.jind = temp-\u0026gt;data.jind + 2; temp-\u0026gt;data.IO = true; } else //if the burst hasn\u0026#39;t finished { temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= (time - timecalc); temp-\u0026gt;data.arrive = time; temp-\u0026gt;data.IO = false; } } ctr = 1;//deincrement IO times of process in IO temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] -= (time - timecalc); if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1]\u0026lt;=0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind \u0026gt; (temp-\u0026gt;data.pxs - 1))//if jind surpasses data, process is done { temp-\u0026gt;data.IO = false; temp-\u0026gt;data.arrive = -1; temp-\u0026gt;data.TT = time; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34; Process \u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Completed\u0026#34; \u0026lt;\u0026lt; endl; } if (minQ1arr \u0026lt;= time)//If queue 1 process has arrived return to wait_tt function return; } } //Performs First Come First Serve Scheduling with preemption; Displays Context Switch Info void FCFS_Sch(int \u0026amp;time) { node *temp; int timecalc;//preserves time of execution int minarrive;//soonest arrival time int minIndex;//index of process with soonest arrival time int minQ12arr= INT_MAX;//soonest arrival time of higher priority process bool AnyArrived;//indicates if any process is in the ready queue temp = start; for (int i = 0; i \u0026lt; 8; i++)//Find arrival time of soonest Q1/2 process { if (temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt; minQ12arr \u0026amp;\u0026amp; temp-\u0026gt;data.queue !=3) minQ12arr = temp-\u0026gt;data.arrive; temp = temp-\u0026gt;next; } while (true) { timecalc = time; AnyArrived = false; minarrive = INT_MAX; temp = start; for (int i = 0; i \u0026lt; 8; i++) { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive\u0026lt;=time) { AnyArrived = true; minarrive = temp-\u0026gt;data.arrive; minIndex = i;//index of process with soonest arrival time } temp = temp-\u0026gt;next; } if (AnyArrived == false)//if no process in ready queue, return to wait_tt function return; int ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } //Context Switch Information Displayed cout \u0026lt;\u0026lt; endl\u0026lt;\u0026lt;\u0026#34;Current Execution Time: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Process on CPU: P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Ready Queue:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.IO ==false) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Burst time:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } cout \u0026lt;\u0026lt; \u0026#34;Processes in I/O:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; I/O time Remaining:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } temp-\u0026gt;data.wait = temp-\u0026gt;data.wait + (time - temp-\u0026gt;data.arrive);//total waiting time is waiting time + (time(it just got on the cpu) minus the arrival time of process for (int i = 0; i \u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]; i++) { time++; if (time \u0026gt;= minQ12arr)//if a Q1 or Q2 process arrives break; } if ((time - timecalc) \u0026gt;= temp-\u0026gt;data.datas[temp-\u0026gt;data.jind])//if CPU burst is not interrupted { temp-\u0026gt;data.arrive = time + temp-\u0026gt;data.datas[temp-\u0026gt;data.jind + 1];//new arrival time is newtime + IO temp-\u0026gt;data.jind = temp-\u0026gt;data.jind + 2; temp-\u0026gt;data.IO = true; } else//CPU burst is interrupted, deincrement process burst time { temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= (time - timecalc); temp-\u0026gt;data.arrive = time; temp-\u0026gt;data.IO = false; } ctr = 1;//deincrement IO times of processes in IO temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] -= (time - timecalc); if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] \u0026lt;= 0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind \u0026gt; (temp-\u0026gt;data.pxs - 1))//Indicate if process is finished { temp-\u0026gt;data.IO = false; temp-\u0026gt;data.arrive = -1; temp-\u0026gt;data.TT = time; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34; Process \u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Completed\u0026#34; \u0026lt;\u0026lt; endl; } if (time \u0026gt;= minQ12arr)//if higher priority process arrives return to wait_tt function return; } } //Calculates the overall waiting time and turnaround time for each process, also shows when CPU is idle and for how long void wait_tt(int \u0026amp;time) { node *temp; //int time = 0; int minIndex = 0;//min index is the index of the current process int minarrive;//soonest arrival time int idle = 0;//indicate whether CPU is idle bool one;//indicates if queue 1 process is in ready queue bool two;//indicates if queue 2 process is in ready queue bool ready;//indicates if any process is in ready queue bool anyP;//indicates if any process is not finished while (true) { one = false; two = false; ready = false; anyP = false; temp = start; minarrive = INT_MAX; temp = start; for (int i = 0; i \u0026lt; 8; i++)//See if ready process in Queue 1 { if (temp-\u0026gt;data.queue == 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt;= time) { one = true; break; } temp = temp-\u0026gt;next; } temp = start; for (int i = 0; i \u0026lt; 8; i++)//See if ready process in Queue 2 { if (temp-\u0026gt;data.queue == 2 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt;= time) { two = true; break; } temp = temp-\u0026gt;next; } temp = start; for (int i = 0; i \u0026lt; 8; i++)//See if any process in ready Queue { if (temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt;= time) { ready = true; break; } temp = temp-\u0026gt;next; } temp = start; for (int i = 0; i \u0026lt; 8; i++)//gets arrival time of soonest process, see if any process is not finished { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1) { minarrive = temp-\u0026gt;data.arrive; minIndex = i;//index of process with soonest arrival time anyP = 1; } temp = temp-\u0026gt;next; } int ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (anyP == false)//If all processes are finished return; if (one) queue1_Sch(time); else if (two) queue2_Sch(time); else if (ready) FCFS_Sch(time); else if(ready==false) {//increment time to soonest arrival time, indicate idleness, and deincrement IO times for the length of time spent idle temp-\u0026gt;data.IO = true; idle = minarrive - time; time = minarrive; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;\u0026#34;IDLE for \u0026#34; \u0026lt;\u0026lt; idle \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;endl; temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] -= idle; if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] \u0026lt;= 0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; } } } } //Computes sum of Burst times for a process int SUM(int A[]) { int sum = 0; for (int i = 0; i \u0026lt; 17; i++) { if(i%2 == 0) sum += A[i]; } return sum; } //Computes average response time, waiting time, and turnaround time for each process void AVG(double \u0026amp;r, double \u0026amp;w, double \u0026amp;tt) { node*temp = start; while (temp != NULL) { r += temp-\u0026gt;data.resp; w += temp-\u0026gt;data.wait; tt += temp-\u0026gt;data.TT; temp = temp-\u0026gt;next; } r /= 8; w /= 8; tt /= 8; } //Computes sum of burst times of the set of all processes void total_sum(double\u0026amp; dTS) { node *temp; dTS = 0; temp = start; while (temp != NULL) { dTS += SUM(temp-\u0026gt;data.datas); temp = temp-\u0026gt;next; } } //Computes CPU utilization void CPU_UT(int time, double dTS, double \u0026amp;util) { util = ((dTS / time)*100); } //Prints the overall response time, waiting time, turnaround time for each process as well as their averages. Also prints CPU utilization and the time when all process are finished. void print(double r, double w, double tt,double util, int time) { cout \u0026lt;\u0026lt;endl\u0026lt;\u0026lt; \u0026#34;Resp \u0026#34; \u0026lt;\u0026lt; \u0026#34;wait \u0026#34; \u0026lt;\u0026lt; \u0026#34;TT\u0026#34; \u0026lt;\u0026lt; endl; node*temp = start; while (temp != NULL) { if (temp-\u0026gt;data.resp \u0026gt; 9 \u0026amp;\u0026amp; temp-\u0026gt;data.wait \u0026gt; 99) { cout \u0026lt;\u0026lt; temp-\u0026gt;data.resp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.wait \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.TT \u0026lt;\u0026lt; endl; temp = temp-\u0026gt;next; } else if (temp-\u0026gt;data.resp \u0026gt; 9 \u0026amp;\u0026amp; temp-\u0026gt;data.wait \u0026lt;= 99) { cout \u0026lt;\u0026lt; temp-\u0026gt;data.resp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.wait \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.TT \u0026lt;\u0026lt; endl; temp = temp-\u0026gt;next; } else { cout \u0026lt;\u0026lt; temp-\u0026gt;data.resp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.wait \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.TT \u0026lt;\u0026lt; endl; temp = temp-\u0026gt;next; } } cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; tt \u0026lt;\u0026lt; \u0026#34;\u0026lt;---AVG\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;%CPU: \u0026#34; \u0026lt;\u0026lt; util \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;TimeOfCompletion: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;endl; } int main() { int time = 0; double dTS = 0;//Total Sum of all burst times as type double double util = 0; double avgr = 0, avgw = 0, avgtt = 0; int P0[8] = { 1, 2, 3, 4, 5, 6, 7, 8 }; int p1[13] = { 6, 17, 8, 19, 12, 31, 11, 18, 9, 22, 8, 26, 10 }; int p2[17] = { 19, 38, 11, 24, 15, 21, 12, 27, 12, 34, 11, 34, 9, 29, 9, 31, 7 }; int p3[17] = { 3, 37, 14, 41, 8, 30, 4, 19, 7, 33, 5, 18, 4, 26, 5, 31, 16 }; int p4[15] = { 15, 35, 14, 41, 16, 45, 18, 51, 14, 61, 13, 54, 16, 61, 15 }; int p5[17] = { 9, 24, 7, 21, 15, 31, 6, 26, 7, 31, 3, 18, 6, 21, 6, 33, 3 }; int p6[17] = { 4, 38, 3, 41, 5, 29, 4, 26, 7, 32, 4, 22, 3, 26, 5, 22, 8 }; int p7[15] = { 14, 36, 17, 31, 16, 32, 15, 41, 14, 42, 17, 39, 16, 33, 15 }; int p8[17] = { 5, 14, 4, 33, 6, 31, 4, 31, 6, 27, 5, 21, 4, 19, 6, 11, 6 }; create_s_list(8, P0, p1, p2, p3, p4, p5, p6, p7, p8, 13, 17, 17, 15, 17, 17, 15, 17);//a singly linked list where each node is a process from p1 to p8, each with all burst and IO times total_sum(dTS); wait_tt(time); CPU_UT(time, dTS, util); AVG(avgr, avgw, avgtt); print(avgr, avgw, avgtt, util, time); return 0; } ","date":"2022-11-27T02:14:03+08:00","permalink":"https://downeyflyfan.com/p/%E4%B8%89%E7%A7%8D%E8%B0%83%E5%BA%A6/","title":"三种调度"},{"content":"[toc]\n一、电磁感应定律 1.1 法拉第电磁感应定律 $$ \\xi=-k\\frac{d\\phi}{dt}\\\\\\ \\\\ 当\\phi的单位为Wb,\\xi 的单位为V,k=1\\\\\\ \\\\ 当有多匝线圈时,\\xi=-N\\frac{d\\phi}{dt}\\\\\\ $$\n1.2 楞次定律 闭合回路中感应电流的方向总是使得它所激发的电场阻碍引起感应电流的磁通量的变化\n1.3 电磁阻尼 二、动生电动势和感生电动势 定义 动生电动势 恒磁场内导体运动所产生的电动势 感生电动势 导体不动，磁场变化产生的电动势 动生电动势 图示 推导 $$ \\\\ 自由电子受到的力\\pmb F=-e(\\pmb{v\\times B})\\\\\\ \\\\ 单位正电荷的非静电“力”\\pmb K=\\frac{\\pmb F}{-e}=\\pmb{v\\times B}\\\\\\ \\\\ \\xi = \\int_C^D\\pmb K\\cdot d\\pmb l=\\int_C^D (\\pmb{v\\times B})d\\pmb l\\\\\\ \\\\ \\xi = \\int vBdl\\ $$\n交流发电机原理 图示 推导 $$ \\\\ 设AB长为l,CD长为s\\\\\\ \\\\ \\xi_{AB} = \\xi_{CD} = \\int_A^B(\\pmb{v\\times B})d\\pmb l=vBlcos\\theta\\\\\\ \\\\ \\xi = 2\\xi_{AB} = 2vBlcos\\theta\\\\\\ \\\\ \\theta = \\omega t, v = \\frac{s}{2}\\omega\\\\\\ \\\\ \\pmb{\\xi =\\omega BS cos\\omega t}\\ $$\n感生电动势和涡旋电场 $$ \\\\ \\xi = \\int\\pmb K\\cdot d\\pmb l\\\\\\ \\\\ \\xi = -\\frac{d\\phi}{dt}=-\\frac{d}{dt}\\int \\pmb B\\cdot d\\pmb S = -\\frac{d}{dt}\\int \\pmb A\\cdot d\\pmb l = -\\oint \\frac{\\partial A}{\\partial t}d\\pmb l\\\\\\ \\\\ \\therefore \\pmb K=-\\frac{\\partial \\pmb A}{\\partial t}\\\\\\ \\\\ 麦克斯韦发现,\\pmb K=\\pmb E_旋\\\\\\ \\\\ \\therefore \\pmb E_旋=-\\frac{\\partial \\pmb A}{\\partial t}\\\\\\ \\\\ 又\\because \\pmb E_势 = -\\nabla U\\\\\\ \\\\ \\therefore \\pmb E = \\pmb E_势 + \\pmb E_旋 = -\\nabla U - \\frac{\\partial \\pmb A}{\\partial t}\\ $$\n电子加速器 $$ 设轨道处的磁场为B(R),运动轨道内的平均磁场为\\overline B\\\\\\ \\\\ 有evB(R) = \\frac{mv^2}{R}\\longrightarrow B(R)=\\frac{mv}{eB}\\\\\\ \\\\ \\xi = -\\frac{d\\phi}{dt}=\\int \\pmb E_旋\\cdot d\\pmb l \\\\\\ \\\\ \\therefore \\pmb E_旋 = -\\frac{1}{2\\pi R}\\frac{d\\phi}{dt}\\\\\\ \\\\ 根据牛顿第二定律 \\frac{d(mv)}{dt}=F=-e E_旋 = \\frac{e}{2\\pi R}\\frac{d\\phi}{dt}\\\\\\ \\\\ d(mv) = \\frac{e}{2\\pi R}d\\phi\\\\\\ \\\\ 设v_0=0,\\phi_0=0,有\\\\\\ \\\\ mv = \\frac{e}{2\\pi R}\\phi = \\frac{e}{2\\pi R}\\pi R^2 \\overline B\\longrightarrow \\overline B = \\frac{2mv}{eB}\\\\\\ \\\\ \\therefore B(R) = \\frac{1}{2}\\overline B\\ $$\n三、互感和自感 3.1 互感系数 图示 推导 $$ 易知: \\Phi_{12}=M_{12}I_1,\\Phi_{21}=M_{21}I_2]\\\\\\ \\\\ \\Phi_{12}=\\oint \\pmb A\\cdot d\\pmb l=\\oint\\frac{\\mu_0I_1}{4\\pi}\\oint\\frac{d\\pmb l_1}{r_{12}}d\\pmb l_2\\\\\\ \\\\ \\Phi_{12}=\\frac{\\mu_0I_1}{4\\pi}\\oint\\oint\\frac{d\\pmb l_1\\cdot d\\pmb l_2}{r_{12}}\\\\\\ \\\\ \\therefore M_{12}=\\frac{\\Phi_{12}}{I_1}=\\frac{\\mu_0}{4\\pi}\\oint\\oint\\frac{d\\pmb l_1\\cdot d\\pmb l_2}{r_{12}}\\\\\\ \\\\ 同理：M_{12}=M_{21} $$\n单位 $$ 1H=\\frac{1Wb}{1A}=\\frac{1V\\cdot 1s}{1A}\\\\\\ \\\\ 1mH=10^{-3}H,1\\mu H=10^{-6}H $$\n3.2 自感 定义 电生磁，磁再生电，影响原电动势 推导 $$ 我们知道: \\Phi=LI \\\\\\ \\\\ 根据电磁感应定理: \\xi = -\\frac{d\\Phi}{dt}=-L\\frac{dI}{dt}\\\\\\ \\\\ $$\n其中比例系数L与线圈的大小、几何形状、匝数有关 互感与自感的关系(无漏磁) $$ 根据(1)式：M=\\frac{N_1\\Phi_{21}}{I_2}=\\frac{N_2\\Phi_{12}}{I_1}\\\\\\ \\\\ 又\\because L_1=\\frac{N_1\\Phi_1}{I_1},L_2=\\frac{N_2\\Phi_2}{I_2}\\\\\\ \\\\ \\therefore M^2=L_1L_2\\longrightarrow \\pmb{M=\\sqrt{L_1L_2}}\\\\\\ \\\\ 在有漏磁的情况下，M\\lt \\sqrt{L_1L_2} $$\n3.3 两个线圈串联的自感系数 顺接与反接 产生的磁场方向相同为顺接，相反为反接 推导 $$ 顺接时\\\\\\ \\\\ \\xi_1+\\xi_{21}=-L_1\\frac{dI}{dt}-M\\frac{dI}{dt}\\\\\\ \\\\ \\xi_2+\\xi_{12}=-L_2\\frac{dI}{dt}-M\\frac{dI}{dt}\\\\\\ \\\\ 总电动势\\xi=-(L_1+L_2+2M)\\frac{dI}{dt}\\\\\\ \\\\ \\therefore 总自感\\pmb{L = L_1+L_2+2M}\\\\\\ \\\\ 反接时 \\\\\\ \\\\ \\pmb{L = L_1+L_2-2M} $$\n3.4 自感磁能与互感磁能 自感磁能 $$ 对于一个线圈来说,在电压增大过程中抵抗其自感电动势所做的功为\\\\\\ \\\\ dW = -\\xi_i i dt\\\\\\ \\\\ 其中 \\xi_i=-L\\frac{dI}{dt}\\\\\\ \\\\ \\therefore dW = Lidi\\\\\\ \\\\ \\pmb{W=\\int dW=\\int_0^I Lidi=\\frac{1}{2}LI^2},称为自感磁能 $$\n互感磁能 $$ 同理，互感磁能应为\\pmb{W=MI_1I_2}\\\\\\ \\\\ 因此互感线圈 的总磁能为\\\\\\ \\\\ \\pmb{W=\\frac{1}{2}L_1I^2+\\frac{1}{2}L_2I^2+MI_1I_2} $$\n","date":"2022-11-26T18:45:06+08:00","permalink":"https://downeyflyfan.com/p/%E7%94%B5%E7%A3%81%E6%84%9F%E5%BA%94/","title":"电磁感应"},{"content":"[toc]\n一 论文 1.1 论文结构[^1] Abstrat Introduction 引出问题 介绍问题背景 前人的解决方案 前人的局限性 Content\nMethod (Methodology) / Problem Setup\nResults\nDiscussion\nConclusion\nReferences\n引用论文\n代码\n1.2 建议 适当使用自创词 连字符型自创词 首字母大写型自创词 数据来源 使用数学模型创造 官方网站的数据 重要词汇可以加粗或者斜体 二、经验总结与学习方向 2.1 经验总结 认真审题 时间长不要紧，题目一定要看懂 仔细审阅题目的文献 明确分工,提高效率 分工可以有重复 明确接下来的学习方向 学习LaTeX并熟练掌握\n学会画图\n论文结构\n2.2 老师经验 算法要通过伪代码或自然语言描述 ","date":"2022-11-25T17:18:37+08:00","permalink":"https://downeyflyfan.com/p/%E6%95%B0%E6%A8%A1%E8%A6%81%E7%82%B9/","title":"数模要点"},{"content":"[toc]\n一、什么是git 定义\n开源的分布式版本控制系统 特点\n分布式 按元数据方式存储数据 内容完整性高 二、git的工作流程 stateDiagram 资源库 --\u003e 工作副本:clone 工作副本 --\u003e 修改工作副本: 编辑、添加、删除 资源库 --\u003e 修改工作副本: 更新 修改工作副本 --\u003e 检查修改: 查看status, change 检查修改 --\u003e 提交修改: push 提交修改 --\u003e 修改错误: push,change 修改错误 --\u003e 资源库: push 提交修改 --\u003e 资源库: push 三、git创建仓库 创建 git init \u0026lt;repo\u0026gt;创建仓库repo\n生成.git目录\n纳入版本控制 git add \u0026lt;file\u0026gt;让git对文件进行跟踪\n该操作支持正则表达式 git commit -m \u0026lt;file\u0026gt; 提交文件\n复制 git clone \u0026lt;repo\u0026gt; (\u0026lt;dir\u0026gt;)将仓库repo拷贝到dir目录 配置 git config显示当前的git配置信息\ngit config -e针对当前仓库编辑文件\ngit config -e --global针对系统中所有的仓库\n设置全局用户信息\n1 2 git config --global user.name \u0026lt;name\u0026gt; git config --global user.email \u0026lt;email\u0026gt; 四、git基本操作 示意图 stateDiagram workspace --\u003e staging_area: add staging_area --\u003e lcoal_repository: commit lcoal_repository --\u003e remote_repository: push remote_repository --\u003e lcoal_repository: fetch/clone lcoal_repository --\u003e workspace: checkout remote_repository --\u003e workspace: pull 简单的操作步骤 1 2 3 git init # 初始化仓库 git add . # 将文件添加到暂存区 git commit # 将暂存区内容添加到仓库 提交和修改 git add git add [file1] [file2] \u0026hellip; 添加多个文件到暂存区 git add [dir] 添加目录到暂存区 git add . 添加当前目录下所有文件到暂存区 git diff git diff [file] 显示暂存区和工作区的差异 git diff \u0026ndash;cache(staged 也可) [file] 显示暂存区和上一次提交的差异 git diff [first-branch]\u0026hellip;[second branch] 显示两次提交之间的差异 git commit git commit -m [message] 提交暂存区到本地仓库 git commit [file1] [file2] \u0026hellip; -m [message] 提交暂存区的指定文件到本地仓库 git commit -a 不需要git add直接提交 git reset git reset HEAD 回退所有内容到上一个版本 git reset HEAD [file] 回退文件file到上一个版本 git reset \u0026ndash;soft HEAD~n 回退到前n个版本 git reset \u0026ndash;hard HEAD 撤销工作区中所有未提交的修改内容 HEAD^中^的个数表示前几个版本\nHEAD~n可以取代上面的方式\nmessage为备注信息\n其他指令 git status 查看仓库状况，显示有变更的文件 git rm 从暂存区和工作区中删除文件 git mv 移动或重命名工作区文件 提交日志 git log git log \u0026ndash;oneline 查看历史提交记录的简洁形式 git log \u0026ndash;graph 拓朴图形式查看历史提交记录 git blame \u0026lt;file\u0026gt;查看指定文件的修改记录 远程操作 git remote git remote -v 显示所有远程仓库 git remote show [remote] 显示某个远程仓库信息 git remote add [shortname] [url] 添加远程版本库 git remote rm name 删除远程仓库 git remote rename [old_name] [new_name] 修改仓库名 git fetch git fetch [alias]提取更新数据\n执行完后需要git merge branch从远程仓库提取数据并尝试合并到当前分支\ngit pull 1 git pull [远程主机名] [远程分支名]:[本地分支名] 将远程主机的分支拉过来与本地分支合并 若远程分支与当前分支合并，则冒号后可以省略 git push 1 git push [远程主机名] [本地分支名]:[远程分支名] 将本地分支推送到远程主机\n参数\n\u0026ndash;force 强制推送 \u0026ndash;delete 删除主机分支 五、git分支管理 创建分支 git branch \u0026lt;name\u0026gt;创建分支 git branch列出分支 切换分支 git checkout \u0026lt;name\u0026gt; 分支合并 git merge \u0026lt;branch\u0026gt; 将分支branch合并到当前所在分支中 合并冲突 删除分支 git branch -d \u0026lt;name\u0026gt; ","date":"2022-11-25T05:07:46+08:00","permalink":"https://downeyflyfan.com/p/git/","title":"Git"},{"content":"[toc]\n一、算法 定义\n解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列 特性\n有穷性 确定性 可行性 算法效率的度量\n运行时间\n取决于算法的好坏与问题的输入规模（输入量） 算法时间复杂度\n大O记法\n$T(n)=O(f(n))$ T(n)增长最慢的为最优算法 分类与排序 $O(1) \u0026lt; O(log(n))\u0026lt; O(n) \u0026lt; O(nlog(n)) \u0026lt; O(n^2) \u0026lt; O(n^3) \u0026lt; O(n!) \u0026lt; O(n^n)$ 最坏情况与平均情况 一般运行时间为最坏运行时间 平均运行时间是一个期望值 算法空间复杂度\n$S(n)=O(f(n))$ 二、线性表(List) 1.线性表(List)定义 零个或多个数据元素的有限序列 每个元素都有一个直接前驱和直接后继元素 数据元素是一对一的关系 2. 抽象数据类型 Operation IintList(*L); ListEmpty(L); GetElem(L,i,*e); LocateELem(L,e); ListInsert(*L,i,e); ListDelete(*L,i,*e); ListLength(L); endADT 3. 顺序存储结构 定义\n用一段地址连续的存储单元依次存放线性表的数据元素 结构代码\n1 2 3 4 5 6 7 #define MAXSIZE 20 typedef int ElemType typedef struct { ElemType data[MAXSIZE]; //数组存取数据元素 int length; //线性表当前长度 }SqList; 三个属性\n最大长度 当前长度 起始位置 插入与删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //插入 Status ListInsert(SqList *L,int i, ElemType e) { int k; if (L-\u0026gt;length==MAXSIZE) return -1; else if (i\u0026lt;1 || i\u0026gt;L-\u0026gt;length) return -1; else { for(k=L-\u0026gt;Length-1;k-\u0026gt;i-1;k--) L-\u0026gt;data[k+1]=L-\u0026gt;data[k]; } L-\u0026gt;data[i-1]=e; L-\u0026gt;length++; return 0; } //删除 Status ListDelete(SqList *L, int i, ElemType e) { int k; if (L-\u0026gt;length==0) return -1; else if (i\u0026lt;1 || i\u0026gt;L-\u0026gt;length) return -1; *e=L-\u0026gt;data[i-1]; if (i\u0026lt;L-\u0026gt;length) { for(k=i;k\u0026lt;L-\u0026gt;length;k++) L-\u0026gt;data[k+1]=L-\u0026gt;data[k]; } L-\u0026gt;length--; return 0; } 4. 链式存储结构 定义\n结点\n数据域\n存储数据元素信息的域 指针域\n存储直接后继的域 存储的信息称指针(链) 最后一个结点指针为空 头指针\n链表中第一个结点的存储位置 头结点\n在第一个结点前加一个头结点 数据域可以为空 对第一个结点进行的操作可以统一 单链表(每个结点只包含一个指针域的链表)操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 //定义 typedef struct Node { ElemType data; struct Node *next; }Node; typedef struct Node *LinkList; //读取 Status GetElem(LinkList L,int i,ElemType *e) { int j; LinkList p; p = L-\u0026gt;next; j = 1; while (p \u0026amp;\u0026amp; j\u0026lt;i) //p不为空且j小于i的时候 { p = p\u0026gt;-next; j++; } if (!p || j\u0026gt;i) return -1; //第i个元素不存在 *e = p-\u0026gt;data; // 取第i个元素的数据 return 0; } //插入 Status ListInsert(LinkList L,int i,ELemType e) { int j; LinkList,p,s; p =*L; j=1; while(p\u0026amp;\u0026amp;j\u0026lt;i) { p=p-\u0026gt;next; ++j; } if (!p||j\u0026gt;i) return -1; s = (LinkList)malloc(sizeof(Node)); //生成新结点 s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return 0; } //删除 Status ListDelete(LinkList L,int i,ElemType e) { int j; LinkList p,q; p =*L; j=1; while(p=p-\u0026gt;next\u0026amp;\u0026amp;j++\u0026lt;i) ; if (!(p-\u0026gt;next) || j \u0026gt; i) return -1; q = p-\u0026gt;next; p -\u0026gt;next = q-\u0026gt;next; *e = q-\u0026gt;data //回收删除数据 free(q); return 0; } //整表创建 //头插法 void CreateListHead(LinkList *L, int n) { LinkList p; int i; srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; for (i=0;i\u0026lt;n;i++) { p = (LinkList)malloc(sizeof(Node)); p-\u0026gt;data = rand()%100+1; p-\u0026gt;next = (*L) -\u0026gt;next; (*L)-\u0026gt;next = p; } } //尾插法 void CreateListTail(LinkList *L, int n) { LinkList p,r; int i; srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); r = *L; for(i=0;i\u0026lt;n;i++) { p = (Node *)malloc(sizeof(Node)); p-\u0026gt;data = rand()%100+1; r-\u0026gt;next = p; r = p; } r-\u0026gt;next = NULL; } //整表删除 Status ClearList(LinkList *L) { LinkList p,q; *p=(*L)-\u0026gt;next; while(p) { q=p-\u0026gt;next; free(q); p=q; } (*L)-\u0026gt;next=NULL; return 0; } 单链表结构和顺序存储结构的优缺点\n对比/分类 顺序存储结构 单链表 查找 O(1) O(n) 插入和删除 O(n) O(1) 空间 需要预分配，灵活性和安全性低 非常棒 5. 静态链表 定义\n用数组描述的链表 组成\n数据域\n游标(cur)\n第一个游标存放备用链表第一个结点的下标 最后一个游标存放第一个插入元素的下标 特殊称呼\n备用链表\n未被使用的数组元素 操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //定义 #define MAXSIZE 1000 typedef struct { ELemType data; int cur; }Component,StaticLinkList[MAXSIZE]; //初始化 Status InitList(StaticLinkList space) { int i; for(i=0;i\u0026lt;MAXSIZE-1;i++) space[i].cur=i+1; space[MAXSIZE-1].cur=0; return 0; } //插入 Status ListInsert(StaticLinkList L,int i, Elemtype e) { int j,k,l; k=MAXSIZE-1; } 6. 循环链表 定义 将单链表的最后一个指针指向头结点,形成循环链表 合并循环链表 图示 代码 1 2 3 p = rearA-\u0026gt;next; //将A的头结点存起来 rearA-\u0026gt;next = rearB-\u0026gt;next-next;//让A的尾结点指向B的第二个结点，B的头结点被抛弃 rearB-\u0026gt;next = p;//让B的结尾指向A的头结点 7. 双向链表 定义 在每一个结点中设置一个指向其前驱结点的指针的单链表 存储结构 1 2 3 4 5 6 typedef struct DulNode { Elemtype data; struct DulNode *prior; struct DulNode *next; } DulNode,*DulLinkList; 有趣的事实 后继的前驱 = 前驱的后继 = 自己 1 p-\u0026gt;next-\u0026gt;prior = p-\u0026gt;prior-\u0026gt;next = p 操作\n插入图示 删除图示 1 2 3 4 5 6 7 8 9 10 // 插入 s-\u0026gt;prior = p; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next-\u0026gt;prior=s; p-\u0026gt;next=s; //删除 p-\u0026gt;prior-\u0026gt;next=p-\u0026gt;next; p-next-\u0026gt;prior=p-\u0026gt;prior; free(p); ","date":"2022-11-25T00:38:32+08:00","permalink":"https://downeyflyfan.com/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/","title":"线性表"},{"content":"一、磁的基本现象和规律 1.1 磁的库仑定律 $$ 引入磁场强度的概念\\\\\\ \\\\ 定义\\pmb H=\\frac{F}{q_{m0}}\\\\\\ \\\\ \\pmb H=-\\nabla U_{m0}，U_{m0}被称为磁势\\\\\\ \\\\ 与静电学相对应有:\\\\\\ \\\\ \\oint \\pmb H\\cdot d\\pmb l=0\\\\\\ \\\\ \\pmb H=\\frac{\\tau_m}{4\\pi \\mu_0}\\nabla \\Omega\\\\\\ \\\\ \\pmb L=\\pmb{p_m\\times H} $$\n1.2 安培定律 推理\n$$ 对于两段载流导线上的电流元来说\\\\\\ \\\\ dF_{12}\\propto\\frac{I_1dl_1\\cdot I_2dl_2}{r_{12}^2}\\\\\\ \\\\ 其中:d\\pmb l_1=dl_1\\cdot sin\\theta_1，d\\pmb l_2=dl_2\\cdot sin\\theta_2\\\\\\ \\\\ \\therefore dF_{12}=k\\frac{I_1I_2dl_1dl_2sin\\theta_1sin\\theta_2}{r_{12}^2}（其中k取决于单位）\\\\\\ \\\\ d\\pmb F_{12}=k\\frac{I_1I_2d\\pmb l_2\\times(d\\pmb l_1\\times\\pmb r_{12})}{r_{12}^2}(1)\\\\\\ \\\\ 经实验得出:k=\\frac{\\mu_0}{4\\pi} $$\n二、磁感应强度 毕奥萨格尔定律 2.1 磁感应强度B 定义\n根据MSKA单位制 $$ \\pmb B=\\mu_0\\pmb H $$\n表达式和单位\n$$ 根据上述(1)式: d\\pmb F_{12}=\\frac{\\mu_0}{4\\pi}\\frac{I_2d\\pmb l_2\\times(I_1d\\pmb l_1\\times \\pmb r_{12})}{r_{12}^2}\\\\\\ \\\\ 又\\because d\\pmb F_{12}=I_2d\\pmb l_2d\\pmb B\\\\\\ \\\\ \\therefore d\\pmb B=\\frac{\\mu_0}{4\\pi}\\frac{I_1d\\pmb l_1\\times \\pmb r_{12}}{r_{12}^2}\\\\\\ \\\\ 线圈1对于电偶元2的作用力\\\\\\ \\\\ d\\pmb F_2=\\frac{\\mu_0}{4\\pi}I_2d\\pmb l_2\\oint \\frac{I_1d\\pmb l_1\\times\\pmb r_{12}}{r_{12}^2}\\\\\\ \\\\ \\therefore \\pmb B=\\frac{\\mu_0}{4\\pi}\\oint\\frac{I_1d\\pmb l_1\\times\\pmb r_{12}}{r_{12}^2}\\\\\\ \\\\ 其中\\pmb B叫做磁感应强度矢量\\\\\\ \\\\ \\therefore B=\\frac{(dF_{12})_{max}}{I_2dl_2}\\\\\\ \\\\ B的单位为N/A\\cdot m,称为T\\\\\\ \\\\ 1T=10^4Gs $$\n2.2 毕奥萨格尔定律 表达式\n$$ \\pmb B=\\frac{\\mu_0}{4\\pi}\\oint\\frac{I_1d\\pmb l_1\\times\\pmb {\\overrightarrow r}[^1]}{r_{12}^2} $$\n应用\n1.载流直导线\n图示 推导 $$ B = \\int_{A_{1}}^{A_2}\\frac{\\mu_0}{4\\pi}\\frac{Idlsin\\theta}{r^2}\\\\\\ \\\\ 根据几何关系:tan(\\pi-\\theta)=\\frac{r_0}{l}\\\\\\ \\\\ \\therefore dl=\\frac{r_0d\\theta}{sin^2\\theta}\\\\\\ \\\\ \\therefore B=\\frac{\\mu_0}{4\\pi}\\int_{\\theta_1}^{\\theta_2}\\frac{Isin\\theta d\\theta}{r_0}\\\\\\ \\\\ \\pmb{B=\\frac{\\mu_0I}{4\\pi r}(cos\\theta_1-cos\\theta_2)}\\\\\\ \\\\ 当直线无限长时:\\pmb{B=\\frac{\\mu_0 I}{2\\pi r}}\\\\\\ $$\n2.载流圆线圈\n图示 推导 $$ \\\\ dB=\\frac{\\mu_0}{4\\pi}\\frac{Idl}{r^2}=\\frac{\\mu_0}{4\\pi}\\frac{Idl}{r_0^2}sin^2\\alpha\\\\\\ \\\\ B=\\oint dBcos\\alpha=\\oint\\frac{\\mu_0}{4\\pi}\\frac{Idl}{r_0^2}sin^2\\alpha cos\\alpha\\\\\\ \\\\ \\therefore \\pmb {B=\\frac{\\mu_0R^2I}{2(R^2+r_0^2)^{3/2}}}\\\\\\ \\\\ 当P点在球心时:\\pmb{B=\\frac{\\mu_0I}{2R}}\\\\\\ \\\\ 当P点在无穷远处:\\pmb{B=\\frac{\\mu_0R^2I}{2r_0^3}} $$\n载有环向电流的圆筒 图示\n推导\n$$ \\\\ 设半径为R，总长度为L,电流的线密度为\\iota\\\\\\ \\\\ 取轴线为x轴，中点为原点\\\\\\ \\\\ 对于x处的P点\\\\\\ \\\\ dB=\\frac{\\mu_0R\\iota \\cdot dl}{2(R^2+(x-l)^2)^{3/2}}\\\\\\ \\\\ B = \\int_{-L/2}^{L/2}dB\\\\\\ \\\\ 其中: 距离r=\\sqrt{R^2+(x-l)^2}\\\\\\ \\\\ \\frac{x-l}{R}=cot\\beta\\longrightarrow dl=\\frac{Rd\\beta}{sin^2\\beta}\\\\\\ \\\\ \\therefore \\pmb{B=\\frac{\\mu_0\\iota}{2}(cos\\beta_1-cos\\beta_2)}\\\\\\ \\\\ cos\\beta_1=\\frac{x+L/2}{\\sqrt{R^2+(x+L/2)^2}}，cos\\beta_2=\\frac{x-L/2}{\\sqrt{R^2+(x-L/2)^2}}\\\\\\ \\\\ 当螺线管无限长:\\pmb{B=\\mu_0\\iota}\\\\\\ \\\\ 在无限长螺线管的 一端:\\pmb {B=\\frac{\\mu_0\\iota}{2}}\\\\\\ \\\\ 其中，电流线密度\\iota=nI\\\\\\ \\\\ \\therefore 对于无限长螺线管有:B=\\mu_0nI\\\\\\ $$\n2.3 安培环路定律(暂定) 结论\n$$ \\oint \\pmb B\\cdot d\\pmb l=\\mu_0I\\\\\\ \\\\ 或\\pmb B=\\frac{\\mu_0I}{4\\pi}\\nabla\\Omega $$\n三、磁场对载流导线的作用 3.1 安培力与无限长直导线之间的作用 安培力\n$$ d\\pmb F=Id\\pmb l\\times\\pmb B $$\n无限长直导线\n图像\n推导\n$$ \\\\ dF_{12}= I_2dl_2B_1=\\frac{\\mu_0I_1I_2}{2\\pi a}dl_2\\\\\\ \\\\ 同理: dF_{21}=\\frac{\\mu_0I_1I_2}{2\\pi a}dl_1\\\\\\ \\\\ \\therefore 单位作用力f=\\frac{dF_{12}}{dl_2}=\\frac{\\mu_0I_1I_2}{2\\pi a} $$\n3.2 矩形载流线圈所受力矩 图示\n推导\n$$ \\\\ F_{AB}=F_{CD}相互抵消\\\\\\ \\\\ L = F_{BC}\\frac{a}{2}sin\\theta+F_{AD}\\frac{a}{2}sin\\theta\\\\\\ \\\\ L = BIbasin\\theta=IBSsin\\theta\\\\\\ \\\\ \\therefore\\pmb L=IS(\\pmb{n\\times B})\\\\\\ $$\n3.3 载流线圈的磁矩 图示\n推导\n$$ \\\\ dl_1sin\\theta_1=dl_2sin\\theta_2=dh\\\\\\ \\\\ dF_{12}=Idl_1Bsin\\theta_1;dF_{21}=Idl_2Bsin\\theta_2\\\\\\ \\\\ \\therefore dF_{12}=dF_{21}=IBdh\\\\\\ \\\\ \\therefore dL=dF_{12}\\cdot x_1+dF_{21}\\cdot x_2=IBdh(x_1+x_2)\\\\\\ \\\\ L = IBS\\\\\\ \\\\ 其中，m=IS\\longrightarrow\\pmb m=IS\\pmb n\\\\\\ \\\\ \\\\\\therefore\\pmb{\\pmb L = m\\times B}\\\\\\ $$\n3.4 磁偶极子和载流线圈的等价性(待定) 四、带电粒子在磁场中的运动 4.1 洛伦兹力 定义\n根据实验有 $$ \\pmb F=q\\ \\pmb{v\\times B}\\\\\\ \\\\ F = |q|\\ vB\\ sin\\theta $$\n洛伦兹力和安培力的关系\n$$ \\\\ 设自由电子移动速度为u,单位体积的自由电子数为n\\\\\\ \\\\ 在时间\\Delta t内通过面S的电子数为n\\Delta V = nSu\\Delta t\\\\\\ \\\\ 电量\\Delta q = enSu\\Delta t\\\\\\ \\\\ I = \\frac{\\Delta q}{\\Delta t}= enSu\\\\\\ \\\\ 每个电子的洛伦兹力为\\\\\\ \\\\ F=evB\\\\\\ \\\\ F_{总}=nS\\Delta l F=(ensv)\\Delta l B=BI\\Delta l $$\n4.2 带电粒子在磁场中的运动 当 $\\pmb{v\\perp B}$\n$$ qvB=m\\frac{v^2}{R}\\\\\\ \\\\ \\pmb{R=\\frac{mv}{qB}}，\\pmb{T=\\frac{2\\pi m}{qB}} $$\n普遍情形\n图示 推导 $$ h=v_{//}T=\\frac{2\\pi mv}{qB} $$\n磁聚焦 由于$v_{//}$相同，一段时间后这些粒子又会聚集在一起 4.3 荷质比 汤姆孙法\n图示 推导 $$ \\\\ eE=evB\\longrightarrow v=\\frac{E}{B}\\\\\\ \\\\ R=\\frac{mv}{eB}\\\\\\ \\\\ \\frac{e}{m}=\\frac{v}{RB}=\\frac{E}{RB^2}\\\\\\ \\\\ 实验结果:\\frac{e}{m}=1.759\\times 10^{11}C/kg $$\n磁聚焦法\n图示 推导\n$$ \\\\ \\frac{1}{2}mv^2=e\\Delta U\\\\\\ \\\\ v = \\sqrt{\\frac{2e\\Delta U}{m}}\\\\\\ \\\\ h = \\frac{2\\pi m v}{eB}\\\\\\ \\\\ \\therefore \\frac{e}{m}=\\frac{8\\pi^2\\Delta U}{l^2B^2} $$\n","date":"2022-11-24T23:25:35+08:00","permalink":"https://downeyflyfan.com/p/%E6%81%92%E7%A3%81%E5%9C%BA/","title":"恒磁场"}]