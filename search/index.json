[{"content":"RL电路的固有响应 电路图 电流与时间 $$ 对于最右边的网孔列KVL方程 \\\\\\ \\\\ L\\frac{di}{dt}+iR = 0 \\\\\\ \\\\ \\pmb{i(t)=I_0e^{(-R/L)t}，t\\gt 0}\\\\\\ \\\\ 零时刻，电压产生结语变化 \\\\\\ \\\\ v(0^-) = 0，v(0^+) = I_0R ，v(0)位置 $$\n功率 能量 $$ p =i^2R = I_0^2Re^{(-2R/L)t} \\\\\\ \\\\ W = \\int_0^t p d\\tau = \\frac{1}{2}LI_0^2(1-e^{-2(R/L)t}), t\\ge 0 $$\n时间常数 定义 $\\tau =L/R$ 替换后 $$ i(t) = I_0e^{-(t/\\tau)} \\\\\\ \\\\ v(t)= I_0Re^{-(t/\\tau)} \\\\\\ \\\\ p =I_0^2 R e^{-2t/\\tau} \\\\\\ \\\\ W =\\frac{1}{2}LI_0^2(1-e^{-2t/\\tau}) $$\n总结 先求$I_0$\n再求$\\tau = L/R$\n最后求$i(t)$\nRC电路的固有响应 电路图 电压与时间 功率 能量 $$ 引入时间常数\\tau = RC \\\\\\ \\\\ 推导方式同RL电路 \\\\\\ \\\\ v(t)=V_0e^{-t/\\tau} \\\\\\ \\\\ i(t) = \\frac{V_0}{R} e^{-t\\tau} \\\\\\ \\\\ p = \\frac{V_0^2}{R} e^{-2(t/\\tau)}\\\\\\ \\\\ w = \\frac{1}{2}CV^2(1-e^{-2(t/\\tau)}) $$\nRL RC电路的阶跃响应 RL 电路的阶跃响应 图示 电流与时间 $$ V_s = Ri + L\\frac{di}{dt} \\\\\\ \\\\ i(t) = \\frac{V_s}{R} + (I_0-\\frac{V_s}{R})e^{-t/\\tau} \\\\\\ \\\\ \\Rightarrow \\pmb {i(t) = \\frac{V_s}{R}(1-e^{-t/\\tau})} \\\\\\ \\\\ i(t) \\rightarrow \\frac{V_s}{R} \\\\\\\n$$\n电流与时间的变化率 $$ \\frac{di}{dt} = \\frac{V_s}{L}e^{-t/\\tau}\\\\\\ \\\\ \\frac{di}{dt}(0) = \\frac{V_S}{L} \\\\\\ $$\n其他变量 $$ v = L\\frac{di}{dt} = (V_s-I_0R)e^{-t/\\tau} \\\\\\ \\\\ $$\nRC电路的阶跃响应 电路图 公式 $$ i =(I_S-\\frac{V_0}{R})e^{-t/\\tau},t\\ge 0 $$\n阶跃响应与固有响应的一般解法 公式表达 $$ 对于方程\\frac{dx}{dt}+\\frac{x}{\\tau} = K \\\\\\ \\\\ 终值x_f = K\\tau \\\\\\ \\\\ \\pmb{x(t) =x_f+[x(t_0)-x_f]e^{-(t-t_0)/\\tau}} $$\n步骤 确定电路的有关变量 对于RC电路，选择电容电压 对于RL电路，选择电感电流 决定初始量 对于电容电压或电感电流, 因为不能突变,,$x(t_0^-)=x(t_0)=x(t_0^+)$ 对于其他量，应当注意其突变 计算$x_f$\n计算$\\tau$\n","date":"2022-12-03T02:18:32+08:00","permalink":"https://example.com/p/rlrc%E7%94%B5%E8%B7%AF%E7%9A%84%E5%93%8D%E5%BA%94/","title":"RL,RC电路的响应"},{"content":"电感 电感的电压与电流 $$ 根据定义\\\\\\ \\\\ v=L\\frac{di}{dt} \\\\\\ \\\\ di = \\frac{v}{L}dt \\\\\\ \\\\ L\\int_{i(0)}^{i(t)} di = \\int_0^t vd\\tau \\\\\\ \\\\ i(t)=\\frac{1}{L}\\int_0^tvd\\tau +i(0) $$\n电感的功率和能量 $$ p = vi =Li\\frac{di}{dt} \\\\\\ \\\\ \\int_0^t p d\\tau = \\int_{i(0)}^{i(t)}Lidi \\\\\\ \\\\ pt = \\frac{1}{2}L(i(t)^2-i(0)^2) \\\\\\ \\\\ 当i(0)=0时,W=\\frac{1}{2}Li^2 $$\n特点 端电流不允许跃变\n端电压允许跃变\n端电流为常量时，短路\n电容 电压 电流 功率 能量 $$ 推导方式与电感相同，可以得出 \\\\\\ \\\\ i = C\\frac{dV}{dt} \\\\\\ \\\\ V =\\frac{1}{C} \\int_0^ti(\\tau) d\\tau + v(0) \\\\\\ \\\\ W =\\frac{1}{2}Cv^2 $$\n特点 端电压不能突变\n端电流可以突变\n当电压为常数时，相当于断路\n电容 电感 串并联 电感串并联 $$ 串联：\\frac{1}{L_{eq}}= \\sum_{i=1}^n \\frac{1}{L_i} \\\\\\ \\\\ 并联: L_{eq} =\\sum_{i=1}^n L_i $$\n电容串并联 $$ 串联: C_{eq} = \\sum_{i=1}^n C_i \\\\\\ \\\\ 并联: \\frac{1}{C_{eq}} = \\sum_{i=1}^n \\frac{1}{C_i} $$\n互感 详见物理学——电磁感应部分\n","date":"2022-12-03T01:56:41+08:00","permalink":"https://example.com/p/%E7%94%B5%E6%84%9F%E7%94%B5%E5%AE%B9%E4%B8%8E%E4%BA%92%E6%84%9F/","title":"电感、电容与互感"},{"content":"栈的定义和操作名称 定义 栈是限定仅可在表尾进行删除和插入的线性表 后进先出形(LIFO)的线性表 基本概念 栈顶(top) 栈可删除和插入的一端 栈底(bottom) 另一端为栈底 空栈 没有元素的栈 操作 插入 也叫进栈，压栈，入栈 删除 弹栈，出栈 栈的ADT 1 2 3 4 5 6 7 8 9 10 11 12 Data 同线性表 Operation IintStack(*S):初始化建立空栈 DestroyStack(*S): 摧毁一个栈 ClearStack(*S):清空栈 StackEmpty(S):栈为空，返回true,否则返回false GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素 Push(*S,e):插入 Pop(*S,*e):删除，并用e返回被删除的元素 StackLength:返回栈S的元素个数 endADT 栈的顺序存储结构 结构定义 1 2 3 4 5 6 typedef int SElemType; //根据实际情况确定栈的元素类型 typedef struct { SElemType data[MAXSIZE]; int top;//用于栈顶指针 }SqStack; 入栈\n1 2 3 4 5 6 7 8 Status Push(SqStack *S, SElemType e) { if (S-\u0026gt;top==MAXSIZE-1)//栈满 return -1; S-\u0026gt;top++; S-\u0026gt;data[S-\u0026gt;top]=e; return 0; } 出栈\n1 2 3 4 5 6 7 8 Status Pop(SqStack *S, SElemType *e) { if (S-\u0026gt;top==-1)//空栈 return -1; *e = S-\u0026gt;data[S-\u0026gt;top]; S-\u0026gt;top--; return -1; } 两栈共享空间 结构 将两栈的顶部接到一起 结构代码 1 2 3 4 5 6 typedef struct { SElemType data[MAXSIZE]; int top1; int top2; }SqDoubleStack 操作 插入 1 2 3 4 5 6 7 8 9 10 Status Push(SqDoubleStack *S, SElemType e, int StackNumber) //StackNumber 用来判断插入栈1还是栈2 { if(S-\u0026gt;top1++=S-\u0026gt;top2)//栈满 return -1; if(StackNumber == 1) S-\u0026gt;data[++S-\u0026gt;top1]=e; if(StackNumber == 2) S-\u0026gt;data[--S-\u0026gt;top2]=e; } 删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Status Pop(SqDoubleStack *S, SElemType *e,int StackNumber) { if (StackNumber == 1) { if (S-\u0026gt;top1==-1)//空栈 return -1; *e = S-\u0026gt;data[S-\u0026gt;top1]; top1++; } if (StackNumber == 2) { if (S-\u0026gt;top2 == MAXSIZE)//空栈 return -1; *e = S-\u0026gt;data[S-\u0026gt;top2]; top2--; } return 0; } 栈的链式存储结构 定义 简称链栈 特点 栈顶在头部 没有头结点 结构代码 1 2 3 4 5 6 7 8 9 10 11 typedef struct StackNode { SElemType data; struct StackNode *next; } StackNode,*LinkStackPtr; typedef struct LinkStack { LinkStackPtr top; int count; }LinkStack; 操作 进栈 1 2 3 4 5 6 7 8 Status Push(LinkStack *S, SElemType e) { LinkStackPtr s = (LinkStackPtr) malloc(sizeof(StackNode)); s-\u0026gt;data=e; s-\u0026gt;next=S-\u0026gt;top; S-\u0026gt;count++; return 0; } 出栈 1 2 3 4 5 6 7 8 9 10 11 12 Status Pop(LinkStack *S, SElemType *e) { LinkStackPtr p; if (StackEmpty(*S))//空栈 return -1; *e = S-\u0026gt;top-\u0026gt;data; p = S-\u0026gt;top; S-\u0026gt;top=S-\u0026gt;top-\u0026gt;next; free(p); S-\u0026gt;count--; return 0; } 栈的应用 递归 斐波那契数列 数学定义 $$ F(n)=\\begin{cases}0 \u0026amp; n=0 \\\\ 1 \u0026amp; n=1 \\\\ F(n-1)+F(n-2) \u0026amp; n \\ge 2\\end{cases} $$\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int Fib(int n) { if (n == 0) return 0; else if (n==1) return 1; else return F(n-1)+F(n-2); } int main() { int i = 0; for(i=0;i\u0026lt;40;i++) { printf(\u0026#34;%d\u0026#34;,Fib(n)); } return 0; } 文字定义 调用自己的函数(包括直接和间接)称作递归函数\n四则运算表达式求值 后缀表达式 原则 数字依次进栈 有运算符号,出两个数字 下面的数字在运算符号前 上面的数字在运算符号后 例 9 3 1 - 3 * + 10 2 / + = 20\n中缀表达式转后缀表达式 中缀表达式就是平时用到的表达式\n转换\n数字按顺序输出\n符号依次进栈\n若下方的符号运算优先级高于上方，输出该符号及其上方的符号\n队列(FIFO) 定义 只允许在一端插入，另一端删除的线性表\n队尾 只允许插入的一端 队头 只允许删除的一端 ADT 1 2 3 4 Data 同线性表，有前驱和后继，元素类型相同 Operation 循环队列 定义 队列的头尾相连的顺序存储结构\n结构 初始化 长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 结构定义 typedef int QElemType; typedef struct { QElemType data[MAXSIZE]; int front; int rear; }SqQueue; // 初始化 Status Sqinit(SqQueue *Q) { Q-\u0026gt;front = 0; Q-\u0026gt;rear = 0; return 0; } // 长度 int QueueLegnth(SqQueue Q) { return ((Q.rear - Q.front + MAXSIZE) % MAXSIZE); } 入列和出列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 入列 Status EnQueue(SqQueue *Q,QElemType e) { if ((Q-\u0026gt;rear + 1) == Q-\u0026gt;front) return -1; Q-\u0026gt;data[Q-\u0026gt;rear] = e; Q-\u0026gt;rear = (Q-\u0026gt;rear+1)%MAXSIZE; return 0; } // 出列 Status DeQueue(SqQueue *Q, QElemType *e) { if (Q-\u0026gt;rear == Q-\u0026gt;front) return -1; *e=Q-\u0026gt;data[Q-\u0026gt;front]; Q-\u0026gt;front = (Q-\u0026gt;front + 1)% MAXSIZE; } 队列的链式存储结构 定义 线性表的单链表，称为链队列\n结构 1 2 3 4 5 6 7 8 9 10 typedef struct Node { QElemType data; struct Node *next; }QNode,*QueuePtr; typedef struct { QueuePtr front,rear; }LinkQueue; 入列 出列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 入列 Status EnQueue (LinkQueue *Q, QElemType e) { QueuePtr s = (QueuePtr) malloc (sizeof(Node)); if(!s) exit(0); s-\u0026gt;data = e; s-\u0026gt;next = NULL; Q-\u0026gt;rear-\u0026gt;next = s; Q-\u0026gt;rear = s; return 0; } // 出列 Status DeQueue(LinkQueue *Q, QElemType *e) { QueuePtr p; if (Q-\u0026gt;front == Q-\u0026gt;rear) return -1; p = Q-\u0026gt;front-\u0026gt;next; *e = p-\u0026gt;data; Q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; if(Q-\u0026gt;rear = p) Q-\u0026gt;rear = Q-\u0026gt;free; free(p); return 0; } ","date":"2022-12-01T23:55:15+08:00","permalink":"https://example.com/p/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","title":"栈和队列"},{"content":"运算放大器端子 重要的端子 反相输入\n同相输入\n输出\n正电源\n负电源\n图示 运放电路符号 运放简化电路符号 端电压和端电流 端电压变量 $$ 理想状态 \\\\\\ \\\\ v_p = v_n $$\n端电流变量 $$ 理想状态 \\\\\\ \\\\ i_p=i_n=0 \\\\\\ \\\\ i_0=-(i_{c^-}+i_{c^+}) $$\n运放的电压传输特性 图示 $$ 理想状态 \\\\\\ \\\\ A \\rightarrow \\infin $$\n公式 $$ v_0=\\begin{cases}+V_{CC} \u0026amp; A(v_p-v_n)\\gt V_{CC} \\\\ A(v_p-v_n) \u0026amp; -V_{CC}\\le A(v_p-v_n) \\le +V_{CC} \\\\ -V_{CC} \u0026amp; A(v_p-v_n) \\lt -V_{CC}\\end{cases} $$\n反相放大器电路 图示 推导 $$ i_f+i_s=i_n = 0 \\\\\\ \\\\ v_n=v_p=0 \\\\\\ \\\\ \\frac{v_0}{R_f}+\\frac{v_s}{R_s} = 0\\\\\\ \\\\ \\therefore v_0=-\\frac{R_f}{R_s}v_s \\\\\\ \\\\ |v_0|\\le V_{CC} $$\n求和放大器电路 图示 推导 $$ 通过节点电压法可以得到 \\\\\\ \\\\ v_0=-(\\frac{R_f}{R_a}v_a+\\frac{R_f}{R_b}v_b+\\frac{R_f}{R_c}v_c) \\\\\\ \\\\ 若R_a=R_b=R_c=R_s \\\\\\ \\\\ v_0=-\\frac{R_f}{R_s}(v_a+v_b+v_c) \\\\\\ \\\\ 若R_f=R_S \\\\\\ \\\\ v_0=v_a+v_b+v_c，输入与输出电压正好反相 $$\n同相放大器电路 图示 推导 $$ \\frac{v_0-v_n}{R_f}+\\frac{v_n}{R_s}=0\\\\\\ \\\\ v_0=\\frac{R_f+R_S}{R_s}v_n $$\n差分放大器 图示 推导 $$ 对于反相节点\\\\\\ \\\\ \\frac{v_n-v_a}{R_A}+\\frac{v_0-v_n}{R_b}= 0 \\\\\\ \\\\ 对于同相节点 \\\\\\ \\\\ v_p=\\frac{R_d}{R_c+R_d}v_b = v_n \\\\\\ \\\\ \\Rightarrow v_0=\\frac{R_d(R_a+R_b)}{R_a(R_c+R_d)}v_b-\\frac{R_b}{R_a}v_a\\\\\\ \\\\ 当\\frac{R_a}{R_b}=\\frac{R_c}{R_d} \\\\\\ \\\\ v_0=\\frac{R_b}{R_a}(v_b-v_a) $$\n关于差分放大器的其他问题 共模输入与差模输入 $$ v_{dm} = v_b-v_a \\\\\\ \\\\ v_{cm} = \\frac{v_a+v_b}{2} \\\\\\ \\\\ \\therefore v_0=A_{cm}v_{cm}+A_{dm}v_{dm} \\\\\\ \\\\ 当R_a=R_c，R_b=R_d \\\\\\ \\\\ v_0 = (o)v_{cm}+\\frac{R_b}{R_a}v_{dm} $$\n","date":"2022-12-01T20:47:09+08:00","permalink":"https://example.com/p/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/","title":"运算放大器"},{"content":"大数定律 总体表述 $$ E(X_i)=\\mu \\\\\\ \\\\ 在一定条件下 \\\\\\ \\\\ Y=\\frac{X_1+X_2+\u0026hellip;+X_n}{n}收敛到\\mu $$\n依概率收敛 定义\n性质\n若$X_n \\rightarrow a, Y_n\\rightarrow b$ , $g$在$(a,b)$上连续，则$g(X_n,Y_n)\\rightarrow g(a,b)$\n若$X_n \\rightarrow a$,$f(x)$在点$a$连续，则$f(X_n)\\rightarrow f(a)$\n马尔可夫不等式与切比雪夫不等式 马尔可夫不等式 设随机变量Y的k阶矩存在\n","date":"2022-12-01T04:04:03+08:00","permalink":"https://example.com/p/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/","title":"大数定律和中心极限定理"},{"content":"数学期望 定义 离散型 设离散型随机变量$X$的分布律为$P(X=x_k)=p_k,k=1,2\u0026hellip;$，若级数$\\sum_{k=1}^{+\\infin}|x_k|p_k\\lt + \\infin$，那么称该级数为$X$的数学期望, 记为\n$$ E(X)=\\sum_{k=1}^{+\\infin}x_kp_k $$\n连续型 $$ E(X)=\\int_{-\\infin}^{+\\infin}xf(x)dx $$\n随机变量函数的数学期望 一元随机变量函数 $Y=g(X)$,且级数收敛,则\n$$ 对于\\pmb{离散型} \\\\\\ \\\\ E(Y)=E[g(X)] = \\sum_{k=1}^{+\\infin}g(x_k)p_k \\\\\\ \\\\ 对于\\pmb{连续型} \\\\\\ \\\\ E(Y)=E(g(X)) = \\int_{-\\infin}^{+\\infin}g(x)f(x)dx $$\n二元随机变量函数 $Z=h(X,Y)$\n$$ 对于\\pmb{离散型} \\\\\\ \\\\ E(Z)=E[h(X,Y)] = \\sum_{i=1}^{+\\infin}\\sum_{j=1}^{+\\infin}h(x_i,y_j)p_{ij} \\\\\\ \\\\ 对于\\pmb{连续型} \\\\\\ \\\\ E(Z) = E(h(X,Y)) = \\int_{-\\infin}^{+\\infin}\\int_{-\\infin}^{+\\infin}h(x,y)f(x,y)dxdy $$\n数学期望的特性 线性组合的数学期望 $$ E(c_0+\\sum_{i=1}^nc_ix_i) = c_0+\\sum_{i=1}^nc_iE(X_i) $$\n随机变量的独立性 $$ 满足E(\\prod_{i=1}^n X)=\\prod_{i=1}^nE(X_i)的随机变量\\\\\\ \\\\ X_i，i=1,2\u0026hellip; n 相互独立 $$\n方差 定义 方差 $$ Var(X)=E\\lbrace\\big [X-E(X)\\big ]^2\\rbrace $$ 记方差为$Var(X)$或$D(X)$\n标准差 记$\\sqrt{Var(X)}$为$\\sigma(x)$，称为标准差或均方差，与$X$有相同的量纲\n计算公式 $$ Var(X)=E\\lbrace X^2-2XE(X)+E^2(X) \\rbrace \\\\\\ \\\\ \\pmb {Var(X) =E(X^2)-E^2(X)} $$\n方差的性质 线性组合的方差 $$ Var(c_0+\\sum_{i=1}^n c_iX_i) = \\sum_{i=1}^nc_i^2Var(X_i) $$\n方差=0 $$ Var(X)=0\\Leftrightarrow P(X=C)=1,C=E(X) $$\n几种常见分布的均值和方差 分布 概率分布律或概率密度函数 数学期望 方差 0-1分布 $P(X=k)=p^k(1-p)^{1-k}$ $p$ $p(1-p)$ 二项分布 $P(X=k)=C_n^kp^k(1-p)^{1-k}$ $np$ $np(1-p)$ 泊松分布 $P(X=k)=\\frac{e^{-\\lambda}\\lambda^k}{k!}$ $\\lambda$ $\\lambda$ 均匀分布 $f(x) = \\begin{cases} 1/(b-a) \u0026amp; a\\lt x \\lt b \\\\ 0 \u0026amp; otherwise \\end{cases}$ $\\frac{a+b}{2}$ $\\frac{(b-a)^2}{12}$ 指数分布 $f(x) =\\begin{cases}\\lambda e^{-\\lambda x} \u0026amp; x \\gt 0\\\\ 0 \u0026amp; otherwise \\end{cases}$ $1/\\lambda$ $1/\\lambda^2$ 正态分布 $f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},x \\in R$ $\\mu$ $\\sigma^2$ 协方差和相关系数 协方差 定义 定义$E\\lbrace[X-E(X)][Y-E(Y)]\\rbrace$为协方差，记为$Cov(X,Y)$\n$$ Cov(X,Y) = \\lbrace[X-E(X)][Y-E(Y)]\\rbrace $$\n计算公式 $$ Cov(X,Y)=E(XY)-E(X)E(Y) $$\n方差性质补充 $$ Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y) $$\n性质 $Cov(aX,bY)=ab\\cdot Cov(X,Y)$\n$Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$\n当$Var(X)Var(Y)\\neq 0$，$(Cov(X,Y))^2\\le Var(X)Var(Y)$\n相关系数 定义 $$ \\rho_{XY}=\\frac{Cov(X,Y)}{\\sqrt{Var(X)Var(Y)}} \\\\\\ \\\\ \\rho_{XY}=Cov(\\frac{X-E(X)}{\\sqrt{Var(X)}},\\frac{X-E(Y)}{\\sqrt{Var(Y)}}) $$\n性质 $\\rho_{XY}\\le 1$\n存在常数$a,b$，使$P(Y=a+bX)=1$,特别地;$\\rho_{XY}=1$时，$b\\gt 0$ , $\\rho_{XY}=-1$时，$b\\lt 0 \\Rightarrow |\\rho_{XY}|=1$\n作用 一个表征$X,Y$之间的线性关系紧密程度的量\n当$\\rho_{XY}\\gt 0$,$X与Y$正相关\n当$\\rho_{XY}\\lt 0$,$X与Y$负相关\n当$\\rho_{XY} = 0$,$X与Y$不相关\n其他数字特征 k阶(原点)矩 $$ E(X^k)，k=1,2,\u0026hellip; $$\nk阶中心矩 $$ E\\lbrace[X-E(X)]^k\\rbrace，k=1,2\u0026hellip; $$\nk+l阶混合(原点)矩 $$ E\\lbrace X^kY^l\\rbrace, k,l=1,2 $$\nk+l阶混合中心矩 $$ E\\lbrace[X-E(X)]^k[Y-E(Y)]^k\\rbrace $$\n多元随机变量的数字特征 数学期望向量 设n元随机变量$\\pmb X =(X_1,X_2,\u0026hellip;X_n)^T$,则称\n$$ E(\\pmb X)= (E(X_1),E(X_2),\u0026hellip;E(X_n))^T $$\n为$n$元随机变量的数学期望向量 协方差矩阵 设二元随机变量$(X_1,X_2)$的四个二阶中心矩存在，则\n$$ \\begin{pmatrix}Var(X_1) \u0026amp; Cov(X_1,X_2) \\\\ Cov(X_2,X_1) \u0026amp; Var(X_2) \\end{pmatrix} $$\n称为协方差矩阵 ","date":"2022-11-30T22:10:32+08:00","permalink":"https://example.com/p/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/","title":"随机变量的数字特征"},{"content":"大二上 主题 What can be learned from a notable figure in the history of electronics or electrical engineering\n长度 8分钟PPT 2分钟Q\u0026amp;A PPT 要求！！ 所有的图片标注为image1、\u0026hellip;image n 开头加上参与者拼音名 倒数第二张必须是图片来源 最后一张必须是Reference 所有的source必须是IEEE style 名称是Pres_slides_Stuednt1SurnameGivenname_Student2SurnameGivenname 在北京时间2022.12.18之前上传PPT PPT内容 层次清晰，有Introduction,有conclusion 必须从下面选一个figure，大家不能有重复的 不能只讲生活和贡献 必须着重讲他们在Electrical \u0026amp; Electronic Engineering的贡献 我们能从他们的贡献和经历中学习什么 我们能学习什么 他们如何激励了其他人在该领域的工作 他们具有什么样的精神品质促成了他们的伟大成就 他们遇到了什么困难，面对困难时，他们展示了什么样的精神品质 他们的伟大成就有什么积极的和消极的长期影响 只有他们的成就才能促成的发明、发现有哪些 他们多大程度上单独完成了他们的成就 其他人有多大可能做出相同贡献 他们的早期家庭生活多大程度上影响了他们的成功 他们接受的基础科学教育多大程度上影响了他们的成功 经济援助多大程度上上影响了他们的成功 Sources 必须paraphrase 来源 UoG Library IEEE Xplore English Text book UESTC library other English Website 若果用Britannic Academic，必须用以下格式引用 最后 可以带打印Notes 记得录视频 不准用电子产品记笔记 ","date":"2022-11-30T21:09:50+08:00","permalink":"https://example.com/p/presentation/","title":"Presentation"},{"content":"静电的基本现象和规律 电荷守恒 场强叠加 库仑定律 $$ \\pmb F_{12}=k\\frac{q_1q_2}{r^2}\\pmb r_{12} \\\\\\ \\\\ 单位: C \\ \\ 1C=1A\\cdot s \\\\\\ \\\\ e = 1.602\\times 10^{-19} (C) \\\\\\ \\\\ 在MKSA单位制中，k=\\frac{1}{4\\pi \\varepsilon_0} \\\\\\ \\\\ \\varepsilon_0 = 8.85\\times 10^{-12} \\ C/(N\\cdot m^2)，k=8.99\\times 10^9(N\\cdot m^2/C^2) \\\\ $$\n电场 电场强度 电场强度的定义 $$ \\pmb E=\\frac{\\pmb F}{q_0}=\\frac{1}{4\\pi\\varepsilon_0}\\frac{q_0}{r^2}\\pmb{\\widehat r} \\\\\\ $$\n高斯定理 立体角(暂定) $$ d\\Omega=\\frac{dS}{r^2} \\Rightarrow d\\Omega = \\frac{\\widehat{\\pmb r}\\cdot d\\pmb S}{r^2} \\\\\\ $$\n高斯定理的表述和证明 表述 通过任意闭合曲面的电通量等于该面包围的所有电量的代数和除以$\\varepsilon_0$\n证明 $$ d\\Phi_E=\\pmb E\\cdot d \\pmb S=\\frac{q}{4\\pi\\varepsilon_0} \\frac{\\widehat{\\pmb r}\\cdot d\\pmb S}{r^2} = \\frac{q}{4\\pi\\varepsilon_0}d\\Omega \\\\\\ \\\\ \\oiint d\\Phi_E=\\frac{q}{4\\pi\\varepsilon_0}\\oiint d\\Omega = \\frac{q}{\\varepsilon_0} $$\n","date":"2022-11-30T04:50:46+08:00","permalink":"https://example.com/p/%E9%9D%99%E7%94%B5%E5%9C%BA/","title":"静电场"},{"content":"黑体辐射 表述 所有物体都会产生热辐射\n$$ 辐射光强 I\\propto T^4\n$$\n","date":"2022-11-30T03:38:30+08:00","permalink":"https://example.com/p/%E9%87%8F%E5%AD%90%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B/","title":"量子理论简介"},{"content":"技巧部分 提出观点 随机 It seems to me that \u0026hellip;\nPersonally, I feel \u0026hellip;\nDoes anyone know\u0026hellip;\nHave you guys got any idea about\u0026hellip;\nFrom my point of view\u0026hellip;\n补充他人观点 May I adding here?\nAs you mentioned\u0026hellip;\nThat\u0026rsquo;s a very good point, and I have an example \u0026hellip;\n引用观点 According to A book\nInformation on a website\nAn artical in trade public\nreport\nlecture\nvideo\n提问 弄清他人意图 So, you mean \u0026hellip;\nSo, what you are saying is \u0026hellip;\nSorry, I didn\u0026rsquo;t quite catch(follow) you. Could you please repeat that?\n打断他人 完全同意 I can\u0026rsquo;t agree with you more\u0026hellip;\nI totally agree with you.\n不完全同意 That\u0026rsquo;s true, but \u0026hellip;\nWell, that might be correct \u0026hellip;\nYes, but \u0026hellip;\n完全不同意 I\u0026rsquo;m sorry, but the point that \u0026hellip; might not be correct\nSorry, but SOMEBODY said the opposite of that\u0026hellip;\nA lot of people1 made that claim, but research published in IEEE \u0026hellip; found that \u0026hellip;\n你话太多 Sorry to say so, but you know, our time is limited. Summary 适当总结，推进话题 大二上考试内容 Main Text - E-waste: A Global Issue E-devices $\\uparrow \\Rightarrow$ E-waste $\\uparrow$ in the past 50 years $\\Rightarrow$ Human Health \u0026amp; Enviroment $\\downarrow$\nBoth in Developed and Developing Countries\nstateDiagram state Report_of_United_Nations_University{ 2014 --\u003e 2016(45Mt): %5 increase 2016(45Mt) --\u003e 2021(52Mt): Predict } state India{ 2006 --\u003e 2010: doubled } Factors Economic growth\nDigital revolution\nPrice of e-deivces $\\downarrow$\nLifespan of e-devices $\\downarrow$\nSolution stateDiagram E_devices --\u003e Enviroment: toxic substances Enviroment --\u003e Human_Health: hurt Envirionment: nearby water,air,ground Recycle expensive $\\Rightarrow$ Developed send e-waste to developing countries International agreement: Restrict th e amount of waste being sent to developing countries\nUS don\u0026rsquo;t sign up these agreements\nStop sending trash to developing countries !!! Governments need more actions!!! Text 3 Unfair e-Waste Trade in Africa 可以具体化为jouranlists, writers等\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-11-30T03:22:47+08:00","permalink":"https://example.com/p/group_discussion/","title":"Group_Discussion"},{"content":"[toc]\n术语 节点 两个或更多元件的连接点 基本节点 三个或更多元件的连接点 路径 基本元件相连的踪迹(相同元件不能重复出现) 支路 连接两个节点的路径 基本支路 连接两个基本节点的路径，不通过基本节点 回路 闭环路径 平面电路 画在平面上没有交叉的电路 超节点 当一个电压源在两个基本节点之间，这两个节点可以组合成一个超节点 超网孔 相邻网孔间只有电流源，可以合并为一个超网孔 方法 节点电压法 步骤 调整电路布局，使得电路没有交叉\n选择参考节点\n确定节点电压\n非参考节点到参考节点的电压升 在非参考节点处列$KCL$方程 注意可以合并形成的超节点 网孔电流法 寻找网孔电流\n在每个网孔中列$KCL$方程\n两种方法的选择 谁的方程最少\n是否包含超节点\n是否包含超网孔\n题目要求解的是什么\n电源变换 图示 方法 电压源串电阻 $\\Leftrightarrow$ 电流源并电阻 $$ i_s=\\frac{v_s}{R} $$\n戴维南-诺顿等效电路 图示 戴维南电阻推导 $$ 先计算开路电压V_{Th} \\\\\\ \\\\ 再计算短路电流 i_{sc}=\\frac{V_{Th}}{R_{Th}} \\\\\\ \\\\ R_{Th}=\\frac{V_{Th}}{i_{sc}} $$\n诺顿等效电路 最大功率传输 将电路简化为戴维南电阻连着负载$R_L$ $$ p = i^2R_L = (\\frac{V_{Th}}{R_{Th}+R_L})^2R_L \\\\\\ \\\\ 令\\frac{dp}{dR_L} = 0 \\Rightarrow R_L=R_{Th} \\\\\\ \\\\ p_{max} = \\frac{V_{Th}^2}{4R_L} $$\n叠加原理 当一个线性系统被一个以上的独立源激励或驱动时，总响应是单独响应的和\n总结 网孔电流法只适用于平面电路\n节点电压法适用于平面电路和非平面电路\n","date":"2022-11-29T04:29:48+08:00","permalink":"https://example.com/p/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%B3%95/","title":"电路分析法"},{"content":"[toc]\n一、麦克斯韦电磁理论 1.1 位移电流 理清四个概念 $$ 电场强度\\pmb E\\\\\\ \\\\ 电位移矢量(电感应强度) \\pmb D=\\varepsilon_0 \\pmb E+\\pmb P，单位:C/m^2\\\\\\ \\\\ 磁感应强度\\pmb B\\\\\\ \\\\ 磁场强度\\pmb H=\\frac{\\pmb B}{\\mu_0} $$\n库仑定律+场强叠加定律$\\Rightarrow$ $$ 电场的高斯定律\\\\\\ \\\\ \\oiint\\pmb D\\cdot d\\pmb S=q_0\\\\\\ \\\\ 静电场的环路定律\\\\\\ \\\\ \\oint\\pmb E\\cdot d\\pmb l=0 $$\nBio-Sarurt定律$\\Rightarrow$ $$ 磁场的高斯定律\\\\\\ \\\\ \\oiint \\pmb B\\cdot d\\pmb S=0\\\\\\ \\\\ 安培环路定律 \\\\\\ \\\\ \\oint \\pmb H\\cdot d\\pmb l=I_0 $$\n磁场变化的规律 $$ 法拉第电磁感应定律\\\\\\ \\\\ \\xi =-\\frac{\\partial \\Phi_B}{\\partial t} $$\n位移电流的推导 $$ \\\\ \\oint \\pmb H \\cdot d\\pmb l = I_0=\\oiint \\pmb j_0\\cdot d\\pmb S=-\\frac{dq_0}{dt}\\\\\\ \\\\ \\because \\oiint \\pmb D\\cdot d\\pmb S=q_0\\Rightarrow \\frac{dq_0}{dt}=\\oiint \\frac{\\partial \\pmb D}{\\partial t}d\\pmb S，代入上式\\\\\\ \\\\ \\oiint (\\pmb j_0+\\frac{\\partial \\pmb D}{\\partial t})d\\pmb S=0\\Rightarrow \\pmb j_0+\\frac{\\partial \\pmb D}{\\partial t}是个连续量\\\\\\ \\\\ 其中,\\frac{\\partial \\pmb \\Phi_0}{\\partial t}=\\iint \\frac{\\partial \\pmb D}{\\partial t}\\cdot d\\pmb S叫做\\pmb{位移电流}\\\\\\ \\\\ \\frac{\\partial \\pmb D}{\\partial t}叫做\\pmb{位移电流密度}\\\\\\ \\\\ I_0=\\iint \\pmb j_0\\cdot d\\pmb S叫做\\pmb{全电流}\\\\\\ \\\\ 故\\oint \\pmb H\\cdot d\\pmb l = I_0 + \\frac{\\partial \\pmb \\Phi_D}{\\partial t } $$\n位移电流与传导电流 位移电流是电场变化产生的 传导电流是电荷在导体中移动产生的 1.2 麦克斯韦方程组 积分形式 $$ \\oiint \\pmb D\\cdot d\\pmb S=q_0\\\\\\ \\\\ \\oint \\pmb E\\cdot d\\pmb l=-\\iint\\frac{\\partial \\pmb B}{\\partial t }\\cdot d\\pmb S\\\\\\ \\\\ \\oiint \\pmb B\\cdot d\\pmb S=0\\\\\\ \\\\ \\oint \\pmb H\\cdot d\\pmb l=I_0+\\iint\\frac{\\partial \\pmb D}{\\partial t}d\\pmb S\\\\\\ \\\\ $$\n微分形式 $$ \\nabla \\cdot \\pmb D=\\rho_0\\\\\\ \\\\ \\nabla\\times\\pmb E=-\\frac{d\\pmb B}{dt}\\\\\\ \\\\ \\nabla \\cdot \\pmb B=0\\\\\\ \\\\ \\nabla \\times \\pmb H=\\pmb j_0+\\frac{\\partial \\pmb D}{\\partial t} $$\n最基本形式 $$ \\nabla\\cdot \\pmb E=\\frac{\\rho_0}{\\varepsilon_0}\\\\\\ \\\\ \\nabla\\times\\pmb E=-\\frac{d\\pmb B}{dt}\\\\\\ \\\\ \\nabla \\cdot \\pmb B=0\\\\\\ \\\\ \\nabla\\times \\pmb B= \\varepsilon_0\\mu_0\\frac{\\partial \\pmb E}{\\partial t } +\\mu_0\\pmb j_0 $$\n1.3 边界条件(暂定) 二、电磁波理论 2.1 平面电磁波的解(暂定) 自由空间的麦克斯韦方程 $$ \\nabla\\cdot \\pmb D=0 \\\\\\ \\\\ \\nabla\\times \\pmb E=-\\mu_0\\frac{\\partial \\pmb H}{\\partial t}\\\\\\ \\\\ \\nabla\\cdot \\pmb H=0\\\\\\ \\\\ \\nabla\\times\\pmb H=\\varepsilon_0\\frac{\\partial \\pmb E}{\\partial t} $$\n电磁场中的位置关系 $$ \\pmb E\\perp\\pmb B\\perp 传播方向\\pmb k\\\\\\ \\\\ $$\n2.2 平面电磁波的性质 电磁波是横波\n$\\pmb E$和$\\pmb B$同相位\n$\\pmb{E\\times N}$与传播方向始终同向\n$\\pmb E$和$\\pmb B$的幅值成比例\n$$ \\varepsilon_0^2E_0=\\mu_0^2H_0^2 = B_0^2 $$\n电磁波的速率$v=\\frac{1}{\\sqrt{\\varepsilon_0\\mu_0}}=c$ 三、电磁场的能流密度矢量和动量 3.1 ","date":"2022-11-29T01:00:20+08:00","permalink":"https://example.com/p/%E9%BA%A6%E5%85%8B%E6%96%AF%E9%9F%A6%E7%94%B5%E7%A3%81%E7%90%86%E8%AE%BA%E4%B8%8E%E7%94%B5%E7%A3%81%E6%B3%A2/","title":"麦克斯韦电磁理论与电磁波"},{"content":"[toc]\n一、二元离散型随机变量 定义 设$X=X(e)$和$Y=Y(e)$是定义在$S$上的随机变量，由它们构成的向量$(X,Y)$叫做二元随机变量\n联合概率分布 定义 若二元随机变量的取值有限，则称$(X,Y)$是离散型随机变量\n概率分布律 $$ P(X=x_i,Y=y_j)=p_{ij},i,j=1,2\u0026hellip; $$\n性质 $p_{ij}\\ge 0$ $\\sum_{i=1}^\\infin\\sum_{j=1}^\\infin p_{ij}=1$ 边际分布 $$ P(Y=y_j)=P(X\\le+\\infin,Y=y_j)=\\sum_{i=1}^\\infin p_{ij}=p_{\\cdot j},j=1,2\u0026hellip;\\\\\\ \\\\ P(X=x_i)= P(X=x_i,Y\\le+\\infin)=\\sum_{j=1}^{+\\infin}p_{ij}=p_{i\\cdot},i=1,2\u0026hellip; $$\n条件分布 $$ P(X=x_i|Y=y_j)=\\frac{p_{ij}}{p_{\\cdot j}},i=1,2\u0026hellip; $$\n二、二元随机变量的分布函数 联合分布函数 定义 $$ F(x,y)=P(X\\le x,Y\\le y) $$\n性质 $F(x,y)$关于$x,y$单调不减\n$F(x,y)\\le 1,F(+\\infin,+\\infin)=1$\n$F(x,y)$关于$x,y$右连续\n若$x_1\\le x_2,y_1\\le y_2$,$F(x_2,y_2)-F(x_2,y_1)-F(x_1,y_2)+F(x_1,y_1)\\ge0$\n边缘分布函数 定义 二元随机变量$(X,Y)$中$X$和$Y$的分布函数$F_X(x),F_Y(y)$被称为边缘分布函数\n$$ F_X(x)=F(x,+\\infin)\\\\\\ \\\\ F_Y(y)=F(+\\infin,y) $$\n条件分布函数 $$ F_{X|Y}(x|y)=P(X\\le x|Y=y)=\\frac{P(X\\le x,Y=y)}{P(Y=y)} $$\n三、二元连续型随机变量 (联合)概率密度函数 定义 若对于为二元随机变量$(X,Y)$,若存在$f(x,y)$ $$ F(x,y)=\\int_{-\\infin}^y\\int_{-\\infin}^xf(u,v)dudv $$ 称$(X,Y)$为二元随机变量的联合概率密度函数 性质 $\\int_{-\\infin}^{\\infin}\\int_{-\\infin}^{+\\infin}f(x,y)dxdy=1$\n对于$f(x,y)$上的连续点有\n$$ \\frac{\\partial^2 F(x,y)}{\\partial x\\partial y}=f(x,y) $$\n边缘概率密度函数 定义 $$ f_X(x)=\\int_{-\\infin}^{+\\infin}f(x,y)dy\\\\\\ \\\\ f_Y(y)=\\int_{-\\infin}^{+\\infin}f(x,y)dx $$\n边缘分布函数 $$ F_X(x)=\\int_{-\\infin}^xf_X(u)du \\\\\\ \\\\ F_Y(y)=\\int_{-\\infin}^yf_Y(v)dv $$\n条件概率密度函数 定义 $$ f_{X|Y}(x,y)=\\frac{f(x,y)}{f_Y(y)}\\\\\\ \\\\ f_{Y|X}(x,y)=\\frac{f(x,y)}{f_X(x)} $$\n性质 $\\int_{-\\infin}^{+\\infin}f_{X|Y}(x,y)=1$\n$P(a\\lt X\\lt b|Y=y)=\\int_a^bf_{X|Y}(x,y)dx$\n$f(x,y)=f_{X|Y}(x|y)f(y)=f_{Y|X}(y|x)f(x)$\n二元均匀分布与二元正态分布 二元均匀分布 定义 $$ f(x,y)\\begin{cases} \\frac{1}{D的面积} \u0026amp; (x,y)\\in D\\\\ 0 \u0026amp; otherwise\\end{cases} $$\n性质 二元均匀分布的条件分布仍为均匀分布 二元均匀分布 $$ f(x,y)=\\frac{1}{2\\pi \\sigma_1\\sigma_2\\sqrt{1-\\rho^2}}\\cdot exp(\\frac{-1}{2(1-\\rho^2)}[\\frac{(x-\\mu_1)^2}{\\sigma_1^2}-2\\rho\\frac{(x-\\mu_1)(y-\\mu_2))}{\\sigma_1\\sigma_2}+\\frac{(y-\\mu_2)^2}{\\sigma_2^2}])\\\\\\ \\\\ x,y\\in R,-1\\lt \\rho\\lt 1, \\sigma_1\\gt 0,\\sigma_2\\gt 0 $$\n四、随机变量的独立性 定义 若对所有实数$x,y$，有$F(x,y)=F_X(x)F_Y(y)$,称随机变量$X,Y$相互独立\n分类 若为离散型随机变量 $$ X,Y相互独立\\Leftrightarrow p_{ij}=p_i\\cdot p_j对于一切i,j成立 $$\n若为连续型随机变量 $$ X,Y相互独立\\Leftrightarrow f(x,y)=f(x)f(y) $$\n五、二元随机变量的函数的分布 $Z=X+Y$分布函数 推导 $$ F_Z(z)=P(Z\\le z)=\\underset{x+y\\le z}\\iint f(x,y)dxdy\\\\\\ \\\\ = \\int_{-\\infin}^{+\\infin}[\\int_{-\\infin}^{z-y} f(x,y)dx]dy \\\\\\ \\\\ = \\int_{-\\infin}^{+\\infin}[\\int_{-\\infin}^zf(u-y,y)du]dy \\ (u=x+y) \\\\\\ \\\\ = \\int_{-\\infin}^z[\\int_{-\\infin}^{+\\infin}f(u-y,y)dy]du \\\\\\ \\\\ 又根据定义有: F_Z(z)=\\int_{-\\infin}^z f_Z(u)du\\\\\\ \\\\ \\therefore f_Z(z)=\\int_{-\\infin}^{+\\infin}f(z-y,y)dy \\\\\\ \\\\ f_Z(z)=\\int_{-\\infin}^{+\\infin}f(x,z-x)dx $$\n定义卷积公式 当$X$和$Y$独立时 $$ f_Z(z)=\\int_{-\\infin}^{+\\infin}f_X(z-y)f_Y(y)dy=\\int_{-\\infin}^{+\\infin}f_X(x)f_Y(z-x)dx $$\n","date":"2022-11-29T00:55:01+08:00","permalink":"https://example.com/p/%E5%A4%9A%E5%85%83%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/","title":"多元随机变量及其分布"},{"content":"[toc]\n一、随机变量 1.1 定义 设随机试验的样本空间为$S={e}$，若$X=X(e)$定义为S上的实值单值函数，则称$X=X(e)$为随机变量\n一般采用大写字母$X,Y,Z$表示随机变量\n引入随机变量是为了描述随机变量\n1.2 分类 一般的，若$I$是一个实数集合，则$X\\in I$为事件${e:X(e)\\in I}$\n离散型随机变量 连续型随机变量 二、离散型随机变量及其分布 2.1 定义 取值至多可数的随机变量称为离散型随机变量\n2.2 概率分布律 $X$ $x_1$ $x_2$ \u0026hellip; $x_n$ $P$ $p_1$ $p_2$ \u0026hellip; $p_n$ 2.3 性质 $p_i\\geq 0$\n$\\sum_{i=1}^np_i=1$\n2.4 几个重要的随机变量分布 2.4.1 0-1分布（两点分布） 若X的分布律为： $X$ $0$ $1$ $p$ $q$ $1-q$ 称$X ～ 0-1(P)$，或$B(1,p)$\n分布律还可以写成 $P(X=k)=p^k(1-p)^{1-k},k=0,1$ 2.4.2 二项分布 n重贝努利试验 设试验E只有两个可能的结果，将E独立、重复进行n次，称这一串独立重复试验为n重贝努利试验\n二项分布的定义 设$A$在$n$重贝努力试验中发生X次，称$X$服从参数为$n,p$的二项分布\n记为$X～B(n,p)$ 概率分布律 $$ P(X=k)=C_n^kp^k(1-p)^{n-k},k=0,1,\u0026hellip;n $$\n2.4.3 泊松分布 服从概率分布律为 $$ P(X=k)=\\frac{\\lambda^ke^{-\\lambda}}{k!},k=0,1,2\u0026hellip;,\\lambda\\ge0 $$\n的随机变量$X$服从参数为$\\lambda$的泊松分布 记为 $X～P(\\lambda)$ 泊松分布与二项分布 $$ 当n\\gt 10,p\\lt0.1时\\\\\\ \\\\ C_n^kp^k(1-p)^{1-k}\\approx \\frac{e^{\\lambda}\\lambda^k}{k!},\\lambda = np $$\n2.4.4 超几何分布 满足 $$ P(X=k)=\\frac{C_a^kC_b^{n-k}}{C_N^n},k=l_1,l_1+1\u0026hellip;l_2\\\\\\ \\\\ l_1=max(0,n-b),l_2=min(a,n) $$ 则称$X$服从超几何分布 记为$X～H(N,n,M)$,N是总数，n是样本量，M是A或B 2.4.5 几何分布 满足 $$ P(X=k)=p(1-p)^{1-k},k=1,2,3\u0026hellip;,0\\lt p\\lt 1 $$\n称$X$服从参数$p$的几何分布 记为$X～GE(p)$ 2.4.6 帕斯卡分布 定义 满足 $$ P(X=k)=C_{k-1}^{r-1}p^r(1-p)^{k-r},k=r,r+1\u0026hellip;,0\\lt p\\lt 1 $$\n称为帕斯卡分布 含义 每次试验成功概率为p,进行到成功r次为止的分布即位帕斯卡分布\n其中，几何分布是帕斯卡分布中$r=1$的特殊情况 三、随机变量的分布函数 3.1 定义 $X$为一随机变量，对任意实数$x$，函数$F(x)=P(X\\le x)$记为$X$的分布函数\n任何随机变量都有相应的分布函数 3.2 性质 $0\\le F(x)\\le 1$\n$F(x)$单调不减\n$F(-\\infin)=0，F(+\\infin)=1$\n$F(x)$右连续，即$F(x+0^+)=F(x)$\n$F(x)-F(x-0)=P(X=x)$\n四、连续型随机变量及其概率密度函数 4.1 定义 对于随机变量$X$的分布函数$F(X)$,若存在非负的函数$f(x)$，使对于任意实数$x$\n$$ F(x)=\\int_{-\\infin}^{\\infin}f(t)dt $$\n$X$为连续型随机变量 $f(x)$为概率密度函数($p.d.f$)，简称密度函数 4.2 $f(x)$的性质 $f(x)\\ge 0$\n$\\int_{-\\infin}^{+\\infin}f(x)dx=1$\n对于任意实数$x_1,x_2(x_2\\gt x_1)$ $$ P{x_1\\lt X\\lt x_2}=F(x_2)-F(x_1)=\\int_{x_1}^{x_2}f(t)dt $$\n$P(X=a)=0,a\\in R$\n在$f(x)$的连续点，$F\u0026rsquo;(x)=f(x)$\n4.3 几个重要的连续型随机变量分布 4.3.1 均匀分布 定义 满足 $$ f(x)=\\begin{cases}\\frac{1}{b-a} \u0026amp; x\\in(a,b)\\\\ 0 \u0026amp; otherwise\\end{cases} $$ 则称$X$在区间$(a,b)$上服从均匀分布，记为$X～(a,b)$ 性质 当在区间$(a,b)$时,概率只与横坐标长度有关，与横坐标位置无关\n分布函数\n$$ F(x)=\\begin{cases} 0 \u0026amp; x\\le a\\\\ \\frac{x-a}{b-a} \u0026amp; a\\le x \\le b \\\\ 1 \u0026amp; x \\ge b\\end{cases} $$\n4.3.2 正态分布（高斯分布） 定义 满足 $$ f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}, -\\infin \\lt x \\lt +\\infin, \\\\\\ \\\\ -\\infin \\lt \\mu \\lt +\\infin，\\sigma \\gt 0 $$\n称$X$服从参数为$\\mu,\\sigma$的正态分布 记为 $X～N(\\mu,\\sigma^2)$ 性质 $f(x)$关于$x=\\mu$对称\n$f_{max}=f(\\mu)=\\frac{1}{\\sqrt{2\\pi}\\sigma}$\n$\\underset{|x-\\mu|\\rightarrow\\infin}{lim}f(x)=0$\n独立的$n$个正态变量的线性组合仍然服从正态分布\n标准正态分布 推导 $$ 令t=\\frac{x-\\mu}{\\sigma}，dx=\\sigma dt\\\\\\ \\\\ f(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}},-\\infin\\lt t \\lt +\\infin \\\\\\ \\\\ $$\n上述概率密度函数记为标准正态分布\n$$ 密度函数\\varphi(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}\\\\\\ \\\\ 分布函数\\Phi(x)=\\int_{-\\infin}^x\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt\\\\\\ \\\\ 且\\pmb{\\Phi(x)+\\Phi(-x)=1} $$\n4.3.3 指数分布 定义 满足 $$ f(x)=\\begin{cases} \\lambda e^{-\\lambda x} \u0026amp;x\\gt 0 \\\\ 0 \u0026amp; x \\le 0 \\end{cases} $$\n的$X$服从参数为$\\lambda$的指数分布 记为$X～E(\\lambda)$ 性质 分布函数 $$ F(x)= \\begin{cases} 1 - e^{-\\lambda x} \u0026amp; x\\gt 0\\\\ 0 \u0026amp; x\\le 0\\end{cases} $$\n无记忆性 $$ For \\ t_0 \\gt 0,t\\gt 0\\\\\\ \\\\ P(X\\gt t_0+t|X\\gt t_0)=\\frac{P(X\\gt t_0+t)}{P(X\\gt t_0)}\\\\\\ \\\\ =\\frac{1-F(t_0+t)}{1-F(t_0)} = e^{-\\lambda t}=P(X\\gt t) $$\n五、随机变量函数的分布 5.1 定理1 设$X～f_X(x)，-\\infin \\lt x\\lt +\\infin，g\u0026rsquo;(x)\\neq 0. \\ Y=g(X)，x=h(y)$,则$Y$的概率密度函数为\n$$ f_Y(y)=\\begin{cases}f_x(h(y))\\cdot|h\u0026rsquo;(y)| \u0026amp; \\alpha \\lt x\\lt \\beta \\\\ 0 \u0026amp; otherwise\\end{cases} $$\n5.2 定理2 一般的，若$X～N(\\mu,\\sigma^2)，Y=aX+b\\Rightarrow Y～ N(a\\mu+b,a^2\\sigma^2)$\n六、总结 对于$F(x)$,概率是函数值；对于$f(x)$，概率是面积\n概率为1不一定是必然事件,概率为0不一定是不可能事件,积事件为0不一定为互斥事件\n无记忆性说明在结束之前，变量$X$始终服从指数分布\n","date":"2022-11-28T23:12:50+08:00","permalink":"https://example.com/p/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/","title":"随机变量及其分布"},{"content":"[toc]\n一、样本空间 随机事件 1.1 随机试验 可重复 结果的可能性已知 结果未知 1.2 样本空间 定义 随机试验E的所有结果构成的集合称为E的样本空间，记为$S={e}$\n$e$被称为样本点 一个元素的单点集称为基本事件 1.3 随机事件 定义 我们称$S$的子集$A$为$E$的随机事件$A$,简称事件$A$,当且仅当$A$所包含一个样本点发生，称事件$A$发生\n特征 A是相应的样本空间S的一个子集 当且仅当A的一个样本的出现A才发生 事件的分类 基本事件 由一个样本点组成的单点集 必然事件 每次试验S总是发生，则S被称为必然事件 不可能事件 空集$\\Phi$为不可能事件 事件的关系与运算 $$ \\pmb{包含关系}\\\\\\ \\\\ A \\subset B: A发生\\Rightarrow B一定发生\\\\\\ \\\\ \\begin{cases} A\\subset B\\\\ B\\subset A \\end{cases} \\Rightarrow A = B\\\\\\ \\\\ \\pmb{积事件与和事件}\\\\\\ \\\\ 和事件:\\bigcup^n_{i=1}A_i: A_i中至少有一个发生\\\\\\ \\\\ 积事件: \\bigcap_{i=1}^nA_i:A_i同时发生\\\\\\ \\\\ A\\bigcap B可以简写成AB,以此类推\\\\\\ \\\\ \\pmb{互斥事件/互不相容}\\\\\\ \\\\ 当AB=\\phi时，A,B互斥\\\\\\ \\\\ \\pmb{逆事件/对立事件}\\overline A\\\\\\ \\\\ 记\\overline A为A的逆事件,有\\begin{cases} A\\bigcup \\overline A =S \\\\ A\\overline A = \\phi \\end{cases}\\\\\\ \\\\ 上述定理 的逆定理也成立\\\\\\ \\\\ \\pmb{差事件} \\\\\\ \\\\ A\\overline B = A - B \\Leftrightarrow {x|x\\in A ,x\\notin B}\\\\\\ $$\n和、积关系式 —— 德摩根定律 $$ \\overline{\\bigcap_{i=1}^n A_i}=\\bigcup_{i=1}^n\\overline {A_i}=\\overline {A_1}\\bigcup \\overline {A_2}\u0026hellip;\\overline {A_n}\\\\\\ \\\\ \\overline{\\bigcup_{i=1}^n A_i} = \\bigcap_{i=1}^n \\overline{A_i}= \\overline{A_1} \\ \\overline{A_2}\u0026hellip;\\overline{A_n}\\\\\\ \\\\ $$\n二、频率与概率 2.1 频率 2.1.1 定义 $$ f_n(A)=\\frac{n_A}{n} $$\n$n_A$为事件出现的次数 n为试验的总次数 2.1.2 性质 $0\\leq f_n(A)\\leq 1$\n$f_n(S) = 1$\n若$A_1,A_2\u0026hellip;A_n$两两互斥,则$f_n(\\bigcup_{i=1}^k A_i) = \\sum_{i=1}^kf_n(A_i)$\n$f_n(A)$随n的增大稳定，稳定值记为p\n2.2 概率 2.2.1 定义 非负, $P(A)\\ge 0$\n规范, $P(S)=1$\n可列可加性\n若$A_1,A_2\u0026hellip;A_n$两两互斥,则$P(\\bigcup_{i=1}^k A_i) = \\sum_{i=1}^kP(A_i)$ 2.2.2 性质 $P(\\phi)=0$\n若$A_1,A_2\u0026hellip;A_n$两两互斥,则$P(\\bigcup_{i=1}^k A_i) = \\sum_{i=1}^kP(A_i)$\n$P(A)=1-P(\\overline A)$\n概率的减法公式\n$$ 若A\\subset B，则P(B-A)=P(B)-P(A) \\Rightarrow P(B) \\gt P(A)\\\\\\ \\\\ 一般情况下,P(B-A)= P(B)-P(AB) $$\n概率的加法公式 $$ 对于两个事件A和B\\\\\\ \\\\ P(A\\bigcup B) =P(A)+P(B)-P(AB)\\\\\\ \\\\ 对于三个事件A,B,C\\\\\\ \\\\ P(A\\bigcup B\\bigcup C) = P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)\\\\\\ \\\\ 一般情况\\\\\\ \\\\ P(\\bigcup_{i=1}^n A_i)=\\sum_{i=1}^nP(A_i)-\\underset{1\\leq i\\lt j\\leq n}\\sum P(A_iA_j)+\u0026hellip;+(-1)^{n-1}P(A_1 A_2\u0026hellip; A_n) $$\n三、等可能概型(古典概型) 3.1 定义 满足 S中样本点有限,出现每一样本点的概率相同的试验被称为等可能概型\n等可能性 有限性 四、条件概率 4.1 定义 $$ P(B|A)=\\frac{P(AB)}{P(A)},P(A)\\neq 0 $$\n4.2 性质 $$ P(B|A)具有概率所具有的性质\\\\\\ \\\\ 乘法公式\\\\\\ \\\\ P(AB) = P(A)\\cdot P(B|A)=P(B)\\cdot P(A|B)\\\\\\ \\\\ P(ABC) = P(A)P(B|A)P(C|AB)\\\\\\ \\\\ P(A_1 A_2 \u0026hellip;A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\u0026hellip;P(A_n|A_1A_2 \u0026hellip; A_{n-1}) $$\n4.3 全概率公式与Bayes公式 划分 不漏: $B_1\\bigcup B_2\u0026hellip;\\bigcup B_n= S$ 不重: $B_i B_j= \\phi,i\\neq j$ 则称$B_1,B_2\u0026hellip;B_n$为S的一个划分\n全概率公式 $$ P(A)=\\sum_{i=1}^nP(B_j)\\cdot P(A|B_j) $$\nBayes公式 $$ P(B_i|A)=\\frac{P(B_i)P(A|B_i)}{\\sum_{i=1}^nP(B_j)\\cdot P(A|B_j)}=\\frac{P(AB_i)}{P(A)} $$\n五、事件独立性与独立试验 5.1 独立事件 定义 若$P(AB)=P(A)P(B)$，则A与B相互独立\n性质 $$ 对于独立事件A,B\\\\\\ \\\\ P(A|B)=P(A),P(B|A)=P(B) $$\n注意 两两独立不等于相互独立 实际问题可以根据事情情况检验独立性 在大量重复实验中，小概率事件必然发生 六、总结 样本空间$S={e}$是集合 ","date":"2022-11-28T05:08:00+08:00","permalink":"https://example.com/p/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"基本概念"},{"content":"[toc]\n一、基尔霍夫定理 1.1 基尔霍夫电流定律 定义 在电路中，任何节点上的所有电流的代数和为0\n其中，基尔霍夫电流方程被称为KCL方程 1.2 基尔霍夫电压定律 定义 在电路中，环绕任何闭合路径的电压为0\n1.3 应用 1.3.1 含源受控电路的分析 二、常见的特殊电路 2.1 惠斯通电桥 图示\n推导 $$ KCL\\begin{cases}i_1=i_3 \\\\ i_2=i_x\\end{cases} \\\\\\ \\\\ KVL\\begin{cases} i_1R_1=i_2R_2\\\\ i_3R_3=i_xR_x\\end{cases}\\\\\\ \\\\ \\Rightarrow R_1R_x=R_2R_3\\Leftrightarrow R_x=\\frac{R_2}{R_1}R_3 $$\n2.2 $\\Delta - Y(\\pi-T)$等效电路 $\\Delta$与$\\pi$结构的转换 $Y$和$T$的转换 $\\Delta-Y$变换\n图示 公式\n$$ 通过串并联的简单计算可以得到\\\\\\ \\\\ R_1=\\frac{R_bR_c}{R_a+R_b+R_C} \\\\\\ \\\\ R_2=\\frac{R_aR_c}{R_a+R_b+R_C} \\\\\\ \\\\ R_3=\\frac{R_aR_b}{R_a+R_b+R_C} \\\\\\ \\\\ 反过来\\\\\\ \\\\ R_a=\\frac{R_1R_2+R_2R_3+R_1R_3}{R_1}\\\\\\ \\\\ R_b=\\frac{R_1R_2+R_2R_3+R_1R_3}{R_2} \\\\\\ \\\\ R_c=\\frac{R_1R_2+R_2R_3+R_1R_3}{R_3} $$\n","date":"2022-11-27T06:07:17+08:00","permalink":"https://example.com/p/%E7%94%B5%E9%98%BB%E5%85%83%E4%BB%B6%E4%B8%8E%E7%AE%80%E5%8D%95%E7%94%B5%E9%98%BB%E7%94%B5%E8%B7%AF/","title":"电阻元件与简单电阻电路"},{"content":"一、RMS (Python) 1. 执行步骤 I/O交互: 输入执行实际时间和任务周期 根据优先级对任务分类 找到周期的最小公约数lcm 分别记录一个lcm内每个任务的 总执行时间 开始执行时间(到达时间) 将每个任根据优先级放在时间表中 输入执行实际时间和任务周期 2. 说明 lcm和hyperperiod在此代码中均指所有任务周期的最小公约数 代码 以下代码来自https://github.com/rragesh/RateMonotonic_Scheduler\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #!/usr/bin/env python3 # ------------------------------------------ # RM_scheduling.py: Rate Monotonic Scheduler # Author: Ragesh RAMACHANDRAN # ------------------------------------------ import json import copy from sys import * from math import gcd from collections import OrderedDict import matplotlib.pyplot as plt import numpy as np import statistics as st from collections import defaultdict tasks = dict() RealTime_task = dict() metrics = defaultdict(dict) d = dict() dList = [] T = [] C = [] U = [] # For gantt chart y_axis = [] from_x = [] to_x = [] def Read_data(): \u0026#34;\u0026#34;\u0026#34; Reading the details of the tasks to be scheduled from the user as Number of tasks n: Period of task P: Worst case excecution time WCET: \u0026#34;\u0026#34;\u0026#34; global n global hp global tasks global dList dList = {} n = int(input(\u0026#34;\\n \\t\\tEnter number of Tasks:\u0026#34;)) # Storing data in a dictionary for i in range(n): dList[\u0026#34;TASK_%d\u0026#34;%i] = {\u0026#34;start\u0026#34;:[],\u0026#34;finish\u0026#34;:[]} dList[\u0026#34;TASK_IDLE\u0026#34;] = {\u0026#34;start\u0026#34;:[],\u0026#34;finish\u0026#34;:[]} for i in range(n): tasks[i] = {} print(\u0026#34;\\n\\n\\n Enter Period of task T\u0026#34;,i,\u0026#34;:\u0026#34;) p = input() tasks[i][\u0026#34;Period\u0026#34;] = int(p) print(\u0026#34;Enter the WCET of task C\u0026#34;,i,\u0026#34;:\u0026#34;) w = input() tasks[i][\u0026#34;WCET\u0026#34;] = int(w) # Writing the dictionary into a JSON file with open(\u0026#39;tasks.json\u0026#39;,\u0026#39;w\u0026#39;) as outfile: json.dump(tasks,outfile,indent = 4) def Hyperperiod(): \u0026#34;\u0026#34;\u0026#34; Calculates the hyper period of the tasks to be scheduled \u0026#34;\u0026#34;\u0026#34; temp = [] for i in range(n): temp.append(tasks[i][\u0026#34;Period\u0026#34;]) HP = temp[0] for i in temp[1:]: HP = HP*i//gcd(HP, i) print (\u0026#34;\\n Hyperperiod:\u0026#34;,HP) return HP def Schedulablity(): \u0026#34;\u0026#34;\u0026#34; Calculates the utilization factor of the tasks to be scheduled and then checks for the schedulablity and then returns true is schedulable else false. \u0026#34;\u0026#34;\u0026#34; for i in range(n): T.append(int(tasks[i][\u0026#34;Period\u0026#34;])) C.append(int(tasks[i][\u0026#34;WCET\u0026#34;])) u = int(C[i])/int(T[i]) U.append(u) U_factor = sum(U) if U_factor\u0026lt;=1: print(\u0026#34;\\nUtilization factor: \u0026#34;,U_factor, \u0026#34;underloaded tasks\u0026#34;) sched_util = n*(2**(1/n)-1) print(\u0026#34;Checking condition: \u0026#34;,sched_util) count = 0 T.sort() for i in range(len(T)): if T[i]%T[0] == 0: count = count + 1 # Checking the schedulablity condition if U_factor \u0026lt;= sched_util or count == len(T): print(\u0026#34;\\n\\tTasks are schedulable by Rate Monotonic Scheduling!\u0026#34;) return True else: print(\u0026#34;\\n\\tTasks are not schedulable by Rate Monotonic Scheduling!\u0026#34;) return False print(\u0026#34;\\n\\tOverloaded tasks!\u0026#34;) print(\u0026#34;\\n\\tUtilization factor \u0026gt; 1\u0026#34;) return False def estimatePriority(RealTime_task): \u0026#34;\u0026#34;\u0026#34; Estimates the priority of tasks at each real time period during scheduling \u0026#34;\u0026#34;\u0026#34; tempPeriod = hp P = -1 #Returns -1 for idle tasks for i in RealTime_task.keys(): if (RealTime_task[i][\u0026#34;WCET\u0026#34;] != 0): if (tempPeriod \u0026gt; RealTime_task[i][\u0026#34;Period\u0026#34;] or tempPeriod \u0026gt; tasks[i][\u0026#34;Period\u0026#34;]): tempPeriod = tasks[i][\u0026#34;Period\u0026#34;] #Checks the priority of each task based on period P = i return P def Simulation(hp): \u0026#34;\u0026#34;\u0026#34; The real time schedulng based on Rate Monotonic scheduling is simulated here. \u0026#34;\u0026#34;\u0026#34; # Real time scheduling are carried out in RealTime_task global RealTime_task RealTime_task = copy.deepcopy(tasks) # validation of schedulablity neessary condition for i in RealTime_task.keys(): RealTime_task[i][\u0026#34;DCT\u0026#34;] = RealTime_task[i][\u0026#34;WCET\u0026#34;] if (RealTime_task[i][\u0026#34;WCET\u0026#34;] \u0026gt; RealTime_task[i][\u0026#34;Period\u0026#34;]): print(\u0026#34; \\n\\t The task can not be completed in the specified time ! \u0026#34;, i ) # main loop for simulator for t in range(hp): # Determine the priority of the given tasks priority = estimatePriority(RealTime_task) if (priority != -1): #processor is not idle print(\u0026#34;\\nt{}--\u0026gt;t{} :TASK{}\u0026#34;.format(t,t+1,priority)) # Update WCET after each clock cycle RealTime_task[priority][\u0026#34;WCET\u0026#34;] -= 1 # For the calculation of the metrics dList[\u0026#34;TASK_%d\u0026#34;%priority][\u0026#34;start\u0026#34;].append(t) dList[\u0026#34;TASK_%d\u0026#34;%priority][\u0026#34;finish\u0026#34;].append(t+1) # For plotting the results y_axis.append(\u0026#34;TASK%d\u0026#34;%priority) from_x.append(t) to_x.append(t+1) else: #processor is idle print(\u0026#34;\\nt{}--\u0026gt;t{} :IDLE\u0026#34;.format(t,t+1)) # For the calculation of the metrics dList[\u0026#34;TASK_IDLE\u0026#34;][\u0026#34;start\u0026#34;].append(t) dList[\u0026#34;TASK_IDLE\u0026#34;][\u0026#34;finish\u0026#34;].append(t+1) # For plotting the results y_axis.append(\u0026#34;IDLE\u0026#34;) from_x.append(t) to_x.append(t+1) # Update Period after each clock cycle for i in RealTime_task.keys(): RealTime_task[i][\u0026#34;Period\u0026#34;] -= 1 if (RealTime_task[i][\u0026#34;Period\u0026#34;] == 0): RealTime_task[i] = copy.deepcopy(tasks[i]) with open(\u0026#39;RM_sched.json\u0026#39;,\u0026#39;w\u0026#39;) as outfile2: json.dump(dList,outfile2,indent = 4) def drawGantt(): \u0026#34;\u0026#34;\u0026#34; The scheduled results are displayed in the form of a gantt chart for the user to get better understanding \u0026#34;\u0026#34;\u0026#34; colors = [\u0026#39;red\u0026#39;,\u0026#39;green\u0026#39;,\u0026#39;blue\u0026#39;,\u0026#39;orange\u0026#39;,\u0026#39;yellow\u0026#39;] fig = plt.figure() ax = fig.add_subplot(111) # the data is plotted from_x to to_x along y_axis ax = plt.hlines(y_axis, from_x, to_x, linewidth=20, color = colors[n-1]) plt.title(\u0026#39;Rate Monotonic scheduling\u0026#39;) plt.grid(True) plt.xlabel(\u0026#34;Real-Time clock\u0026#34;) plt.ylabel(\u0026#34;HIGH------------------Priority---------------------\u0026gt;LOW\u0026#34;) plt.xticks(np.arange(min(from_x), max(to_x)+1, 1.0)) plt.show() def showMetrics(): \u0026#34;\u0026#34;\u0026#34; Displays the resultant metrics after scheduling such as average response time, the average waiting time and the time of first deadline miss \u0026#34;\u0026#34;\u0026#34; N = [] startTime = [] releaseTime = [] finishTime = [] avg_respTime = [] avg_waitTime = [] # Calculation of number of releases and release time for i in tasks.keys(): release =int(hp)/int(tasks[i][\u0026#34;Period\u0026#34;]) N.append(release) temp = [] for j in range(int(N[i])): temp.append(j*int(tasks[i][\u0026#34;Period\u0026#34;])) # temp.append(hp) releaseTime.append(temp)\t# Calculation of start time of each task for j,i in enumerate(tasks.keys()): start_array,end_array = filter_out(dList[\u0026#34;TASK_%d\u0026#34;%i][\u0026#34;start\u0026#34;],dList[\u0026#34;TASK_%d\u0026#34;%i][\u0026#34;finish\u0026#34;],N[j]) startTime.append(start_array) finishTime.append(end_array) # Calculation of average waiting time and average response time of tasks for i in tasks.keys(): avg_waitTime.append(st.mean([a_i - b_i for a_i, b_i in zip(startTime[i],releaseTime[i])])) avg_respTime.append(st.mean([a_i - b_i for a_i, b_i in zip(finishTime[i],releaseTime[i])])) # Printing the resultant metrics for i in tasks.keys(): metrics[i][\u0026#34;Releases\u0026#34;] = N[i] metrics[i][\u0026#34;Period\u0026#34;] = tasks[i][\u0026#34;Period\u0026#34;] metrics[i][\u0026#34;WCET\u0026#34;] = tasks[i][\u0026#34;WCET\u0026#34;] metrics[i][\u0026#34;AvgRespTime\u0026#34;] = avg_respTime[i] metrics[i][\u0026#34;AvgWaitTime\u0026#34;] = avg_waitTime[i] print(\u0026#34;\\n Number of releases of task %d =\u0026#34;%i,int(N[i])) print(\u0026#34;\\n Release time of task%d = \u0026#34;%i,releaseTime[i]) print(\u0026#34;\\n start time of task %d = \u0026#34;%i,startTime[i]) print(\u0026#34;\\n finish time of task %d = \u0026#34;%i,finishTime[i]) print(\u0026#34;\\n Average Response time of task %d = \u0026#34;%i,avg_respTime[i]) print(\u0026#34;\\n Average Waiting time of task %d = \u0026#34;%i,avg_waitTime[i]) print(\u0026#34;\\n\u0026#34;) # Storing results into a JSON file with open(\u0026#39;Metrics.json\u0026#39;,\u0026#39;w\u0026#39;) as f: json.dump(metrics,f,indent = 4) print(\u0026#34;\\n\\n\\t\\tScheduling of %d tasks completed succesfully....\u0026#34;%n) def filter_out(start_array,finish_array,release_time): \u0026#34;\u0026#34;\u0026#34;A filtering function created to create the required data struture from the simulation results\u0026#34;\u0026#34;\u0026#34; new_start = [] new_finish = [] beg_time = min(start_array) diff = int(hp/release_time) # Calculation of finish time and start time from simulation results if(release_time\u0026gt;1): new_start.append(beg_time) prev = beg_time for i in range(int(release_time-1)): beg_time = beg_time + diff new_start.append(beg_time) count = start_array.index(prev) for i in range(start_array.index(prev),start_array.index(beg_time)-1): count+=1 new_finish.append(finish_array[count]) prev = beg_time new_finish.append(max(finish_array)) else: end_time = max(finish_array) new_start.append(beg_time) new_finish.append(int(end_time)) return new_start,new_finish if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;\\n\\n\\t\\t_RATE MONOTONIC SCHEDULER_\\n\u0026#34;) Read_data() sched_res = Schedulablity() if sched_res == True: hp = Hyperperiod() Simulation(hp) showMetrics() drawGantt() else: Read_data() sched_res = Schedulablity() 二、EDF Code in C 1. 思路 先算出所有周期的最小公约数T 先选择截止时间最早的任务A作为当前处理任务 判断A是否在当前周期T内: 若不在，就根据截止时间选择其他任务 若其他任务都无法在当前周期T的剩余时间内完成（即，截止时间$\\lt$周期内的剩余时间 ）,则选择截止时间最短的运行到周期结束 注意，由于该模型中的任务不可再分割，不可抢占，所以我们应对传统EDF模型进行更改，使得在该情况下,不继续执行任务\n在下一个周期开始后，循环上述 2、3步骤 2. 说明 该思路中的优先级以截止时间衡量 3. 代码 更多代码和库请见 https://github.com/elzoughby/EDF-scheduling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include \u0026#34;heapSort.c\u0026#34; void arrayPrint(int*, int); int lcm(int* ar, int m); void arrayPrint(int* arr, int n) { for(int i=0; i\u0026lt;n; i++) { printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); } int lcm(int* ar, int m)\t{ int res = ar[0]; int a,b; for(int i=1; i\u0026lt;m; i++) { if(res\u0026gt;ar[i]) { b= res; a= ar[i]; } else { b = ar[i]; a = res; } int r=1; while(r\u0026gt;0) { r = b%a; b = a; a = r; } res = (ar[i]*res)/b; } return res; } int main(int argc, char **argv) { int m = 3; int arr[3][4] = {{3,20,7,0},{2,5,4,0},{2,10,9,0}}; int* exec = (int*)(malloc(sizeof(int)*m)); int* period = (int*)(malloc(sizeof(int)*m)); int* deadline = (int*)(malloc(sizeof(int)*m)); int* arrival = (int*)(malloc(sizeof(int)*m)); int* rdl = (int*)(malloc(sizeof(int)*m)); int* offset = (int*)(malloc(sizeof(int)*m)); int* rexec = (int*)(malloc(sizeof(int)*m)); int* index = (int*)(malloc(sizeof(int)*m)); for(int i=0; i\u0026lt;m; i++)\t{ exec[i] = arr[i][0]; rexec[i] = arr[i][0]; period[i] = arr[i][1]; deadline[i] = arr[i][2]; offset[i] = arr[i][3]; arrival[i] = arr[i][3]; rdl[i] = arr[i][3] + arr[i][2]; } int lcmm = lcm(period,m); int* heapdead = (int*)(malloc(sizeof(int)*lcmm*m)); int* heapindex = (int*)(malloc(sizeof(int)*lcmm*m)); int** e = (int**)(malloc(sizeof(int)*m)); int** plote = (int**)(malloc(sizeof(int)*m)); for(int i=0; i\u0026lt;m; i++)\t{ e[i] = (int*)(malloc(sizeof(int)*lcmm)); plote[i] = (int*)(malloc(sizeof(int)*lcmm*100)); } int value; int indexterm; int heapsize = 0; for(int i=0; i\u0026lt;lcmm; i++) {\tfor(int j=0; j\u0026lt;m; j++)\t{ e[j][i] = 0; for(int k=0; k\u0026lt;100; k++) plote[j][i*100+k] = 0; if(arrival[j] == i)\t{ rdl[j] = deadline[j] + i; minHeapPush(heapdead, heapindex, \u0026amp;heapsize, rdl[j], j ); arrival[j] += period[j]; rexec[j] = exec[j]; } } if(heapsize \u0026gt; 0)\t{\tminHeapPop(heapdead,heapindex,\u0026amp;value,\u0026amp;indexterm,\u0026amp;heapsize); printf(\u0026#34;%d \u0026#34;,indexterm+1); e[indexterm][i] = 1; for(int k=0; k\u0026lt;100; k++) plote[indexterm][i*100+k] = 1; if(value\u0026gt;i) { rexec[indexterm]--; if(rexec[indexterm]\u0026gt;0)\t{ minHeapPush(heapdead, heapindex, \u0026amp;heapsize, value, indexterm ); } } } else { printf(\u0026#34;0 \u0026#34;); } } printf(\u0026#34;\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ arrayPrint(e[i],lcmm); } FILE *filePtr; filePtr = fopen(\u0026#34;polar.dat\u0026#34;,\u0026#34;w\u0026#34;); for(int i=0; i\u0026lt;lcmm*100; i++) { //fprintf(filePtr, \u0026#34;%d\\t\u0026#34;, j); //for(int i=0; i\u0026lt;3; i++)\t{\tfprintf(filePtr, \u0026#34;%d\\t%d\\t%d\\t%d\\n\u0026#34;,i, plote[0][i], plote[1][i], plote[2][i]); //} //fprintf(filePtr, \u0026#34;\\n\u0026#34;); } /* for(int i=0; i\u0026lt;m; i++)\t{ for(int j=0; j\u0026lt;lcmm; j++)\t{ printf(\u0026#34;%d\\t\u0026#34;,plote[i][j]); } printf(\u0026#34;\\n\u0026#34;); } */ return 0;\t} /*minHeapBuild(deadline,index,m); minHeapPop(deadline,index,\u0026amp;value,\u0026amp;indexterm,\u0026amp;m); printf(\u0026#34;%d %d\\n\u0026#34;,value,indexterm); minHeapPop(deadline,index,\u0026amp;value,\u0026amp;indexterm,\u0026amp;m); printf(\u0026#34;%d %d\\n\u0026#34;,value,indexterm); minHeapPop(deadline,index,\u0026amp;value,\u0026amp;indexterm,\u0026amp;m); printf(\u0026#34;%d %d\\n\u0026#34;,value,indexterm); minHeapPush(deadline, index, \u0026amp;m, 10, 2); minHeapPush(deadline, index, \u0026amp;m, 8, 3); minHeapPush(deadline, index, \u0026amp;m, 7, 9); arrayPrint(deadline,m); arrayPrint(index,m);*/ MLFQ-Scheduler 1. 操作系统调度中的规则 优先级高的先执行 优先级相同的轮转运行 工作进入系统时，将其放在最高优先级 工作用完其时间片后，降低其优先级 经过一段时间S,就降低其优先级 2. 在该模型中 由于该模型不可抢占，我们需要对规则进行改变\npulse width短的任务优先级更高 优先级高的先执 优先级相同的随机选择运行顺序 增加的任务，将其放在最高优先级 规定每个任务拥有相同的时间配额，一旦每个任务的时间配额用完，就降低其优先级 先删除优先级最低的任务 3. 代码 更多代码请见https://github.com/shreyaakamath/Xv6-MLFQ-Scheduler/tree/master/xv6\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 // ConsoleApplication1.cpp : Defines the entry point for the console application. // // data_structs_3.cpp : Defines the entry point for the console application. //COPY FOR EXPERIMENTATION #include \u0026#34;stdafx.h\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; //Data initialization struct process_data { int wait; int pxs; int arrive; int jind; int resp; int TT; int queue; bool IO; int a, b, c, d, e, f, g, h, i, j, k, l, m, n, O, p, q; int datas[17] = { a,b,c,d,e,f,g,h,i,j,k,l,m,n, O,p,q }; }; struct slinklist { process_data data; struct slinklist * next; }; typedef struct slinklist node; node * start = NULL; node *getnode(int px[], int pxs)//Creates newnode with predetermined input { node *newnode; newnode = (node*)malloc(sizeof(node)); newnode-\u0026gt;data.wait = 0; newnode-\u0026gt;data.arrive = 0; newnode-\u0026gt;data.jind = 0; newnode-\u0026gt;data.resp = 0; newnode-\u0026gt;data.TT = 0; newnode-\u0026gt;data.pxs = pxs; newnode-\u0026gt;data.queue = 1; newnode-\u0026gt;data.IO = false; for (int j = 0; j \u0026lt; 17; j++) newnode-\u0026gt;data.datas[j] = 0; for (int j = 0; j \u0026lt; pxs; j++) newnode-\u0026gt;data.datas[j] = px[j]; newnode-\u0026gt;next = NULL; return newnode; } void create_s_list(int n, int P0[8], int p1[13], int p2[17], int p3[17], int p4[15], int p5[17], int p6[17], int p7[15], int p8[17], int p1s, int p2s, int p3s, int p4s, int p5s, int p6s, int p7s, int p8s)//Creates n number of nodes for a Single Linked List { int i; node *newnode; node *temp; int *P1[] = { p1, p2, p3, p4, p5, p6, p7, p8 };//array of arrays int P2[] = { p1s,p2s,p3s,p4s,p5s,p6s,p7s,p8s };//size of arrays for (i = 0; i \u0026lt; n; i++) { newnode = getnode(P1[i], P2[i]); if (start == NULL) { start = newnode; } else { temp = start; while (temp-\u0026gt;next != NULL) temp = temp-\u0026gt;next; temp-\u0026gt;next = newnode; } } } //Performs Round Robin Scheduling with TQ = 6; Displays Context Switch Info void queue1_Sch(int \u0026amp;time) { node *temp; int minarrive;//arrival time of soonest queue 1 process int minIndex = 0;//index of soonest queue 1 process bool Onearrived;//indicates if a queue 1 process has arrived while (true) { temp = start; Onearrived = false; minarrive = INT_MAX; for (int i = 0; i \u0026lt; 8; i++)//gets index of Queue 1 process with soonest arrival time { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.queue ==1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive\u0026lt;=time) { minarrive = temp-\u0026gt;data.arrive; minIndex = i; Onearrived = true; } temp = temp-\u0026gt;next; } if (Onearrived == false)//if no queue 1 process has arrived break; int ctr = 1;//make temp point to process in execution temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } //Context Switch Information Displayed cout \u0026lt;\u0026lt; endl\u0026lt;\u0026lt; \u0026#34;Current Execution Time: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Process on CPU: P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;Ready Queue:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.IO == false)//if process is not in either IO or CPU execution { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Burst time:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } cout \u0026lt;\u0026lt; \u0026#34;Processes in I/O:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1)//If process is in IO and not in execution... { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; I/O time Remaining:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex)//Select Process in execution again-\u0026gt;index of node with lowest arrival time { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind == 0)//Response Time, jind gets either incremented from one pass in the loop, or process gets demoted to lower queue { temp-\u0026gt;data.resp = time; } temp-\u0026gt;data.wait += (time - temp-\u0026gt;data.arrive);//total waiting time is waiting time + (time(it just got on the cpu) minus the arrival time of process if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026gt; 6)//if burst is greater than 6 { time += 6;// incrementing time the length of TQ temp-\u0026gt;data.arrive = time; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= 6; temp-\u0026gt;data.queue = 2; temp-\u0026gt;data.IO = false;//process in not in IO in this case } else if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;= 6) { time += temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]; temp-\u0026gt;data.arrive = time + temp-\u0026gt;data.datas[temp-\u0026gt;data.jind + 1]; temp-\u0026gt;data.jind = temp-\u0026gt;data.jind + 2; temp-\u0026gt;data.IO = true;//Process in IO after finishing burst } ctr = 1;//deincrements IO times of processes currently in IO temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] -= 6; if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] \u0026lt;= 0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind \u0026gt; (temp-\u0026gt;data.pxs - 1))//if jind surpasses data, process is done { temp-\u0026gt;data.IO = false; temp-\u0026gt;data.arrive = -1; temp-\u0026gt;data.TT = time; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34; Process \u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Completed\u0026#34; \u0026lt;\u0026lt; endl; } } } //Performs Round Robin Scheduling TQ = 12 with preemption; Displays Context Switch Info void queue2_Sch(int \u0026amp;time) { node *temp; int minarrive; int minQ1arr = INT_MAX; //arrival time of soonest Q1 process int minIndex = 0; bool Twoarrived;//indicates if queue 2 process is in the ready queue int timecalc;//preserves time of execution temp = start; for (int i = 0; i \u0026lt; 8; i++)//Find arrival time of soonest Q1 process { if (temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.queue == 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt; minQ1arr) minQ1arr = temp-\u0026gt;data.arrive; temp = temp-\u0026gt;next; } while (true) { temp = start; Twoarrived = false; minarrive = INT_MAX; timecalc = time; temp = start; for (int i = 0; i \u0026lt; 8; i++)//gets index of Queue 2 process with soonest arrival time { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.queue == 2 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive\u0026lt;=time) { Twoarrived = true; minarrive = temp-\u0026gt;data.arrive; minIndex = i;//index of process with soonest arrival time } temp = temp-\u0026gt;next; } if (Twoarrived == false) return; int ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } //Context Switch Information Displayed cout \u0026lt;\u0026lt; endl\u0026lt;\u0026lt; \u0026#34;Current Execution Time: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Process on CPU: P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Ready Queue:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.IO == false) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Burst time:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } cout \u0026lt;\u0026lt; \u0026#34;Processes in I/O:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; I/O time Remaining:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } temp-\u0026gt;data.wait += (time - temp-\u0026gt;data.arrive);//total waiting time is waiting time + (time(it just got on the cpu) minus the arrival time of process if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026gt; 12)//if burst is greater than 12 { for (int i = 0; i \u0026lt; 12; i++) { time++; if (time \u0026gt;= minQ1arr)//if a Q1 process arrives break; } temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= (time - timecalc); temp-\u0026gt;data.arrive = time; if((time-timecalc)\u0026gt;=12) temp-\u0026gt;data.queue = 3; temp-\u0026gt;data.IO = false; } else if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;= 12)// If burst is less than the time quantum { for (int i = 0; i \u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]; i++) { time++; if (time \u0026gt;= minQ1arr)//if a Q1 process arrives break; } if ((time - timecalc) \u0026gt;= temp-\u0026gt;data.datas[temp-\u0026gt;data.jind])//if the burst was finished { temp-\u0026gt;data.arrive = time + temp-\u0026gt;data.datas[temp-\u0026gt;data.jind + 1]; temp-\u0026gt;data.jind = temp-\u0026gt;data.jind + 2; temp-\u0026gt;data.IO = true; } else //if the burst hasn\u0026#39;t finished { temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= (time - timecalc); temp-\u0026gt;data.arrive = time; temp-\u0026gt;data.IO = false; } } ctr = 1;//deincrement IO times of process in IO temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] -= (time - timecalc); if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1]\u0026lt;=0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind \u0026gt; (temp-\u0026gt;data.pxs - 1))//if jind surpasses data, process is done { temp-\u0026gt;data.IO = false; temp-\u0026gt;data.arrive = -1; temp-\u0026gt;data.TT = time; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34; Process \u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Completed\u0026#34; \u0026lt;\u0026lt; endl; } if (minQ1arr \u0026lt;= time)//If queue 1 process has arrived return to wait_tt function return; } } //Performs First Come First Serve Scheduling with preemption; Displays Context Switch Info void FCFS_Sch(int \u0026amp;time) { node *temp; int timecalc;//preserves time of execution int minarrive;//soonest arrival time int minIndex;//index of process with soonest arrival time int minQ12arr= INT_MAX;//soonest arrival time of higher priority process bool AnyArrived;//indicates if any process is in the ready queue temp = start; for (int i = 0; i \u0026lt; 8; i++)//Find arrival time of soonest Q1/2 process { if (temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt; minQ12arr \u0026amp;\u0026amp; temp-\u0026gt;data.queue !=3) minQ12arr = temp-\u0026gt;data.arrive; temp = temp-\u0026gt;next; } while (true) { timecalc = time; AnyArrived = false; minarrive = INT_MAX; temp = start; for (int i = 0; i \u0026lt; 8; i++) { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive\u0026lt;=time) { AnyArrived = true; minarrive = temp-\u0026gt;data.arrive; minIndex = i;//index of process with soonest arrival time } temp = temp-\u0026gt;next; } if (AnyArrived == false)//if no process in ready queue, return to wait_tt function return; int ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } //Context Switch Information Displayed cout \u0026lt;\u0026lt; endl\u0026lt;\u0026lt;\u0026#34;Current Execution Time: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Process on CPU: P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34;--\u0026gt;\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Ready Queue:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.IO ==false) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Burst time:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } cout \u0026lt;\u0026lt; \u0026#34;Processes in I/O:\u0026#34; \u0026lt;\u0026lt; endl; ctr = 1; temp = start; while (ctr \u0026lt;= 8) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1) { cout \u0026lt;\u0026lt; \u0026#34; P\u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; I/O time Remaining:\u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] \u0026lt;\u0026lt; endl; } temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } temp-\u0026gt;data.wait = temp-\u0026gt;data.wait + (time - temp-\u0026gt;data.arrive);//total waiting time is waiting time + (time(it just got on the cpu) minus the arrival time of process for (int i = 0; i \u0026lt; temp-\u0026gt;data.datas[temp-\u0026gt;data.jind]; i++) { time++; if (time \u0026gt;= minQ12arr)//if a Q1 or Q2 process arrives break; } if ((time - timecalc) \u0026gt;= temp-\u0026gt;data.datas[temp-\u0026gt;data.jind])//if CPU burst is not interrupted { temp-\u0026gt;data.arrive = time + temp-\u0026gt;data.datas[temp-\u0026gt;data.jind + 1];//new arrival time is newtime + IO temp-\u0026gt;data.jind = temp-\u0026gt;data.jind + 2; temp-\u0026gt;data.IO = true; } else//CPU burst is interrupted, deincrement process burst time { temp-\u0026gt;data.datas[temp-\u0026gt;data.jind] -= (time - timecalc); temp-\u0026gt;data.arrive = time; temp-\u0026gt;data.IO = false; } ctr = 1;//deincrement IO times of processes in IO temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO \u0026amp;\u0026amp; ctr != minIndex + 1) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] -= (time - timecalc); if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind-1] \u0026lt;= 0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; ctr++; } ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (temp-\u0026gt;data.jind \u0026gt; (temp-\u0026gt;data.pxs - 1))//Indicate if process is finished { temp-\u0026gt;data.IO = false; temp-\u0026gt;data.arrive = -1; temp-\u0026gt;data.TT = time; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34; Process \u0026#34; \u0026lt;\u0026lt; ctr \u0026lt;\u0026lt; \u0026#34; Completed\u0026#34; \u0026lt;\u0026lt; endl; } if (time \u0026gt;= minQ12arr)//if higher priority process arrives return to wait_tt function return; } } //Calculates the overall waiting time and turnaround time for each process, also shows when CPU is idle and for how long void wait_tt(int \u0026amp;time) { node *temp; //int time = 0; int minIndex = 0;//min index is the index of the current process int minarrive;//soonest arrival time int idle = 0;//indicate whether CPU is idle bool one;//indicates if queue 1 process is in ready queue bool two;//indicates if queue 2 process is in ready queue bool ready;//indicates if any process is in ready queue bool anyP;//indicates if any process is not finished while (true) { one = false; two = false; ready = false; anyP = false; temp = start; minarrive = INT_MAX; temp = start; for (int i = 0; i \u0026lt; 8; i++)//See if ready process in Queue 1 { if (temp-\u0026gt;data.queue == 1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt;= time) { one = true; break; } temp = temp-\u0026gt;next; } temp = start; for (int i = 0; i \u0026lt; 8; i++)//See if ready process in Queue 2 { if (temp-\u0026gt;data.queue == 2 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt;= time) { two = true; break; } temp = temp-\u0026gt;next; } temp = start; for (int i = 0; i \u0026lt; 8; i++)//See if any process in ready Queue { if (temp-\u0026gt;data.arrive != -1 \u0026amp;\u0026amp; temp-\u0026gt;data.arrive \u0026lt;= time) { ready = true; break; } temp = temp-\u0026gt;next; } temp = start; for (int i = 0; i \u0026lt; 8; i++)//gets arrival time of soonest process, see if any process is not finished { if (temp-\u0026gt;data.arrive \u0026lt; minarrive \u0026amp;\u0026amp; temp-\u0026gt;data.arrive != -1) { minarrive = temp-\u0026gt;data.arrive; minIndex = i;//index of process with soonest arrival time anyP = 1; } temp = temp-\u0026gt;next; } int ctr = 1; temp = start; while (ctr \u0026lt;= minIndex) { temp = temp-\u0026gt;next; ctr++; } if (anyP == false)//If all processes are finished return; if (one) queue1_Sch(time); else if (two) queue2_Sch(time); else if (ready) FCFS_Sch(time); else if(ready==false) {//increment time to soonest arrival time, indicate idleness, and deincrement IO times for the length of time spent idle temp-\u0026gt;data.IO = true; idle = minarrive - time; time = minarrive; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;\u0026#34;IDLE for \u0026#34; \u0026lt;\u0026lt; idle \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;endl; temp = start; while (temp != NULL) { if (temp-\u0026gt;data.IO) temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] -= idle; if (temp-\u0026gt;data.datas[temp-\u0026gt;data.jind - 1] \u0026lt;= 0) temp-\u0026gt;data.IO = false; temp = temp-\u0026gt;next; } } } } //Computes sum of Burst times for a process int SUM(int A[]) { int sum = 0; for (int i = 0; i \u0026lt; 17; i++) { if(i%2 == 0) sum += A[i]; } return sum; } //Computes average response time, waiting time, and turnaround time for each process void AVG(double \u0026amp;r, double \u0026amp;w, double \u0026amp;tt) { node*temp = start; while (temp != NULL) { r += temp-\u0026gt;data.resp; w += temp-\u0026gt;data.wait; tt += temp-\u0026gt;data.TT; temp = temp-\u0026gt;next; } r /= 8; w /= 8; tt /= 8; } //Computes sum of burst times of the set of all processes void total_sum(double\u0026amp; dTS) { node *temp; dTS = 0; temp = start; while (temp != NULL) { dTS += SUM(temp-\u0026gt;data.datas); temp = temp-\u0026gt;next; } } //Computes CPU utilization void CPU_UT(int time, double dTS, double \u0026amp;util) { util = ((dTS / time)*100); } //Prints the overall response time, waiting time, turnaround time for each process as well as their averages. Also prints CPU utilization and the time when all process are finished. void print(double r, double w, double tt,double util, int time) { cout \u0026lt;\u0026lt;endl\u0026lt;\u0026lt; \u0026#34;Resp \u0026#34; \u0026lt;\u0026lt; \u0026#34;wait \u0026#34; \u0026lt;\u0026lt; \u0026#34;TT\u0026#34; \u0026lt;\u0026lt; endl; node*temp = start; while (temp != NULL) { if (temp-\u0026gt;data.resp \u0026gt; 9 \u0026amp;\u0026amp; temp-\u0026gt;data.wait \u0026gt; 99) { cout \u0026lt;\u0026lt; temp-\u0026gt;data.resp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.wait \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.TT \u0026lt;\u0026lt; endl; temp = temp-\u0026gt;next; } else if (temp-\u0026gt;data.resp \u0026gt; 9 \u0026amp;\u0026amp; temp-\u0026gt;data.wait \u0026lt;= 99) { cout \u0026lt;\u0026lt; temp-\u0026gt;data.resp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.wait \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.TT \u0026lt;\u0026lt; endl; temp = temp-\u0026gt;next; } else { cout \u0026lt;\u0026lt; temp-\u0026gt;data.resp \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.wait \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; temp-\u0026gt;data.TT \u0026lt;\u0026lt; endl; temp = temp-\u0026gt;next; } } cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; tt \u0026lt;\u0026lt; \u0026#34;\u0026lt;---AVG\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;%CPU: \u0026#34; \u0026lt;\u0026lt; util \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;TimeOfCompletion: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;endl; } int main() { int time = 0; double dTS = 0;//Total Sum of all burst times as type double double util = 0; double avgr = 0, avgw = 0, avgtt = 0; int P0[8] = { 1, 2, 3, 4, 5, 6, 7, 8 }; int p1[13] = { 6, 17, 8, 19, 12, 31, 11, 18, 9, 22, 8, 26, 10 }; int p2[17] = { 19, 38, 11, 24, 15, 21, 12, 27, 12, 34, 11, 34, 9, 29, 9, 31, 7 }; int p3[17] = { 3, 37, 14, 41, 8, 30, 4, 19, 7, 33, 5, 18, 4, 26, 5, 31, 16 }; int p4[15] = { 15, 35, 14, 41, 16, 45, 18, 51, 14, 61, 13, 54, 16, 61, 15 }; int p5[17] = { 9, 24, 7, 21, 15, 31, 6, 26, 7, 31, 3, 18, 6, 21, 6, 33, 3 }; int p6[17] = { 4, 38, 3, 41, 5, 29, 4, 26, 7, 32, 4, 22, 3, 26, 5, 22, 8 }; int p7[15] = { 14, 36, 17, 31, 16, 32, 15, 41, 14, 42, 17, 39, 16, 33, 15 }; int p8[17] = { 5, 14, 4, 33, 6, 31, 4, 31, 6, 27, 5, 21, 4, 19, 6, 11, 6 }; create_s_list(8, P0, p1, p2, p3, p4, p5, p6, p7, p8, 13, 17, 17, 15, 17, 17, 15, 17);//a singly linked list where each node is a process from p1 to p8, each with all burst and IO times total_sum(dTS); wait_tt(time); CPU_UT(time, dTS, util); AVG(avgr, avgw, avgtt); print(avgr, avgw, avgtt, util, time); return 0; } ","date":"2022-11-27T02:14:03+08:00","permalink":"https://example.com/p/%E4%B8%89%E7%A7%8D%E8%B0%83%E5%BA%A6/","title":"三种调度"},{"content":"[toc]\n一、新建boot分区 1 fidsk -l 二、挂载分区 挂载根目录分区与开机分区 1 2 mount /dev/nvme0n1p6 /mnt mount /dev/nvme0n1p8 /mnt/boot 生成文件系统自动挂载分区(可删除先前的) 1 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 三、安装内核 1 2 arch-chroot /mnt pacman -S base linux linux-firmware 四、安装引导 安装徽码 1 $ pacman -S intel-ucode 安装引导 1 2 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch --recheck grub-mkconfig -o /boot/grub/grub.cfg 五、退出并重启 1 2 3 $ exit $ umount -R /mnt $ reboot ","date":"2022-11-26T23:40:49+08:00","permalink":"https://example.com/p/archlinux%E5%BC%80%E6%9C%BA%E5%88%86%E5%8C%BA%E5%AE%89%E8%A3%85/","title":"ArchLinux开机分区安装"},{"content":"[toc]\n一、电磁感应定律 1.1 法拉第电磁感应定律 $$ \\xi=-k\\frac{d\\phi}{dt}\\\\\\ \\\\ 当\\phi的单位为Wb,\\xi 的单位为V,k=1\\\\\\ \\\\ 当有多匝线圈时,\\xi=-N\\frac{d\\phi}{dt}\\\\\\ $$\n1.2 楞次定律 闭合回路中感应电流的方向总是使得它所激发的电场阻碍引起感应电流的磁通量的变化\n1.3 电磁阻尼 二、动生电动势和感生电动势 定义 动生电动势 恒磁场内导体运动所产生的电动势 感生电动势 导体不动，磁场变化产生的电动势 动生电动势 图示 推导 $$ \\\\ 自由电子受到的力\\pmb F=-e(\\pmb{v\\times B})\\\\\\ \\\\ 单位正电荷的非静电“力”\\pmb K=\\frac{\\pmb F}{-e}=\\pmb{v\\times B}\\\\\\ \\\\ \\xi = \\int_C^D\\pmb K\\cdot d\\pmb l=\\int_C^D (\\pmb{v\\times B})d\\pmb l\\\\\\ \\\\ \\xi = \\int vBdl\\ $$\n交流发电机原理 图示 推导 $$ \\\\ 设AB长为l,CD长为s\\\\\\ \\\\ \\xi_{AB} = \\xi_{CD} = \\int_A^B(\\pmb{v\\times B})d\\pmb l=vBlcos\\theta\\\\\\ \\\\ \\xi = 2\\xi_{AB} = 2vBlcos\\theta\\\\\\ \\\\ \\theta = \\omega t, v = \\frac{s}{2}\\omega\\\\\\ \\\\ \\pmb{\\xi =\\omega BS cos\\omega t}\\ $$\n感生电动势和涡旋电场 $$ \\\\ \\xi = \\int\\pmb K\\cdot d\\pmb l\\\\\\ \\\\ \\xi = -\\frac{d\\phi}{dt}=-\\frac{d}{dt}\\int \\pmb B\\cdot d\\pmb S = -\\frac{d}{dt}\\int \\pmb A\\cdot d\\pmb l = -\\oint \\frac{\\partial A}{\\partial t}d\\pmb l\\\\\\ \\\\ \\therefore \\pmb K=-\\frac{\\partial \\pmb A}{\\partial t}\\\\\\ \\\\ 麦克斯韦发现,\\pmb K=\\pmb E_旋\\\\\\ \\\\ \\therefore \\pmb E_旋=-\\frac{\\partial \\pmb A}{\\partial t}\\\\\\ \\\\ 又\\because \\pmb E_势 = -\\nabla U\\\\\\ \\\\ \\therefore \\pmb E = \\pmb E_势 + \\pmb E_旋 = -\\nabla U - \\frac{\\partial \\pmb A}{\\partial t}\\ $$\n电子加速器 $$ 设轨道处的磁场为B(R),运动轨道内的平均磁场为\\overline B\\\\\\ \\\\ 有evB(R) = \\frac{mv^2}{R}\\longrightarrow B(R)=\\frac{mv}{eB}\\\\\\ \\\\ \\xi = -\\frac{d\\phi}{dt}=\\int \\pmb E_旋\\cdot d\\pmb l \\\\\\ \\\\ \\therefore \\pmb E_旋 = -\\frac{1}{2\\pi R}\\frac{d\\phi}{dt}\\\\\\ \\\\ 根据牛顿第二定律 \\frac{d(mv)}{dt}=F=-e E_旋 = \\frac{e}{2\\pi R}\\frac{d\\phi}{dt}\\\\\\ \\\\ d(mv) = \\frac{e}{2\\pi R}d\\phi\\\\\\ \\\\ 设v_0=0,\\phi_0=0,有\\\\\\ \\\\ mv = \\frac{e}{2\\pi R}\\phi = \\frac{e}{2\\pi R}\\pi R^2 \\overline B\\longrightarrow \\overline B = \\frac{2mv}{eB}\\\\\\ \\\\ \\therefore B(R) = \\frac{1}{2}\\overline B\\ $$\n三、互感和自感 3.1 互感系数 图示 推导 $$ 易知: \\Phi_{12}=M_{12}I_1,\\Phi_{21}=M_{21}I_2]\\\\\\ \\\\ \\Phi_{12}=\\oint \\pmb A\\cdot d\\pmb l=\\oint\\frac{\\mu_0I_1}{4\\pi}\\oint\\frac{d\\pmb l_1}{r_{12}}d\\pmb l_2\\\\\\ \\\\ \\Phi_{12}=\\frac{\\mu_0I_1}{4\\pi}\\oint\\oint\\frac{d\\pmb l_1\\cdot d\\pmb l_2}{r_{12}}\\\\\\ \\\\ \\therefore M_{12}=\\frac{\\Phi_{12}}{I_1}=\\frac{\\mu_0}{4\\pi}\\oint\\oint\\frac{d\\pmb l_1\\cdot d\\pmb l_2}{r_{12}}\\\\\\ \\\\ 同理：M_{12}=M_{21} $$\n单位 $$ 1H=\\frac{1Wb}{1A}=\\frac{1V\\cdot 1s}{1A}\\\\\\ \\\\ 1mH=10^{-3}H,1\\mu H=10^{-6}H $$\n3.2 自感 定义 电生磁，磁再生电，影响原电动势 推导 $$ 我们知道: \\Phi=LI \\\\\\ \\\\ 根据电磁感应定理: \\xi = -\\frac{d\\Phi}{dt}=-L\\frac{dI}{dt}\\\\\\ \\\\ $$\n其中比例系数L与线圈的大小、几何形状、匝数有关 互感与自感的关系(无漏磁) $$ 根据(1)式：M=\\frac{N_1\\Phi_{21}}{I_2}=\\frac{N_2\\Phi_{12}}{I_1}\\\\\\ \\\\ 又\\because L_1=\\frac{N_1\\Phi_1}{I_1},L_2=\\frac{N_2\\Phi_2}{I_2}\\\\\\ \\\\ \\therefore M^2=L_1L_2\\longrightarrow \\pmb{M=\\sqrt{L_1L_2}}\\\\\\ \\\\ 在有漏磁的情况下，M\\lt \\sqrt{L_1L_2} $$\n3.3 两个线圈串联的自感系数 顺接与反接 产生的磁场方向相同为顺接，相反为反接 推导 $$ 顺接时\\\\\\ \\\\ \\xi_1+\\xi_{21}=-L_1\\frac{dI}{dt}-M\\frac{dI}{dt}\\\\\\ \\\\ \\xi_2+\\xi_{12}=-L_2\\frac{dI}{dt}-M\\frac{dI}{dt}\\\\\\ \\\\ 总电动势\\xi=-(L_1+L_2+2M)\\frac{dI}{dt}\\\\\\ \\\\ \\therefore 总自感\\pmb{L = L_1+L_2+2M}\\\\\\ \\\\ 反接时 \\\\\\ \\\\ \\pmb{L = L_1+L_2-2M} $$\n3.4 自感磁能与互感磁能 自感磁能 $$ 对于一个线圈来说,在电压增大过程中抵抗其自感电动势所做的功为\\\\\\ \\\\ dW = -\\xi_i i dt\\\\\\ \\\\ 其中 \\xi_i=-L\\frac{dI}{dt}\\\\\\ \\\\ \\therefore dW = Lidi\\\\\\ \\\\ \\pmb{W=\\int dW=\\int_0^I Lidi=\\frac{1}{2}LI^2},称为自感磁能 $$\n互感磁能 $$ 同理，互感磁能应为\\pmb{W=MI_1I_2}\\\\\\ \\\\ 因此互感线圈 的总磁能为\\\\\\ \\\\ \\pmb{W=\\frac{1}{2}L_1I^2+\\frac{1}{2}L_2I^2+MI_1I_2} $$\n","date":"2022-11-26T18:45:06+08:00","permalink":"https://example.com/p/%E7%94%B5%E7%A3%81%E6%84%9F%E5%BA%94/","title":"电磁感应"},{"content":"[toc]\n一 论文 1.1 论文结构1 Abstrat Introduction 引出问题 介绍问题背景 前人的解决方案 前人的局限性 Content\nMethod (Methodology) / Problem Setup\nResults\nDiscussion\nConclusion\nReferences\n引用论文\n代码\n1.2 建议 适当使用自创词 连字符型自创词 首字母大写型自创词 数据来源 使用数学模型创造 官方网站的数据 重要词汇可以加粗或者斜体 1.2 文章 第一篇范文 A model for sea level rise fore I Introduction 分析问题 介绍背景 过去的研究及其不足 我们找到了新的突破口 引用公式 $\\Delta V=W(\\frac{1}{\\rho_{water}}-\\frac{1}{\\rho_{ocean}})$\n引出模型 忽略较小量\n突出该模型优势\n建立模型 模型的obejectives\n模型的应用和局限性\n提出假设 即建立模型的理论条件(只考虑哪些因素) 定义问题 II Method(Methodology) 建模步骤流程图\n介绍流程\n数学模型中各个数据\n图像\n公式推导\n模型的构建详细说明\n应用\nIII Results IV Discussion and Conclusion V Recommendations 第二篇范文 A Difficulty Metric and Puzzle Generator for Sodoku2 I Abstract II Content III Introduction IV Problem Setup 提出假设(理想情况)\n定义问题\nV A Difficulty Metric 继续假设，定义算法\n介绍算法\n介绍步骤 重要公式的来源/证明 分析 用算法解决具体问题 分析优缺点(此文分析runtime) VI Generator 提出假设\n提出算法\n介绍Pseudo-generator\n如何生成puzzle 和standard generator的不同 Benefits 结果和分析 standard结果 Pseudo结果 Conclusion 优点 缺点 更多方案和future work VII Appendix VIII References 二、经验总结与学习方向 2.1 经验总结 认真审题 时间长不要紧，题目一定要看懂 明确分工,提高效率 分工可以有重复 明确接下来的学习方向 学习LaTeX并熟练掌握\n以下结构均要放在目录中,abstract可以放在目录前\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nAbstract 和 Content 不用标号\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-11-25T17:18:37+08:00","permalink":"https://example.com/p/%E6%95%B0%E6%A8%A1%E8%A6%81%E7%82%B9/","title":"数模要点"},{"content":"[toc]\n一、什么是git 定义\n开源的分布式版本控制系统 特点\n分布式 按元数据方式存储数据 内容完整性高 二、git的工作流程 stateDiagram 资源库 --\u003e 工作副本:clone 工作副本 --\u003e 修改工作副本: 编辑、添加、删除 资源库 --\u003e 修改工作副本: 更新 修改工作副本 --\u003e 检查修改: 查看status, change 检查修改 --\u003e 提交修改: push 提交修改 --\u003e 修改错误: push,change 修改错误 --\u003e 资源库: push 提交修改 --\u003e 资源库: push 三、git创建仓库 创建 git init \u0026lt;repo\u0026gt;创建仓库repo\n生成.git目录\n纳入版本控制 git add \u0026lt;file\u0026gt;让git对文件进行跟踪\n该操作支持正则表达式 git commit -m \u0026lt;file\u0026gt; 提交文件\n复制 git clone \u0026lt;repo\u0026gt; (\u0026lt;dir\u0026gt;)将仓库repo拷贝到dir目录 配置 git config显示当前的git配置信息\ngit config -e针对当前仓库编辑文件\ngit config -e --global针对系统中所有的仓库\n设置全局用户信息\n1 2 git config --global user.name \u0026lt;name\u0026gt; git config --global user.email \u0026lt;email\u0026gt; 四、git基本操作 示意图 stateDiagram workspace --\u003e staging_area: add staging_area --\u003e lcoal_repository: commit lcoal_repository --\u003e remote_repository: push remote_repository --\u003e lcoal_repository: fetch/clone lcoal_repository --\u003e workspace: checkout remote_repository --\u003e workspace: pull 简单的操作步骤 1 2 3 git init # 初始化仓库 git add . # 将文件添加到暂存区 git commit # 将暂存区内容添加到仓库 提交和修改 git add git add [file1] [file2] \u0026hellip; 添加多个文件到暂存区 git add [dir] 添加目录到暂存区 git add . 添加当前目录下所有文件到暂存区 git diff git diff [file] 显示暂存区和工作区的差异 git diff \u0026ndash;cache(staged 也可) [file] 显示暂存区和上一次提交的差异 git diff [first-branch]\u0026hellip;[second branch] 显示两次提交之间的差异 git commit git commit -m [message] 提交暂存区到本地仓库 git commit [file1] [file2] \u0026hellip; -m [message] 提交暂存区的指定文件到本地仓库 git commit -a 不需要git add直接提交 git reset git reset HEAD 回退所有内容到上一个版本 git reset HEAD [file] 回退文件file到上一个版本 git reset \u0026ndash;soft HEAD~n 回退到前n个版本 git reset \u0026ndash;hard HEAD 撤销工作区中所有未提交的修改内容 HEAD^中^的个数表示前几个版本\nHEAD~n可以取代上面的方式\nmessage为备注信息\n其他指令 git status 查看仓库状况，显示有变更的文件 git rm 从暂存区和工作区中删除文件 git mv 移动或重命名工作区文件 提交日志 git log git log \u0026ndash;oneline 查看历史提交记录的简洁形式 git log \u0026ndash;graph 拓朴图形式查看历史提交记录 git blame \u0026lt;file\u0026gt;查看指定文件的修改记录 远程操作 git remote git remote -v 显示所有远程仓库 git remote show [remote] 显示某个远程仓库信息 git remote add [shortname] [url] 添加远程版本库 git remote rm name 删除远程仓库 git remote rename [old_name] [new_name] 修改仓库名 git fetch git fetch [alias]提取更新数据\n执行完后需要git merge branch从远程仓库提取数据并尝试合并到当前分支\ngit pull 1 git pull [远程主机名] [远程分支名]:[本地分支名] 将远程主机的分支拉过来与本地分支合并 若远程分支与当前分支合并，则冒号后可以省略 git push 1 git push [远程主机名] [本地分支名]:[远程分支名] 将本地分支推送到远程主机\n参数\n\u0026ndash;force 强制推送 \u0026ndash;delete 删除主机分支 五、git分支管理 创建分支 git branch \u0026lt;name\u0026gt;创建分支 git branch列出分支 切换分支 git checkout \u0026lt;name\u0026gt; 分支合并 git merge \u0026lt;branch\u0026gt; 将分支branch合并到当前所在分支中 合并冲突 删除分支 git branch -d \u0026lt;name\u0026gt; ","date":"2022-11-25T05:07:46+08:00","permalink":"https://example.com/p/git/","title":"Git"},{"content":"[toc]\n一、算法 定义\n解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列 特性\n有穷性 确定性 可行性 算法效率的度量\n运行时间\n取决于算法的好坏与问题的输入规模（输入量） 算法时间复杂度\n大O记法\n$T(n)=O(f(n))$ T(n)增长最慢的为最优算法 分类与排序 $O(1) \u0026lt; O(log(n))\u0026lt; O(n) \u0026lt; O(nlog(n)) \u0026lt; O(n^2) \u0026lt; O(n^3) \u0026lt; O(n!) \u0026lt; O(n^n)$ 最坏情况与平均情况 一般运行时间为最坏运行时间 平均运行时间是一个期望值 算法空间复杂度\n$S(n)=O(f(n))$ 二、线性表(List) 1.线性表(List)定义 零个或多个数据元素的有限序列 每个元素都有一个直接前驱和直接后继元素 数据元素是一对一的关系 2. 抽象数据类型 Operation IintList(*L); ListEmpty(L); GetElem(L,i,*e); LocateELem(L,e); ListInsert(*L,i,e); ListDelete(*L,i,*e); ListLength(L); endADT 3. 顺序存储结构 定义\n用一段地址连续的存储单元依次存放线性表的数据元素 结构代码\n1 2 3 4 5 6 7 #define MAXSIZE 20 typedef int ElemType typedef struct { ElemType data[MAXSIZE]; //数组存取数据元素 int length; //线性表当前长度 }SqList; 三个属性\n最大长度 当前长度 起始位置 插入与删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //插入 Status ListInsert(SqList *L,int i, ElemType e) { int k; if (L-\u0026gt;length==MAXSIZE) return -1; else if (i\u0026lt;1 || i\u0026gt;L-\u0026gt;length) return -1; else { for(k=L-\u0026gt;Length-1;k-\u0026gt;i-1;k--) L-\u0026gt;data[k+1]=L-\u0026gt;data[k]; } L-\u0026gt;data[i-1]=e; L-\u0026gt;length++; return 0; } //删除 Status ListDelete(SqList *L, int i, ElemType e) { int k; if (L-\u0026gt;length==0) return -1; else if (i\u0026lt;1 || i\u0026gt;L-\u0026gt;length) return -1; *e=L-\u0026gt;data[i-1]; if (i\u0026lt;L-\u0026gt;length) { for(k=i;k\u0026lt;L-\u0026gt;length;k++) L-\u0026gt;data[k+1]=L-\u0026gt;data[k]; } L-\u0026gt;length--; return 0; } 4. 链式存储结构 定义\n结点\n数据域\n存储数据元素信息的域 指针域\n存储直接后继的域 存储的信息称指针(链) 最后一个结点指针为空 头指针\n链表中第一个结点的存储位置 头结点\n在第一个结点前加一个头结点 数据域可以为空 对第一个结点进行的操作可以统一 单链表(每个结点只包含一个指针域的链表)操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 //定义 typedef struct Node { ElemType data; struct Node *next; }Node; typedef struct Node *LinkList; //读取 Status GetElem(LinkList L,int i,ElemType *e) { int j; LinkList p; p = L-\u0026gt;next; j = 1; while (p \u0026amp;\u0026amp; j\u0026lt;i) //p不为空且j小于i的时候 { p = p\u0026gt;-next; j++; } if (!p || j\u0026gt;i) return -1; //第i个元素不存在 *e = p-\u0026gt;data; // 取第i个元素的数据 return 0; } //插入 Status ListInsert(LinkList L,int i,ELemType e) { int j; LinkList,p,s; p =*L; j=1; while(p\u0026amp;\u0026amp;j\u0026lt;i) { p=p-\u0026gt;next; ++j; } if (!p||j\u0026gt;i) return -1; s = (LinkList)malloc(sizeof(Node)); //生成新结点 s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return 0; } //删除 Status ListDelete(LinkList L,int i,ElemType e) { int j; LinkList p,q; p =*L; j=1; while(p=p-\u0026gt;next\u0026amp;\u0026amp;j++\u0026lt;i) ; if (!(p-\u0026gt;next) || j \u0026gt; i) return -1; q = p-\u0026gt;next; p -\u0026gt;next = q-\u0026gt;next; *e = q-\u0026gt;data //回收删除数据 free(q); return 0; } //整表创建 //头插法 void CreateListHead(LinkList *L, int n) { LinkList p; int i; srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; for (i=0;i\u0026lt;n;i++) { p = (LinkList)malloc(sizeof(Node)); p-\u0026gt;data = rand()%100+1; p-\u0026gt;next = (*L) -\u0026gt;next; (*L)-\u0026gt;next = p; } } //尾插法 void CreateListTail(LinkList *L, int n) { LinkList p,r; int i; srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); r = *L; for(i=0;i\u0026lt;n;i++) { p = (Node *)malloc(sizeof(Node)); p-\u0026gt;data = rand()%100+1; r-\u0026gt;next = p; r = p; } r-\u0026gt;next = NULL; } //整表删除 Status ClearList(LinkList *L) { LinkList p,q; *p=(*L)-\u0026gt;next; while(p) { q=p-\u0026gt;next; free(q); p=q; } (*L)-\u0026gt;next=NULL; return 0; } 单链表结构和顺序存储结构的优缺点\n对比/分类 顺序存储结构 单链表 查找 O(1) O(n) 插入和删除 O(n) O(1) 空间 需要预分配，灵活性和安全性低 非常棒 5. 静态链表 定义\n用数组描述的链表 组成\n数据域\n游标(cur)\n第一个游标存放备用链表第一个结点的下标 最后一个游标存放第一个插入元素的下标 特殊称呼\n备用链表\n未被使用的数组元素 操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //定义 #define MAXSIZE 1000 typedef struct { ELemType data; int cur; }Component,StaticLinkList[MAXSIZE]; //初始化 Status InitList(StaticLinkList space) { int i; for(i=0;i\u0026lt;MAXSIZE-1;i++) space[i].cur=i+1; space[MAXSIZE-1].cur=0; return 0; } //插入 Status ListInsert(StaticLinkList L,int i, Elemtype e) { int j,k,l; k=MAXSIZE-1; } 6. 循环链表 定义 将单链表的最后一个指针指向头结点,形成循环链表 合并循环链表 图示 代码 1 2 3 p = rearA-\u0026gt;next; //将A的头结点存起来 rearA-\u0026gt;next = rearB-\u0026gt;next-next;//让A的尾结点指向B的第二个结点，B的头结点被抛弃 rearB-\u0026gt;next = p;//让B的结尾指向A的头结点 7. 双向链表 定义 在每一个结点中设置一个指向其前驱结点的指针的单链表 存储结构 1 2 3 4 5 6 typedef struct DulNode { Elemtype data; struct DulNode *prior; struct DulNode *next; } DulNode,*DulLinkList; 有趣的事实 后继的前驱 = 前驱的后继 = 自己 1 p-\u0026gt;next-\u0026gt;prior = p-\u0026gt;prior-\u0026gt;next = p 操作\n插入图示 删除图示 1 2 3 4 5 6 7 8 9 10 // 插入 s-\u0026gt;prior = p; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next-\u0026gt;prior=s; p-\u0026gt;next=s; //删除 p-\u0026gt;prior-\u0026gt;next=p-\u0026gt;next; p-next-\u0026gt;prior=p-\u0026gt;prior; free(p); ","date":"2022-11-25T00:38:32+08:00","permalink":"https://example.com/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/","title":"线性表"},{"content":"[toc]\n一、磁的基本现象和规律 1.1 磁的库仑定律 $$ 引入磁场强度的概念\\\\\\ \\\\ 定义\\pmb H=\\frac{F}{q_{m0}}\\\\\\ \\\\ \\pmb H=-\\nabla U_{m0}，U_{m0}被称为磁势\\\\\\ \\\\ 与静电学相对应有:\\\\\\ \\\\ \\oint \\pmb H\\cdot d\\pmb l=0\\\\\\ \\\\ \\pmb H=\\frac{\\tau_m}{4\\pi \\mu_0}\\nabla \\Omega\\\\\\ \\\\ \\pmb L=\\pmb{p_m\\times H} $$\n1.2 安培定律 推理\n$$ 对于两段载流导线上的电流元来说\\\\\\ \\\\ dF_{12}\\propto\\frac{I_1dl_1\\cdot I_2dl_2}{r_{12}^2}\\\\\\ \\\\ 其中:d\\pmb l_1=dl_1\\cdot sin\\theta_1，d\\pmb l_2=dl_2\\cdot sin\\theta_2\\\\\\ \\\\ \\therefore dF_{12}=k\\frac{I_1I_2dl_1dl_2sin\\theta_1sin\\theta_2}{r_{12}^2}（其中k取决于单位）\\\\\\ \\\\ d\\pmb F_{12}=k\\frac{I_1I_2d\\pmb l_2\\times(d\\pmb l_1\\times\\pmb r_{12})}{r_{12}^2}(1)\\\\\\ \\\\ 经实验得出:k=\\frac{\\mu_0}{4\\pi} $$\n二、磁感应强度 毕奥萨格尔定律 2.1 磁感应强度B 定义\n根据MSKA单位制 $$ \\pmb B=\\mu_0\\pmb H $$\n表达式和单位\n$$ 根据上述(1)式: d\\pmb F_{12}=\\frac{\\mu_0}{4\\pi}\\frac{I_2d\\pmb l_2\\times(I_1d\\pmb l_1\\times \\pmb r_{12})}{r_{12}^2}\\\\\\ \\\\ 又\\because d\\pmb F_{12}=I_2d\\pmb l_2d\\pmb B\\\\\\ \\\\ \\therefore d\\pmb B=\\frac{\\mu_0}{4\\pi}\\frac{I_1d\\pmb l_1\\times \\pmb r_{12}}{r_{12}^2}\\\\\\ \\\\ 线圈1对于电偶元2的作用力\\\\\\ \\\\ d\\pmb F_2=\\frac{\\mu_0}{4\\pi}I_2d\\pmb l_2\\oint \\frac{I_1d\\pmb l_1\\times\\pmb r_{12}}{r_{12}^2}\\\\\\ \\\\ \\therefore \\pmb B=\\frac{\\mu_0}{4\\pi}\\oint\\frac{I_1d\\pmb l_1\\times\\pmb r_{12}}{r_{12}^2}\\\\\\ \\\\ 其中\\pmb B叫做磁感应强度矢量\\\\\\ \\\\ \\therefore B=\\frac{(dF_{12})_{max}}{I_2dl_2}\\\\\\ \\\\ B的单位为N/A\\cdot m,称为T\\\\\\ \\\\ 1T=10^4Gs $$\n2.2 毕奥萨格尔定律 表达式\n$$ \\pmb B=\\frac{\\mu_0}{4\\pi}\\oint\\frac{I_1d\\pmb l_1\\times\\pmb {\\overrightarrow r}[^1]}{r_{12}^2} $$\n应用\n1.载流直导线\n图示 推导 $$ B = \\int_{A_{1}}^{A_2}\\frac{\\mu_0}{4\\pi}\\frac{Idlsin\\theta}{r^2}\\\\\\ \\\\ 根据几何关系:tan(\\pi-\\theta)=\\frac{r_0}{l}\\\\\\ \\\\ \\therefore dl=\\frac{r_0d\\theta}{sin^2\\theta}\\\\\\ \\\\ \\therefore B=\\frac{\\mu_0}{4\\pi}\\int_{\\theta_1}^{\\theta_2}\\frac{Isin\\theta d\\theta}{r_0}\\\\\\ \\\\ \\pmb{B=\\frac{\\mu_0I}{4\\pi r}(cos\\theta_1-cos\\theta_2)}\\\\\\ \\\\ 当直线无限长时:\\pmb{B=\\frac{\\mu_0 I}{2\\pi r}}\\\\\\ $$\n2.载流圆线圈\n图示 推导 $$ \\\\ dB=\\frac{\\mu_0}{4\\pi}\\frac{Idl}{r^2}=\\frac{\\mu_0}{4\\pi}\\frac{Idl}{r_0^2}sin^2\\alpha\\\\\\ \\\\ B=\\oint dBcos\\alpha=\\oint\\frac{\\mu_0}{4\\pi}\\frac{Idl}{r_0^2}sin^2\\alpha cos\\alpha\\\\\\ \\\\ \\therefore \\pmb {B=\\frac{\\mu_0R^2I}{2(R^2+r_0^2)^{3/2}}}\\\\\\ \\\\ 当P点在球心时:\\pmb{B=\\frac{\\mu_0I}{2R}}\\\\\\ \\\\ 当P点在无穷远处:\\pmb{B=\\frac{\\mu_0R^2I}{2r_0^3}} $$\n载有环向电流的圆筒 图示\n推导\n$$ \\\\ 设半径为R，总长度为L,电流的线密度为\\iota\\\\\\ \\\\ 取轴线为x轴，中点为原点\\\\\\ \\\\ 对于x处的P点\\\\\\ \\\\ dB=\\frac{\\mu_0R\\iota \\cdot dl}{2(R^2+(x-l)^2)^{3/2}}\\\\\\ \\\\ B = \\int_{-L/2}^{L/2}dB\\\\\\ \\\\ 其中: 距离r=\\sqrt{R^2+(x-l)^2}\\\\\\ \\\\ \\frac{x-l}{R}=cot\\beta\\longrightarrow dl=\\frac{Rd\\beta}{sin^2\\beta}\\\\\\ \\\\ \\therefore \\pmb{B=\\frac{\\mu_0\\iota}{2}(cos\\beta_1-cos\\beta_2)}\\\\\\ \\\\ cos\\beta_1=\\frac{x+L/2}{\\sqrt{R^2+(x+L/2)^2}}，cos\\beta_2=\\frac{x-L/2}{\\sqrt{R^2+(x-L/2)^2}}\\\\\\ \\\\ 当螺线管无限长:\\pmb{B=\\mu_0\\iota}\\\\\\ \\\\ 在无限长螺线管的 一端:\\pmb {B=\\frac{\\mu_0\\iota}{2}}\\\\\\ \\\\ 其中，电流线密度\\iota=nI\\\\\\ \\\\ \\therefore 对于无限长螺线管有:B=\\mu_0nI\\\\\\ $$\n2.3 安培环路定律(暂定) 结论\n$$ \\oint \\pmb B\\cdot d\\pmb l=\\mu_0I\\\\\\ \\\\ 或\\pmb B=\\frac{\\mu_0I}{4\\pi}\\nabla\\Omega $$\n三、磁场对载流导线的作用 3.1 安培力与无限长直导线之间的作用 安培力\n$$ d\\pmb F=Id\\pmb l\\times\\pmb B $$\n无限长直导线\n图像\n推导\n$$ \\\\ dF_{12}= I_2dl_2B_1=\\frac{\\mu_0I_1I_2}{2\\pi a}dl_2\\\\\\ \\\\ 同理: dF_{21}=\\frac{\\mu_0I_1I_2}{2\\pi a}dl_1\\\\\\ \\\\ \\therefore 单位作用力f=\\frac{dF_{12}}{dl_2}=\\frac{\\mu_0I_1I_2}{2\\pi a} $$\n3.2 矩形载流线圈所受力矩 图示\n推导\n$$ \\\\ F_{AB}=F_{CD}相互抵消\\\\\\ \\\\ L = F_{BC}\\frac{a}{2}sin\\theta+F_{AD}\\frac{a}{2}sin\\theta\\\\\\ \\\\ L = BIbasin\\theta=IBSsin\\theta\\\\\\ \\\\ \\therefore\\pmb L=IS(\\pmb{n\\times B})\\\\\\ $$\n3.3 载流线圈的磁矩 图示\n推导\n$$ \\\\ dl_1sin\\theta_1=dl_2sin\\theta_2=dh\\\\\\ \\\\ dF_{12}=Idl_1Bsin\\theta_1;dF_{21}=Idl_2Bsin\\theta_2\\\\\\ \\\\ \\therefore dF_{12}=dF_{21}=IBdh\\\\\\ \\\\ \\therefore dL=dF_{12}\\cdot x_1+dF_{21}\\cdot x_2=IBdh(x_1+x_2)\\\\\\ \\\\ L = IBS\\\\\\ \\\\ 其中，m=IS\\longrightarrow\\pmb m=IS\\pmb n\\\\\\ \\\\ \\\\\\therefore\\pmb{\\pmb L = m\\times B}\\\\\\ $$\n3.4 磁偶极子和载流线圈的等价性(待定) 四、带电粒子在磁场中的运动 4.1 洛伦兹力 定义\n根据实验有 $$ \\pmb F=q\\ \\pmb{v\\times B}\\\\\\ \\\\ F = |q|\\ vB\\ sin\\theta $$\n洛伦兹力和安培力的关系\n$$ \\\\ 设自由电子移动速度为u,单位体积的自由电子数为n\\\\\\ \\\\ 在时间\\Delta t内通过面S的电子数为n\\Delta V = nSu\\Delta t\\\\\\ \\\\ 电量\\Delta q = enSu\\Delta t\\\\\\ \\\\ I = \\frac{\\Delta q}{\\Delta t}= enSu\\\\\\ \\\\ 每个电子的洛伦兹力为\\\\\\ \\\\ F=evB\\\\\\ \\\\ F_{总}=nS\\Delta l F=(ensv)\\Delta l B=BI\\Delta l $$\n4.2 带电粒子在磁场中的运动 当 $\\pmb{v\\perp B}$\n$$ qvB=m\\frac{v^2}{R}\\\\\\ \\\\ \\pmb{R=\\frac{mv}{qB}}，\\pmb{T=\\frac{2\\pi m}{qB}} $$\n普遍情形\n图示 推导 $$ h=v_{//}T=\\frac{2\\pi mv}{qB} $$\n磁聚焦 由于$v_{//}$相同，一段时间后这些粒子又会聚集在一起 4.3 荷质比 汤姆孙法\n图示 推导 $$ \\\\ eE=evB\\longrightarrow v=\\frac{E}{B}\\\\\\ \\\\ R=\\frac{mv}{eB}\\\\\\ \\\\ \\frac{e}{m}=\\frac{v}{RB}=\\frac{E}{RB^2}\\\\\\ \\\\ 实验结果:\\frac{e}{m}=1.759\\times 10^{11}C/kg $$\n磁聚焦法\n图示 推导\n$$ \\\\ \\frac{1}{2}mv^2=e\\Delta U\\\\\\ \\\\ v = \\sqrt{\\frac{2e\\Delta U}{m}}\\\\\\ \\\\ h = \\frac{2\\pi m v}{eB}\\\\\\ \\\\ \\therefore \\frac{e}{m}=\\frac{8\\pi^2\\Delta U}{l^2B^2} $$\n","date":"2022-11-24T23:25:35+08:00","permalink":"https://example.com/p/%E6%81%92%E7%A3%81%E5%9C%BA/","title":"恒磁场"}]